{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-scheduler-core\n * Generated: 2021-06-24\n * Version: 2.7.6\n * License: https://js.devexpress.com/Licensing\n */\nimport moment from 'moment';\nimport { RRuleSet, RRule } from 'rrule';\nimport { slice } from '@devexpress/dx-core';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n/** @deprecated */\n\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar computed = function (getters, viewName, baseComputed, defaultValue) {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n\n  return baseComputed(getters, viewName);\n};\n\nvar toPercentage = function (value, total) {\n  return value * 100 / total;\n};\n\nvar createExcludedInterval = function (day, start) {\n  var leftBound = moment(start.day(day));\n  return [leftBound, moment(leftBound).hour(start.hour()).endOf('day')];\n};\n\nvar excludedIntervals = function (excludedDays, start) {\n  return excludedDays.map(function (day) {\n    return day === 0 ? 7 : day;\n  }).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, day, i, allDays) {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[acc.length - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n\n    return acc;\n  }, []);\n};\n\nvar inInterval = function (date, interval) {\n  return date.isBetween(interval[0], interval[1], undefined, '[]');\n};\n\nvar viewPredicate = function (appointment, left, right, excludedDays, removeAllDayAppointments) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  if (removeAllDayAppointments === void 0) {\n    removeAllDayAppointments = false;\n  }\n\n  var start = appointment.start,\n      end = appointment.end;\n  var isAppointmentInBoundary = end.isAfter(left) && start.isBefore(right);\n  var isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left)).find(function (interval) {\n    return inInterval(start, interval) && inInterval(end, interval);\n  });\n  var considerAllDayAppointment = removeAllDayAppointments ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay : true;\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nvar calculateFirstDateOfWeek = function (currentDate, firstDayOfWeek, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: {\n      dow: firstDayOfWeek,\n      doy: 1\n    }\n  });\n  var firstDateOfWeek = moment(currentDate).startOf('week');\n\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach(function (day) {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n\n  moment.locale(currentLocale);\n  return firstDateOfWeek.toDate();\n};\n\nvar getAppointmentStyle = function (_a) {\n  var top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n  return {\n    height: height,\n    width: width + \"%\",\n    transform: \"translateY(\" + top + \"px)\",\n    msTransform: \"translateY(\" + top + \"px)\",\n    left: left + \"%\",\n    position: 'absolute'\n  };\n};\n\nvar expandRecurrenceAppointment = function (appointment, leftBound, rightBound) {\n  var rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  var leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  var appointmentStartDate = moment(appointment.start).toDate();\n\n  var options = __assign(__assign({}, RRule.parseString(appointment.rRule)), {\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate()\n  });\n\n  var correctedOptions = options.until ? __assign(__assign({}, options), {\n    until: moment(getUTCDate(options.until)).toDate()\n  }) : options;\n  var rruleSet = getRRuleSetWithExDates(appointment.exDate);\n  rruleSet.rrule(new RRule(correctedOptions)); // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n\n  var datesInBoundaries = rruleSet.between(leftBoundUTC, rightBoundUTC, true).map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n  var appointmentDuration = moment(appointment.end).diff(appointment.start, 'minutes');\n  return datesInBoundaries.map(function (startDate, index) {\n    return __assign(__assign({}, appointment), {\n      dataItem: __assign(__assign({}, appointment.dataItem), {\n        startDate: moment(startDate).toDate(),\n        endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n        parentData: appointment.dataItem\n      }),\n      start: moment(startDate),\n      end: moment(startDate).add(appointmentDuration, 'minutes'),\n      key: appointment.key + \"_rec_\" + index\n    });\n  });\n};\n\nvar filterByViewBoundaries = function (appointment, leftBound, rightBound, excludedDays, removeAllDay) {\n  var appointments = [appointment];\n\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(appointment, leftBound, rightBound);\n  }\n\n  return appointments.filter(function (appt) {\n    return viewPredicate(appt, leftBound, rightBound, excludedDays, removeAllDay);\n  });\n};\n\nvar getUTCDate = function (date) {\n  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());\n};\n\nvar getRRuleSetWithExDates = function (exDate) {\n  var rruleSet = new RRuleSet();\n\n  if (exDate) {\n    exDate.split(',').map(function (date) {\n      var currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n\n  return rruleSet;\n};\n\nvar formatDateToString = function (date) {\n  return moment.utc(date).format('YYYY-MM-DDTHH:mm');\n};\n\nvar addDateToKey = function (prevKey, momentDate) {\n  return prevKey + \"_\" + momentDate.toDate().toString();\n};\n\nvar VERTICAL_TYPE = 'vertical';\nvar HORIZONTAL_TYPE = 'horizontal';\nvar SCROLL_OFFSET = 50;\nvar SCROLL_SPEED_PX = 15;\nvar SECONDS = 'seconds';\nvar MINUTES = 'minutes';\nvar HOURS = 'hours';\nvar RESIZE_TOP = 'resize-start';\nvar RESIZE_BOTTOM = 'resize-end';\nvar POSITION_START = 'start';\nvar POSITION_END = 'end';\nvar AUTO_HEIGHT = 'auto';\nvar DAY_OPTIONS = {\n  day: 'numeric'\n};\nvar WEEK_DAY_OPTIONS = {\n  weekday: 'short'\n};\nvar SHORT_MONTH_OPTIONS = {\n  month: 'short'\n};\nvar HOUR_MINUTE_OPTIONS = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\nvar MONTH_YEAR_OPTIONS = {\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'short'\n};\nvar SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  month: 'short',\n  year: 'numeric'\n};\nvar SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  month: 'short',\n  year: '2-digit'\n};\nvar DAY_LONG_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: '2-digit'\n};\nvar LONG_WEEK_DAY_OPTIONS = {\n  weekday: 'long'\n};\nvar LONG_MONTH_OPTIONS = {\n  month: 'long'\n};\nvar DAY_LONG_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'long'\n};\nvar EMPTY_OPTIONS = {};\nvar RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current'\n};\nvar TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nvar TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\nvar WEEKDAY_INTERVAL = 'weekdayInterval';\nvar VERTICAL_VIEW_LEFT_OFFSET = 80;\nvar HORIZONTAL_VIEW_LEFT_OFFSET = 0;\nvar VERTICAL_GROUP_ORIENTATION = 'Vertical';\nvar HORIZONTAL_GROUP_ORIENTATION = 'Horizontal';\nvar VIEW_TYPES = {\n  MONTH: 'month',\n  WEEK: 'week',\n  DAY: 'day',\n  ALL_DAY_PANEL: 'allDayPanel'\n};\nvar MONTH_TYPE = 'month';\n\nvar getViewType = function (currentViewType) {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nvar isMidnight = function (date) {\n  var momentDate = moment(date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nvar calculateTextByDays = function (startViewDate, endViewDate, formatDate, additionalOptions) {\n  var momentStartViewDate = moment(startViewDate);\n  var momentEndViewDate = moment(endViewDate);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), __assign(__assign({}, DAY_LONG_MONTH_LONG_YEAR_OPTIONS), additionalOptions));\n  }\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return formatDate(momentStartViewDate.toDate(), DAY_OPTIONS) + \"-\" + formatDate(momentEndViewDate.toDate(), DAY_OPTIONS) + \" \" + formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS);\n    }\n\n    return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar calculateTextByMonths = function (currentDate, intervalCount, formatDate) {\n  var momentCurrentDate = moment(currentDate);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n\n  var lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS) + \"-\" + formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar viewBoundText = function (startViewDate, endViewDate, type, currentDate, intervalCount, formatDate) {\n  return type !== 'month' ? calculateTextByDays(startViewDate, endViewDate, formatDate, type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS) : calculateTextByMonths(currentDate, intervalCount, formatDate);\n};\n\nvar checkCellGroupingInfo = function (cell, appointment) {\n  return cell.groupingInfo ? cell.groupingInfo.every(function (group) {\n    return group.id === appointment[group.fieldName];\n  }) : true;\n};\n\nvar isDateValid = function (date) {\n  return moment(date).isValid();\n};\n\nvar convertToMoment = function (date) {\n  return moment(date);\n};\n\nvar areDatesSame = function (firstDate, secondDate) {\n  return moment(firstDate).isSame(secondDate, 'date');\n};\n\nvar getTimeTableHeight = function (timeTableElementsMeta) {\n  var _a;\n\n  return (_a = timeTableElementsMeta.parentRect) === null || _a === void 0 ? void 0 : _a.call(timeTableElementsMeta).height;\n};\n\nvar containsDSTChange = function (date) {\n  var momentDate = moment(date);\n  momentDate.startOf('day');\n  var isStartDST = momentDate.isDST();\n  momentDate.endOf('day');\n  var isEndDst = momentDate.isDST();\n  return isStartDST && !isEndDst || !isStartDST && isEndDst;\n};\n\nvar subtractSecond = function (date) {\n  return moment(date).subtract(1, 'second').toDate();\n};\n\nvar dayScale = function (currentDate, firstDayOfWeek, dayCount, excluded) {\n  if (excluded === void 0) {\n    excluded = [];\n  }\n\n  var result = [];\n  var date = firstDayOfWeek !== undefined ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded)) : moment(currentDate);\n\n  for (var index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(function (item) {\n      return item === date.day();\n    }) === -1) {\n      result.push(date.toDate());\n    }\n\n    date.add(1, 'days');\n  }\n\n  return result;\n};\n\nvar timeScale = function (currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays) {\n  var result = [];\n  var startDateOfView = firstDayOfWeek !== undefined ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) : currentDate;\n  var isDSTChange = containsDSTChange(startDateOfView);\n  var validDate = moment(startDateOfView);\n\n  if (isDSTChange) {\n    validDate.subtract(1, 'day');\n  }\n\n  var left = moment(validDate).startOf('day').add(startDayHour, 'hour');\n  var right = moment(validDate).startOf('day').add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    var startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({\n      start: startDate,\n      end: left.toDate()\n    });\n  }\n\n  var timeScaleLastIndex = result.length - 1;\n\n  if (isMidnight(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end);\n  }\n\n  return result;\n};\n\nvar availableViews = function (views, viewName, viewDisplayName) {\n  if (!views) return [{\n    name: viewName,\n    displayName: viewDisplayName\n  }];\n\n  if (views.findIndex(function (view) {\n    return viewName === view.name;\n  }) === -1) {\n    var nextViews = views.slice();\n    nextViews.push({\n      name: viewName,\n      displayName: viewDisplayName\n    });\n    return nextViews;\n  }\n\n  return views;\n};\n\nvar viewCellsData = function (currentDate, firstDayOfWeek, dayCount, excludedDays, startDayHour, endDayHour, cellDuration, currTime) {\n  var days = dayScale(currentDate, firstDayOfWeek, dayCount, excludedDays);\n  var times = timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays);\n  var currentTime = moment(currTime);\n  return times.reduce(function (cellsAcc, time) {\n    var start = moment(time.start);\n    var end = moment(time.end);\n    var rowCells = days.reduce(function (rowAcc, day) {\n      var startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      var endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      var today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({\n        startDate: startDate,\n        endDate: endDate,\n        today: today\n      });\n      return rowAcc;\n    }, []);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, []);\n};\n\nvar timeCellsData = function (cellsData, startDayHour, endDayHour, cellDuration, currentTime) {\n  var firstViewDate = cellsData[0][0].startDate;\n\n  if (!containsDSTChange(firstViewDate)) {\n    return cellsData;\n  }\n\n  var nextDay = moment(firstViewDate).add(1, 'day').toDate();\n  var validCellsData = viewCellsData(nextDay, undefined, 1, [], startDayHour, endDayHour, cellDuration, currentTime);\n  return validCellsData;\n};\n\nvar allDayCells = function (viewCells) {\n  return [viewCells[0].map(function (cell) {\n    return {\n      startDate: moment(cell.startDate).startOf('day').toDate(),\n      endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),\n      groupingInfo: cell.groupingInfo,\n      endOfGroup: cell.endOfGroup\n    };\n  })];\n};\n\nvar startViewDate = function (viewCells) {\n  return moment(viewCells[0][0].startDate).toDate();\n};\n\nvar endViewDate = function (viewCells) {\n  var lastRowIndex = viewCells.length - 1;\n  var lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate);\n};\n\nvar MAX_WIDTH = 1;\nvar INDIRECT_CHILD_LEFT_OFFSET = 0.05;\n\nvar isAllDayElementsMetaActual = function (viewCellsData, allDayElementsMeta, groupOrientation, groupCount) {\n  var numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;\n  return isElementsMetaActual(viewCellsData, allDayElementsMeta, numberOfRows);\n};\n\nvar isTimeTableElementsMetaActual = function (viewCellsData, timeTableElementsMeta) {\n  return isElementsMetaActual(viewCellsData, timeTableElementsMeta, viewCellsData.length);\n};\n\nvar isElementsMetaActual = function (viewCellsData, elementsMeta, numberOfRows) {\n  if (!(elementsMeta === null || elementsMeta === void 0 ? void 0 : elementsMeta.getCellRects)) {\n    return false;\n  }\n\n  var tableSize = numberOfRows * viewCellsData[0].length;\n  return tableSize === elementsMeta.getCellRects.length;\n};\n\nvar appointmentHeightType = function (appointment, cellDuration) {\n  var durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nvar horizontalRectCalculator = function (appointment, viewMetaData, _a) {\n  var getRectByAppointment = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      cellElementsMeta = _b.cellElementsMeta,\n      viewCellsData = _b.viewCellsData;\n\n  var _c = getRectByAppointment(appointment, viewMetaData, {\n    multiline: multiline,\n    cellElementsMeta: cellElementsMeta,\n    viewCellsData: viewCellsData\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  return {\n    resources: appointment.resources,\n    top: top + height / appointment.reduceValue * appointment.offset,\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE,\n    key: appointment.key\n  };\n};\n\nvar verticalRectCalculator = function (appointment, viewMetaData, _a) {\n  var getRectByAppointment = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      viewCellsData = _b.viewCellsData,\n      cellDuration = _b.cellDuration,\n      cellElementsMeta = _b.cellElementsMeta,\n      excludedDays = _b.excludedDays;\n\n  var _c = getRectByAppointment(appointment, viewMetaData, {\n    multiline: multiline,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    excludedDays: excludedDays,\n    cellElementsMeta: cellElementsMeta\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  var offset = appointment.offset,\n      relativeWidth = appointment.width,\n      relativeLeft = appointment.left;\n  var widthMultiplier = relativeWidth * 5 / 3 + relativeLeft <= 1 ? 5 / 3 : 1;\n  var validWidth = widthMultiplier === 5 / 3 ? widthMultiplier * relativeWidth : relativeWidth + 0.02;\n\n  if (validWidth + relativeLeft > 1) {\n    validWidth = 1 - relativeLeft;\n  }\n\n  return {\n    resources: appointment.resources,\n    top: top,\n    height: height,\n    left: toPercentage(left + relativeLeft * width, parentWidth),\n    width: toPercentage(validWidth * width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    offset: offset,\n    key: appointment.key\n  };\n};\n\nvar oldVerticalRectCalculator = function (appointment, viewMetaData, _a) {\n  var getRectByAppointment = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      viewCellsData = _b.viewCellsData,\n      cellDuration = _b.cellDuration,\n      cellElementsMeta = _b.cellElementsMeta,\n      excludedDays = _b.excludedDays,\n      placeAppointmentsNextToEachOther = _b.placeAppointmentsNextToEachOther;\n\n  var _c = getRectByAppointment(appointment, viewMetaData, {\n    multiline: multiline,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    excludedDays: excludedDays,\n    cellElementsMeta: cellElementsMeta,\n    placeAppointmentsNextToEachOther: placeAppointmentsNextToEachOther\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  var widthInPx = width / appointment.reduceValue;\n  return {\n    resources: appointment.resources,\n    top: top,\n    height: height,\n    left: toPercentage(left + widthInPx * appointment.offset, parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    key: appointment.key\n  };\n};\n\nvar compareByDay = function (first, second) {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nvar compareByAllDay = function (first, second) {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nvar compareByTime = function (first, second) {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nvar sortAppointments = function (appointments) {\n  return appointments.slice().sort(function (a, b) {\n    return compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b);\n  });\n};\n\nvar byDayPredicate = function (boundary, date) {\n  return boundary.isSameOrAfter(date, 'day') && !boundary.isSame(boundary.clone().startOf('day'));\n};\n\nvar findOverlappedAppointments = function (sortedAppointments, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  var appointments = sortedAppointments.slice();\n  var groups = [];\n  var totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    var current = appointments[totalIndex];\n    var currentGroup = groups[groups.length - 1];\n    var next = appointments[totalIndex + 1];\n    var maxBoundary = current.end;\n    currentGroup.push(current);\n    totalIndex += 1;\n\n    while (next && (maxBoundary.isAfter(next.start) || byDay && byDayPredicate(maxBoundary, next.start))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n\n  return groups;\n};\n\nvar isMidnight$1 = function (date) {\n  return date.isSame(date.clone().startOf('day'));\n};\n\nvar maxBoundaryPredicate = function (maxBoundary, startDate) {\n  return maxBoundary.isBefore(startDate, 'day') || isMidnight$1(maxBoundary) && maxBoundary.isSame(startDate, 'day');\n};\n\nvar calculateAppointmentOffsets = function (groups, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  return groups.map(function (items) {\n    var offset = 0;\n    var reduceValue = 1;\n    var appointments = items.map(function (appointment) {\n      return __assign({}, appointment);\n    });\n    var groupLength = appointments.length;\n\n    for (var startIndex = 0; startIndex < groupLength; startIndex += 1) {\n      var appointment = appointments[startIndex];\n\n      if (appointment.offset === undefined) {\n        var maxBoundary = appointment.end;\n        appointment.offset = offset;\n\n        for (var index = startIndex + 1; index < groupLength; index += 1) {\n          if (appointments[index].offset === undefined) {\n            if (!byDay && maxBoundary.isSameOrBefore(appointments[index].start) || byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start)) {\n              maxBoundary = appointments[index].end;\n              appointments[index].offset = offset;\n            }\n          }\n        }\n\n        offset += 1;\n        if (reduceValue < offset) reduceValue = offset;\n      }\n    }\n\n    return {\n      items: appointments,\n      reduceValue: reduceValue\n    };\n  });\n};\n\nvar unwrapAppointmentForest = function (appointmentForests) {\n  var forestUnwrapped = appointmentForests.map(function (_a) {\n    var items = _a.items,\n        reduceValue = _a.reduceValue;\n    return {\n      reduceValue: reduceValue,\n      items: items.map(function (_a) {\n        var data = _a.data;\n        return __assign({}, data);\n      })\n    };\n  });\n  return unwrapGroups(forestUnwrapped);\n};\n\nvar unwrapGroups = function (groups) {\n  return groups.reduce(function (acc, _a) {\n    var items = _a.items,\n        reduceValue = _a.reduceValue;\n    acc.push.apply(acc, __spread(items.map(function (_a) {\n      var start = _a.start,\n          end = _a.end,\n          dataItem = _a.dataItem,\n          offset = _a.offset,\n          resources = _a.resources,\n          key = _a.key,\n          restProps = __rest(_a, [\"start\", \"end\", \"dataItem\", \"offset\", \"resources\", \"key\"]);\n\n      return __assign({\n        start: start,\n        end: end,\n        dataItem: dataItem,\n        offset: offset,\n        reduceValue: reduceValue,\n        resources: resources,\n        fromPrev: moment(start).diff(dataItem.startDate, 'minutes') > 1,\n        toNext: moment(dataItem.endDate).diff(end, 'minutes') > 1,\n        key: key\n      }, restProps);\n    })));\n    return acc;\n  }, []);\n};\n\nvar intervalIncludes = function (intervalStart, intervalEnd, date) {\n  return date.isBetween(intervalStart, intervalEnd, undefined, '[)');\n};\n\nvar createAppointmentForest = function (appointmentGroups, cellDuration) {\n  return appointmentGroups.map(function (appointmentGroup) {\n    var items = appointmentGroup.items;\n    var nextItems;\n    var roots;\n\n    if (items.length === 1) {\n      nextItems = [{\n        data: items[0],\n        children: [],\n        treeDepth: 0,\n        isDirectChild: false,\n        hasDirectChild: false\n      }];\n      roots = [0];\n    } else {\n      var _a = visitRoots(items, cellDuration),\n          appointments = _a.appointments,\n          appointmentTreeRoots = _a.roots;\n\n      nextItems = appointments;\n      roots = appointmentTreeRoots;\n    }\n\n    return __assign(__assign({}, appointmentGroup), {\n      items: nextItems,\n      roots: roots\n    });\n  });\n};\n\nvar visitRoots = function (appointmentItems, cellDuration) {\n  var appointmentNodes = appointmentItems.map(function (props) {\n    return {\n      data: props\n    };\n  });\n  var roots = appointmentNodes.reduce(function (acc, appointment, appointmentIndex) {\n    var appointmentOffset = appointment.data.offset;\n\n    if (appointmentOffset === 0) {\n      if (appointmentIndex + 1 === appointmentNodes.length) {\n        appointment.children = [];\n        appointment.hasDirectChild = false;\n        appointment.treeDepth = 0;\n      } else {\n        appointment.treeDepth = visitAllChildren(appointmentNodes, appointmentIndex, cellDuration, 0);\n      }\n\n      appointment.parent = undefined;\n      appointment.isDirectChild = false;\n      return __spread(acc, [appointmentIndex]);\n    }\n\n    return acc;\n  }, []);\n  return {\n    appointments: appointmentNodes,\n    roots: roots\n  };\n};\n\nvar visitChild = function (appointmentNodes, index, parentAppointmentIndex, cellDuration, isDirectChild, treeDepth) {\n  var appointmentNode = appointmentNodes[index];\n  appointmentNode.isDirectChild = isDirectChild;\n  appointmentNode.parent = parentAppointmentIndex;\n  var nextTreeDepth = treeDepth + 1;\n  var end = appointmentNode.data.end;\n\n  if (index === appointmentNodes.length - 1 || end.isSameOrBefore(appointmentNodes[index + 1].data.start)) {\n    appointmentNode.children = [];\n    appointmentNode.treeDepth = 0;\n    appointmentNode.hasDirectChild = false;\n    return nextTreeDepth;\n  }\n\n  var calculatedTreeDepth = visitAllChildren(appointmentNodes, index, cellDuration, treeDepth);\n  appointmentNode.treeDepth = calculatedTreeDepth;\n  return calculatedTreeDepth + 1;\n};\n\nvar visitAllChildren = function (appointmentNodes, appointmentIndex, cellDuration, treeDepth) {\n  var appointment = appointmentNodes[appointmentIndex];\n  var _a = appointment.data,\n      end = _a.end,\n      appointmentOffset = _a.offset,\n      start = _a.start;\n  var directChildTimeLimit = moment(start).add(cellDuration, 'minutes');\n  var maxAppointmentTreeDepth = 0;\n  var children = [];\n  var nextChildIndex = appointmentIndex + 1;\n\n  while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n    var nextAppointment = appointmentNodes[nextChildIndex];\n    var _b = nextAppointment.data,\n        nextOffset = _b.offset,\n        nextStart = _b.start;\n\n    if (nextOffset === appointmentOffset + 1) {\n      var isDirectChild = intervalIncludes(start, directChildTimeLimit, nextStart);\n      var nextTreeDepth = visitChild(appointmentNodes, nextChildIndex, appointmentIndex, cellDuration, isDirectChild, treeDepth);\n\n      if (maxAppointmentTreeDepth < nextTreeDepth) {\n        maxAppointmentTreeDepth = nextTreeDepth;\n      }\n\n      children.push(nextChildIndex);\n    }\n\n    nextChildIndex += 1;\n  }\n\n  appointment.hasDirectChild = children.length !== 0 && appointmentNodes[children[0]].isDirectChild;\n  appointment.children = children;\n  return maxAppointmentTreeDepth;\n};\n\nvar isPossibleChild = function (appointments, possibleChildIndex, parentEnd, parentOffset) {\n  var possibleChild = appointments[possibleChildIndex];\n  return possibleChildIndex < appointments.length && possibleChild.data.offset !== parentOffset && possibleChild.data.start.isBefore(parentEnd);\n};\n\nvar findMaxReduceValue = function (appointmentGroups) {\n  return appointmentGroups.reduce(function (maxReduceValue, group) {\n    var currentReduceValue = group.reduceValue;\n    return maxReduceValue > currentReduceValue ? maxReduceValue : currentReduceValue;\n  }, 1);\n};\n\nvar calculateAppointmentsMetaData = function (appointmentGroups, indirectChildLeftOffset) {\n  return appointmentGroups.map(function (appointmentForest) {\n    var items = appointmentForest.items,\n        roots = appointmentForest.roots;\n    var firstNode = items[0];\n    return __assign(__assign({}, appointmentForest), {\n      items: items.length === 1 ? [__assign(__assign({}, firstNode), {\n        data: __assign(__assign({}, firstNode.data), {\n          left: 0,\n          width: 1\n        })\n      })] : calculateRootsMetaData(items, roots, indirectChildLeftOffset)\n    });\n  });\n};\n\nvar calculateRootsMetaData = function (appointmentNodes, roots, indirectChildLeftOffset) {\n  var appointments = appointmentNodes.map(function (props) {\n    return __assign({}, props);\n  });\n  roots.forEach(function (appointmentIndex) {\n    var appointment = appointments[appointmentIndex];\n\n    var _a = calculateAppointmentLeftAndWidth(appointments, undefined, appointment, MAX_WIDTH, indirectChildLeftOffset, undefined),\n        left = _a.left,\n        width = _a.width;\n\n    appointment.data.left = left;\n    appointment.data.width = width;\n    calculateChildrenMetaData(appointments, appointment, MAX_WIDTH, indirectChildLeftOffset);\n  });\n  return appointments;\n};\n\nvar calculateChildMetaData = function (appointmentNodes, appointmentIndex, maxWidth, indirectChildLeftOffset) {\n  var appointment = appointmentNodes[appointmentIndex];\n\n  var _a = calculateAppointmentLeftAndWidth(appointmentNodes, undefined, appointment, maxWidth, indirectChildLeftOffset, undefined),\n      left = _a.left,\n      width = _a.width;\n\n  appointment.data.left = left;\n  appointment.data.width = width;\n  calculateChildrenMetaData(appointmentNodes, appointment, maxWidth, indirectChildLeftOffset);\n};\n\nvar calculateChildrenMetaData = function (appointmentNodes, appointmentNode, maxWidth, indirectChildLeftOffset) {\n  appointmentNode.children.forEach(function (childIndex) {\n    calculateChildMetaData(appointmentNodes, childIndex, maxWidth, indirectChildLeftOffset);\n  });\n};\n\nvar calculateAppointmentLeftAndWidth = function (appointmentNodes, blocks, appointmentNode, maxRight, indirectChildLeftOffset, defaultLeft) {\n  var _a;\n\n  var _b = appointmentNode,\n      hasDirectChild = _b.hasDirectChild,\n      treeDepth = _b.treeDepth,\n      isDirectChild = _b.isDirectChild,\n      parentIndex = _b.parent,\n      children = _b.children,\n      blockIndex = _b.blockIndex;\n  var firstChild = appointmentNodes[children[0]];\n  var firstChildBlockIndex = (_a = firstChild) === null || _a === void 0 ? void 0 : _a.blockIndex;\n  var hasDirectChildAndInSameBlock = hasDirectChild && (firstChildBlockIndex === undefined || blockIndex === firstChildBlockIndex || blocks[firstChildBlockIndex].includedInto === blockIndex || maxRight === 1);\n\n  if (parentIndex === undefined) {\n    return {\n      width: hasDirectChildAndInSameBlock ? maxRight / (treeDepth + 1) : maxRight,\n      left: 0\n    };\n  }\n\n  var parent = appointmentNodes[parentIndex];\n  var _c = parent.data,\n      parentWidth = _c.width,\n      parentLeft = _c.left;\n  var calculatedLeft = isDirectChild ? parentLeft + parentWidth : parentLeft + indirectChildLeftOffset;\n  var left = defaultLeft !== undefined ? Math.max(defaultLeft, calculatedLeft) : calculatedLeft;\n  var unoccupiedSpace = maxRight - left;\n  return {\n    width: hasDirectChildAndInSameBlock ? unoccupiedSpace / (treeDepth + 1) : unoccupiedSpace,\n    left: left\n  };\n};\n\nvar prepareToGroupIntoBlocks = function (appointments) {\n  return appointments.map(function (appointmentForest) {\n    var nodes = appointmentForest.items;\n    var appointmentNodes = nodes.map(function (props) {\n      return __assign({}, props);\n    });\n    appointmentNodes.forEach(function (appointmentNode, index) {\n      if (index === 0) {\n        appointmentNode.overlappingSubTreeRoots = [];\n        return;\n      }\n\n      var overlappingSubTreeRoots = [];\n      var _a = appointmentNode.data,\n          appointmentOffset = _a.offset,\n          end = _a.end;\n      var nextChildIndex = index + 1;\n      var currentBlockEnd;\n\n      while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n        var nextAppointment = appointmentNodes[nextChildIndex];\n\n        if (nextAppointment.data.offset < appointmentOffset && nextAppointment.maxOffset === undefined) {\n          nextAppointment.maxOffset = appointmentOffset;\n        }\n\n        var previousSubTreeRoot = overlappingSubTreeRoots.length > 0 ? appointmentNodes[overlappingSubTreeRoots[overlappingSubTreeRoots.length - 1]] : undefined;\n\n        if (isOverlappingSubTreeRoot(appointmentNode, nextAppointment, previousSubTreeRoot, currentBlockEnd)) {\n          overlappingSubTreeRoots.push(nextChildIndex);\n          nextAppointment.overlappingSubTreeRoot = true;\n          var maxChildDate = findChildrenMaxEndDate(appointmentNodes, nextAppointment);\n\n          if (!currentBlockEnd || currentBlockEnd.isBefore(maxChildDate)) {\n            currentBlockEnd = maxChildDate;\n          }\n        }\n\n        nextChildIndex += 1;\n      }\n\n      appointmentNode.overlappingSubTreeRoots = overlappingSubTreeRoots;\n    });\n    return __assign(__assign({}, appointmentForest), {\n      items: appointmentNodes\n    });\n  });\n};\n\nvar isOverlappingSubTreeRoot = function (appointmentNode, nextAppointment, previousSubTreeRoot, previousEndDate) {\n  var overlappingSubTreeRoot = nextAppointment.overlappingSubTreeRoot,\n      maxOffset = nextAppointment.maxOffset,\n      nextData = nextAppointment.data;\n  var nextOffset = nextData.offset,\n      nextStart = nextData.start;\n  var offset = appointmentNode.data.offset;\n  return nextOffset < offset && !overlappingSubTreeRoot && (maxOffset === undefined || maxOffset >= offset) && (!previousSubTreeRoot || previousSubTreeRoot.data.offset >= nextOffset && nextStart.isSameOrAfter(previousEndDate));\n};\n\nvar findChildrenMaxEndDate = function (appointmentNodes, appointmentNode) {\n  var children = appointmentNode.children,\n      data = appointmentNode.data;\n  var end = data.end;\n  var maxDate = children.reduce(function (currentMaxDate, childIndex) {\n    var child = appointmentNodes[childIndex];\n    var maxChildrenDate = findChildrenMaxEndDate(appointmentNodes, child);\n\n    if (maxChildrenDate.isAfter(currentMaxDate)) {\n      return maxChildrenDate;\n    }\n\n    return currentMaxDate;\n  }, end);\n  return maxDate;\n};\n\nvar groupAppointmentsIntoBlocks = function (appointmentForests) {\n  return appointmentForests.map(function (appointmentForest) {\n    var items = appointmentForest.items,\n        reduceValue = appointmentForest.reduceValue;\n\n    var _a = items.reduce(function (acc, appointment, index) {\n      var blocks = acc.blocks.slice();\n      var treeDepth = appointment.treeDepth,\n          data = appointment.data,\n          overlappingSubTreeRoots = appointment.overlappingSubTreeRoots,\n          overlappingSubTreeRoot = appointment.overlappingSubTreeRoot;\n      var offset = data.offset,\n          start = data.start,\n          end = data.end;\n\n      if (overlappingSubTreeRoots.length !== 0) {\n        if (!overlappingSubTreeRoot) {\n          blocks.push({\n            start: start,\n            end: end,\n            minOffset: offset,\n            maxOffset: offset + treeDepth,\n            size: treeDepth + 1,\n            items: [],\n            endForChildren: end\n          });\n        }\n\n        overlappingSubTreeRoots.forEach(function (subTreeRootIndex) {\n          var subTreeRoot = items[subTreeRootIndex];\n          var subTreeRootData = subTreeRoot.data;\n          blocks.push({\n            start: subTreeRootData.start,\n            end: end,\n            minOffset: subTreeRootData.offset,\n            maxOffset: offset - 1,\n            size: calculateBlockSizeByEndDate(items, subTreeRoot, end),\n            items: [],\n            endForChildren: subTreeRootData.end\n          });\n        });\n      }\n\n      var blockIndex = findBlockIndexByAppointment(blocks, appointment);\n      blocks[blockIndex].items.push(index);\n\n      var appointmentInBlock = __assign(__assign({}, appointment), {\n        blockIndex: blockIndex\n      });\n\n      return {\n        blocks: blocks,\n        appointments: __spread(acc.appointments, [appointmentInBlock])\n      };\n    }, {\n      blocks: [{\n        start: items[0].data.start,\n        end: items[0].data.end,\n        minOffset: 0,\n        maxOffset: reduceValue - 1,\n        size: reduceValue,\n        items: [],\n        endForChildren: items[0].data.end\n      }],\n      appointments: []\n    }),\n        nextBlocks = _a.blocks,\n        appointments = _a.appointments;\n\n    return {\n      blocks: nextBlocks,\n      appointmentForest: __assign(__assign({}, appointmentForest), {\n        items: appointments\n      })\n    };\n  });\n};\n\nvar calculateBlockSizeByEndDate = function (appointmentNodes, subTreeRoot, blockEndDate) {\n  var children = subTreeRoot.children,\n      data = subTreeRoot.data;\n  var start = data.start;\n\n  if (children.length === 0) {\n    if (blockEndDate.isAfter(start)) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  var maxSize = Math.max.apply(Math, __spread(children.map(function (childIndex) {\n    return calculateBlockSizeByEndDate(appointmentNodes, appointmentNodes[childIndex], blockEndDate);\n  })));\n\n  if (blockEndDate.isSameOrBefore(start) && maxSize === 0) {\n    return 0;\n  }\n\n  return maxSize + 1;\n};\n\nvar findBlockIndexByAppointment = function (blocks, appointment) {\n  var _a = appointment.data,\n      start = _a.start,\n      offset = _a.offset;\n  var blockIndex = blocks.length - 1;\n\n  while (blockIndex > 0) {\n    var currentBlock = blocks[blockIndex];\n\n    if (intervalIncludes(currentBlock.start, currentBlock.end, start) && offset >= currentBlock.minOffset && offset <= currentBlock.maxOffset) {\n      break;\n    }\n\n    blockIndex -= 1;\n  }\n\n  return blockIndex;\n};\n\nvar findIncludedBlocks = function (groupedIntoBlocks) {\n  return groupedIntoBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    var nextBlocks = blocks.map(function (props) {\n      return __assign({}, props);\n    });\n    nextBlocks.forEach(function (block, blockIndex) {\n      block.includedBlocks = [];\n\n      for (var currentBlockIndex = blockIndex + 1; currentBlockIndex < nextBlocks.length; currentBlockIndex += 1) {\n        var currentBlock = nextBlocks[currentBlockIndex];\n\n        if (isIncludedBlock(block, currentBlock)) {\n          block.includedBlocks.push(currentBlockIndex);\n          currentBlock.includedInto = blockIndex;\n        }\n      }\n    });\n    return {\n      blocks: nextBlocks,\n      appointmentForest: appointmentForest\n    };\n  });\n};\n\nvar isIncludedBlock = function (block, possibleIncludedBlock) {\n  var start = block.start,\n      end = block.end,\n      minOffset = block.minOffset,\n      maxOffset = block.maxOffset;\n  var possibleIncludedStart = possibleIncludedBlock.start,\n      possibleIncludedEnd = possibleIncludedBlock.end,\n      possibleMinOffset = possibleIncludedBlock.minOffset,\n      possibleMaxOffset = possibleIncludedBlock.maxOffset;\n  return intervalIncludes(start, end, possibleIncludedStart) && intervalIncludes(start, end, possibleIncludedEnd) && possibleMaxOffset <= maxOffset && possibleMinOffset >= minOffset;\n};\n\nvar findChildBlocks = function (groupedIntoBlocks) {\n  return groupedIntoBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    var nextBlocks = blocks.map(function (props) {\n      return __assign({}, props);\n    });\n    nextBlocks.forEach(function (block, index) {\n      block.children = [];\n\n      for (var currentIndex = index + 1; currentIndex < nextBlocks.length; currentIndex += 1) {\n        var nextBlock = nextBlocks[currentIndex];\n\n        if (isChildBlock(block, nextBlock)) {\n          block.children.push(currentIndex);\n          nextBlock.parent = index;\n        }\n      }\n\n      return block;\n    });\n    return {\n      appointmentForest: appointmentForest,\n      blocks: nextBlocks\n    };\n  });\n};\n\nvar isChildBlock = function (block, possibleChildBlock) {\n  var start = block.start,\n      endForChildren = block.endForChildren,\n      minOffset = block.minOffset,\n      includedInto = block.includedInto;\n  var childStart = possibleChildBlock.start,\n      childIncludedInto = possibleChildBlock.includedInto,\n      childMaxOffset = possibleChildBlock.maxOffset;\n  return intervalIncludes(start, endForChildren, childStart) && childMaxOffset + 1 === minOffset && (childIncludedInto === undefined || childIncludedInto === includedInto);\n};\n\nvar adjustByBlocks = function (groupedIntoBlocks, indirectChildLeftOffset) {\n  var updatedBlocks = groupedIntoBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    var dimensionsCalculated = calculateBlocksDimensions(blocks, appointmentForest.items);\n    return {\n      blocks: alignBlocksWithPrevious(dimensionsCalculated, appointmentForest.items),\n      appointmentForest: appointmentForest\n    };\n  });\n  var adjustedByBlocks = updatedBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    return __assign(__assign({}, appointmentForest), {\n      items: adjustAppointmentsByBlocks(appointmentForest.items, blocks, indirectChildLeftOffset)\n    });\n  });\n  return adjustedByBlocks;\n};\n\nvar calculateBlocksDimensions = function (blocks, appointments) {\n  return updateBlocksProportions(calculateBlocksLeftLimit(calculateBlocksTotalSize(blocks), appointments));\n};\n\nvar alignBlocksWithPrevious = function (blocks, appointments) {\n  var nextBlocks = blocks.map(function (_a) {\n    var right = _a.right,\n        restProps = __rest(_a, [\"right\"]);\n\n    return __assign({}, restProps);\n  });\n  var leftLimitCalculated = calculateBlocksLeftLimit(updateBlocksLeft(nextBlocks, appointments), appointments);\n  return updateBlocksProportions(leftLimitCalculated);\n};\n\nvar adjustAppointmentsByBlocks = function (appointments, blocks, indirectChildLeftOffset) {\n  var nextAppointments = appointments.map(function (props) {\n    return __assign({}, props);\n  });\n  var nextBlocks = blocks.map(function (props) {\n    return __assign({}, props);\n  });\n  nextBlocks.forEach(function (block, index) {\n    if (index !== 0) {\n      var items = block.items,\n          blockLeft = block.left,\n          right = block.right,\n          children_1 = block.children;\n      var maxRight_1 = calculateIncludedBlockMaxRight(nextBlocks, block);\n      var finalMaxRight_1 = maxRight_1 * right;\n      var defaultLeft_1 = blockLeft * maxRight_1;\n      items.forEach(function (appointmentIndex, itemIndex) {\n        var appointment = nextAppointments[appointmentIndex];\n\n        if (itemIndex === 0) {\n          var _a = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, defaultLeft_1),\n              left_1 = _a.left,\n              width = _a.width;\n\n          appointment.data.left = left_1;\n          appointment.data.width = width;\n\n          if (defaultLeft_1 !== left_1) {\n            children_1.forEach(function (childIndex) {\n              redistributeChildBlocks(nextBlocks, childIndex, left_1 / maxRight_1);\n            });\n          }\n        } else {\n          var _b = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, undefined),\n              left = _b.left,\n              width = _b.width;\n\n          appointment.data.left = left;\n          appointment.data.width = width;\n        }\n      });\n    }\n  });\n  blocks[0].items.forEach(function (appointmentIndex) {\n    var appointment = nextAppointments[appointmentIndex];\n\n    var _a = calculateAppointmentLeftAndWidth(nextAppointments, blocks, appointment, 1, indirectChildLeftOffset, undefined),\n        left = _a.left,\n        width = _a.width;\n\n    appointment.data.left = left;\n    appointment.data.width = width;\n  });\n  return nextAppointments;\n};\n\nvar redistributeChildBlocks = function (blocks, blockIndex, right) {\n  var block = blocks[blockIndex];\n  var leftOffset = block.leftOffset,\n      size = block.size,\n      leftLimit = block.leftLimit,\n      children = block.children;\n  block.right = right;\n  var width = size + leftOffset;\n  var relativeWidth = right - leftLimit;\n  var left = right - relativeWidth * size / width;\n  block.left = left;\n  children.forEach(function (childIndex) {\n    redistributeChildBlocks(blocks, childIndex, left);\n  });\n};\n\nvar calculateIncludedBlockMaxRight = function (blocks, includedBlock) {\n  var includedIntoIndex = includedBlock.includedInto;\n\n  if (includedIntoIndex === undefined) {\n    return 1;\n  }\n\n  var includedInto = blocks[includedIntoIndex];\n  var currentMaxRight = includedInto.right;\n  return currentMaxRight * calculateIncludedBlockMaxRight(blocks, includedInto);\n};\n\nvar calculateBlocksTotalSize = function (blocks) {\n  var result = blocks.map(function (block) {\n    var totalSize = calculateSingleBlockTotalSize(blocks, block);\n    return __assign(__assign({}, block), {\n      totalSize: totalSize,\n      leftOffset: totalSize - block.size\n    });\n  });\n  return result;\n};\n\nvar calculateSingleBlockTotalSize = function (blocks, block) {\n  var children = block.children,\n      size = block.size;\n\n  if (children.length === 0) {\n    return size;\n  }\n\n  return Math.max.apply(Math, __spread(children.map(function (childIndex) {\n    return calculateSingleBlockTotalSize(blocks, blocks[childIndex]);\n  }))) + size;\n};\n\nvar calculateBlocksLeftLimit = function (blocks, appointments) {\n  return blocks.map(function (block) {\n    var leftLimit = calculateSingleBlockLeftLimit(blocks, appointments, block);\n    return __assign(__assign({}, block), {\n      leftLimit: leftLimit\n    });\n  });\n};\n\nvar calculateSingleBlockLeftLimit = function (blocks, appointments, block) {\n  var _a = block,\n      children = _a.children,\n      items = _a.items,\n      left = _a.left;\n\n  if (children.length === 0) {\n    return left !== undefined ? Math.min(left, appointments[items[0]].data.left) : appointments[items[0]].data.left;\n  }\n\n  return Math.min.apply(Math, __spread(children.map(function (childIndex) {\n    return calculateSingleBlockLeftLimit(blocks, appointments, blocks[childIndex]);\n  })));\n};\n\nvar updateBlocksProportions = function (blocks) {\n  var nextBlocks = blocks.map(function (props) {\n    return __assign({}, props);\n  });\n  nextBlocks.forEach(function (block) {\n    var parentIndex = block.parent,\n        leftLimit = block.leftLimit,\n        leftOffset = block.leftOffset,\n        totalSize = block.totalSize;\n\n    if (parentIndex === undefined) {\n      block.right = 1;\n      block.left = (1 - leftLimit) * leftOffset / totalSize + leftLimit;\n      return;\n    }\n\n    var parent = nextBlocks[parentIndex];\n    var _a = parent,\n        parentLeft = _a.left,\n        parentTotalSize = _a.totalSize;\n    block.totalSize = parentTotalSize;\n    block.right = parentLeft;\n    block.left = (1 - leftLimit) * leftOffset / parentTotalSize + leftLimit;\n  });\n  return nextBlocks;\n};\n\nvar updateBlocksLeft = function (blocks, appointments) {\n  return blocks.map(function (block) {\n    var items = block.items,\n        left = block.left;\n    var firstItem = appointments[items[0]];\n    var firstItemParentIndex = firstItem.parent;\n\n    if (firstItemParentIndex === undefined) {\n      return block;\n    }\n\n    var firstItemParent = appointments[firstItemParentIndex];\n    var parentBlock = blocks[firstItemParent.blockIndex];\n    return __assign(__assign({}, block), {\n      left: parentBlock.parent === undefined ? left : blocks[parentBlock.parent].left\n    });\n  });\n};\n\nvar createAndAdjustAppointmentForest = function (appointmentGroups, cellDuration) {\n  var appointmentForest = createAppointmentForest(appointmentGroups, cellDuration);\n  var indirectChildLeftOffset = Math.min(1 / findMaxReduceValue(appointmentForest), INDIRECT_CHILD_LEFT_OFFSET);\n  var baseCalculated = calculateAppointmentsMetaData(appointmentForest, indirectChildLeftOffset);\n  var preparedToGroupIntoBlocks = prepareToGroupIntoBlocks(baseCalculated);\n  var groupedIntoBlocks = groupAppointmentsIntoBlocks(preparedToGroupIntoBlocks);\n  var blocksWithIncluded = findIncludedBlocks(groupedIntoBlocks);\n  var blocksWithParents = findChildBlocks(blocksWithIncluded);\n  return adjustByBlocks(blocksWithParents, indirectChildLeftOffset);\n};\n\nvar calculateRectByDateAndGroupIntervals = function (type, intervals, rectByDates, rectByDatesMeta, viewMetaData) {\n  var growDirection = type.growDirection,\n      multiline = type.multiline;\n  var isHorizontal = growDirection === HORIZONTAL_TYPE;\n  var sorted = intervals.map(sortAppointments);\n  var grouped = sorted.reduce(function (acc, sortedGroup) {\n    return __spread(acc, findOverlappedAppointments(sortedGroup, isHorizontal));\n  }, []);\n  var cellDuration = rectByDatesMeta.cellDuration,\n      placeAppointmentsNextToEachOther = rectByDatesMeta.placeAppointmentsNextToEachOther;\n  var rectCalculator = isHorizontal ? horizontalRectCalculator : placeAppointmentsNextToEachOther ? oldVerticalRectCalculator : verticalRectCalculator;\n  var groupsCalculated = calculateAppointmentOffsets(grouped, isHorizontal);\n  var isAppointmentForestNeeded = !isHorizontal && !placeAppointmentsNextToEachOther;\n  var appointmentForest;\n\n  if (isAppointmentForestNeeded) {\n    appointmentForest = createAndAdjustAppointmentForest(groupsCalculated, cellDuration);\n  }\n\n  var unwrappedAppointments = isAppointmentForestNeeded ? unwrapAppointmentForest(appointmentForest) : unwrapGroups(groupsCalculated);\n  var rects = unwrappedAppointments.map(function (appointment) {\n    return rectCalculator(appointment, viewMetaData, {\n      rectByDates: rectByDates,\n      multiline: multiline,\n      rectByDatesMeta: rectByDatesMeta\n    });\n  });\n  return rects.sort(function (first, second) {\n    return first.offset >= second.offset ? 1 : -1;\n  });\n};\n\nvar sliceAppointmentByDay = function (appointment, cellDuration) {\n  var start = appointment.start,\n      end = appointment.end,\n      dataItem = appointment.dataItem,\n      key = appointment.key;\n  if (start.isSame(end, 'day')) return [appointment];\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  var isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n  var firstAppointmentKey = addDateToKey(key, start);\n  var secondAppointmentKey = addDateToKey(key, end);\n  return [isShortOnFirstDay ? {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n    dataItem: dataItem,\n    key: firstAppointmentKey\n  } : {\n    start: start,\n    end: start.clone().endOf('day'),\n    dataItem: dataItem,\n    key: firstAppointmentKey\n  }, isShortOnSecondDay ? {\n    start: end.clone().startOf('day'),\n    end: end.clone().startOf('day').add(minDuration, 'minutes'),\n    dataItem: dataItem,\n    key: secondAppointmentKey\n  } : {\n    start: end.clone().startOf('day'),\n    end: end,\n    dataItem: dataItem,\n    key: secondAppointmentKey\n  }];\n};\n\nvar dayBoundaryPredicate = function (appointment, leftBound, rightBound, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes());\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(function (day) {\n    return day === moment(appointment.start).day();\n  }) !== -1) return false;\n  return appointment.end.isAfter(startDayTime) && appointment.start.isBefore(endDayTime);\n};\n\nvar reduceAppointmentByDayBounds = function (appointment, leftBound, rightBound, cellDuration) {\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes()).seconds(dayStart.seconds());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes()).seconds(dayEnd.seconds());\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  var isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return __assign(__assign({}, appointment), {\n      start: endDayTime.clone().add(-minDuration, 'minutes'),\n      end: endDayTime\n    });\n  }\n\n  if (isShortOnSecondDay) {\n    return __assign(__assign({}, appointment), {\n      start: startDayTime,\n      end: startDayTime.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return __assign(__assign(__assign({}, appointment), appointment.start.isSameOrBefore(startDayTime) ? {\n    start: startDayTime\n  } : null), appointment.end.isSameOrAfter(endDayTime) ? {\n    end: endDayTime\n  } : null);\n};\n\nvar normalizeAppointmentDuration = function (appointment, cellDuration) {\n  var minDuration = cellDuration / 2;\n  var start = moment(appointment.start);\n  var end = moment(appointment.end);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return __assign(__assign({}, appointment), {\n      start: start,\n      end: end\n    });\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return __assign(__assign({}, appointment), {\n      start: start,\n      end: start.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return __assign(__assign({}, appointment), {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day')\n  });\n};\n\nvar getWeekVerticallyGroupedColumnIndex = function (viewCellsData, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return moment(date).isSame(timeCell.startDate, 'date');\n  });\n};\n\nvar getWeekHorizontallyGroupedColumnIndex = function (viewCellsData, appointment, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    var isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);\n    return moment(date).isSame(timeCell.startDate, 'date') && isCorrectGroup;\n  });\n};\n\nvar getWeekVerticallyGroupedRowIndex = function (viewCellsData, appointment, date, columnIndex, takePrev, groupCount) {\n  var timeTableHeight = viewCellsData.length / groupCount;\n  var timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n  if (!viewCellsData[0][0].groupingInfo) return timeTableRowIndex;\n  var isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);\n\n  while (isWrongCell) {\n    timeTableRowIndex += timeTableHeight;\n    isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);\n  }\n\n  return timeTableRowIndex;\n};\n\nvar getWeekHorizontallyGroupedRowIndex = function (viewCellsData, date, columnIndex, takePrev) {\n  return viewCellsData.findIndex(function (timeCell) {\n    return moment(date).isBetween(timeCell[columnIndex].startDate, timeCell[columnIndex].endDate, 'seconds', takePrev ? '(]' : '[)');\n  });\n};\n\nvar calculateWeekDateIntervals = function (appointments, leftBound, rightBound, // startViewDate, endViewDate\nexcludedDays, cellDuration) {\n  return [appointments.map(function (appointment) {\n    return normalizeAppointmentDuration(appointment, cellDuration);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByDay(appointment, cellDuration));\n  }, []).filter(function (appointment) {\n    return dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays);\n  }).map(function (appointment) {\n    return reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration);\n  })];\n};\n\nvar CELL_GAP_PX = 10;\nvar CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nvar CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nvar getVerticalCellIndexByAppointmentData = function (appointment, viewCellsData, viewMetaData, date, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupCount = viewMetaData.groupCount;\n  var columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedColumnIndex(viewCellsData, date) : getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date);\n  var rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedRowIndex(viewCellsData, appointment, date, columnIndex, takePrev, groupCount) : getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n  var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return {\n    index: cellIndex,\n    startDate: viewCellsData[rowIndex][columnIndex].startDate\n  };\n};\n\nvar getCellRect = function (date, appointment, viewCellsData, cellDuration, cellElementsMeta, takePrev, viewMetaData) {\n  var _a = getVerticalCellIndexByAppointmentData(appointment, viewCellsData, viewMetaData, date, takePrev),\n      cellIndex = _a.index,\n      cellStartDate = _a.startDate;\n\n  var _b = cellElementsMeta.getCellRects[cellIndex](),\n      top = _b.top,\n      left = _b.left,\n      width = _b.width,\n      cellHeight = _b.height;\n\n  var timeOffset = moment(date).diff(cellStartDate, 'minutes');\n  var topOffset = cellHeight * (timeOffset / cellDuration);\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    topOffset: topOffset,\n    parentRect: parentRect\n  };\n};\n\nvar getVerticalRectByAppointmentData = function (appointment, viewMetaData, _a) {\n  var viewCellsData = _a.viewCellsData,\n      cellDuration = _a.cellDuration,\n      cellElementsMeta = _a.cellElementsMeta,\n      placeAppointmentsNextToEachOther = _a.placeAppointmentsNextToEachOther;\n  var firstCellRect = getCellRect(appointment.start.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, false, viewMetaData);\n  var lastCellRect = getCellRect(appointment.end.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, true, viewMetaData);\n  var top = firstCellRect.top + firstCellRect.topOffset;\n  var height = lastCellRect.top + lastCellRect.topOffset - top;\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: placeAppointmentsNextToEachOther ? height - CELL_BOUND_VERTICAL_OFFSET_PX : height\n  };\n};\n\nvar allDayPredicate = function (appointment) {\n  return appointment.end.diff(appointment.start, 'hours') > 23 || !!appointment.allDay;\n};\n\nvar getAllDayCellIndexByAppointmentData = function (viewCellsData, viewMetaData, date, appointment, takePrev) {\n  var currentDate = moment(date);\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupCount = viewMetaData.groupCount;\n  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData, currentDate, appointment) : getAllDayVerticallyGroupedColumnIndex(viewCellsData, currentDate);\n  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount);\n  var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n\n  return cellIndex;\n};\n\nvar getAllDayVerticallyGroupedColumnIndex = function (viewCellsData, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return date.isSame(timeCell.startDate, 'date');\n  });\n};\n\nvar getAllDayHorizontallyGroupedColumnIndex = function (viewCellsData, date, appointment) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return date.isSame(timeCell.startDate, 'date') && checkCellGroupingInfo(timeCell, appointment);\n  });\n};\n\nvar getAllDayVerticallyGroupedRowIndex = function (viewCellsData, appointment, groupCount) {\n  var index = viewCellsData.findIndex(function (viewCellsDataRow) {\n    return checkCellGroupingInfo(viewCellsDataRow[0], appointment);\n  });\n  return index * groupCount / viewCellsData.length;\n};\n\nvar sliceAppointmentsByBoundaries = function (appointment, left, right, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start.clone();\n  var endDate = appointment.end.clone();\n  var nextStart = startDate.clone();\n  var nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left)) {\n    nextStart = moment(left);\n    nextStart.startOf('day');\n  }\n\n  if (endDate.isAfter(right)) {\n    nextEnd = moment(right);\n    nextEnd.endOf('day');\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === startDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) !== -1 && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === endDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextEnd.day();\n    }) !== -1 && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n\n  return [__assign(__assign({}, appointment), {\n    start: nextStart,\n    end: nextEnd\n  })];\n};\n\nvar sliceAppointmentsByDays = function (appointment, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start;\n  var endDate = appointment.end;\n  var nextStart = startDate.clone();\n  var appointments = [];\n\n  while (nextStart.isBefore(endDate)) {\n    if (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) === -1) {\n      appointments.push(__assign(__assign({}, appointment), {\n        start: nextStart,\n        end: moment(nextStart).endOf('day')\n      }));\n    }\n\n    nextStart = moment(nextStart).add(1, 'day');\n  }\n\n  return appointments;\n};\n\nvar DEFAULT_RULE_OBJECT = {\n  interval: 1\n};\nvar DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6\n};\nvar RRULE_DAYS_OF_WEEK = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR, RRule.SA, RRule.SU];\nvar DAYS_IN_WEEK = 7;\nvar DAYS_OF_WEEK_ARRAY = [DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY, DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY];\nvar MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12\n};\nvar RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY,\n  MONTHLY: RRule.MONTHLY,\n  WEEKLY: RRule.WEEKLY,\n  DAILY: RRule.DAILY,\n  HOURLY: RRule.HOURLY,\n  MINUTELY: RRule.MINUTELY\n};\nvar REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never'\n};\nvar REPEAT_TYPES_ARRAY = [REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY];\nvar WEEK_NUMBER_LABELS = ['firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel'];\nvar END_REPEAT_RADIO_GROUP = 'endRepeat';\nvar MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nvar YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\nvar TITLE_TEXT_EDITOR = 'titleTextEditor';\nvar MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nvar ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nvar NUMBER_EDITOR = 'numberEditor';\nvar TITLE = 'title';\nvar ORDINARY_LABEL = 'ordinaryLabel';\nvar SAVE_BUTTON = 'saveButton';\nvar DELETE_BUTTON = 'deleteButton';\nvar CANCEL_BUTTON = 'cancelButton';\nvar OUTLINED_SELECT = 'outlinedSelect';\nvar STANDARD_SELECT = 'standardSelect';\nvar SUNDAY_DATE = new Date(2019, 7, 11);\nvar MONDAY_DATE = new Date(2019, 7, 12);\nvar TUESDAY_DATE = new Date(2019, 7, 13);\nvar WEDNESDAY_DATE = new Date(2019, 7, 14);\nvar THURSDAY_DATE = new Date(2019, 7, 15);\nvar FRIDAY_DATE = new Date(2019, 7, 16);\nvar SATURDAY_DATE = new Date(2019, 7, 17);\nvar DAYS_OF_WEEK_DATES = [SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE, THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE];\nvar JANUARY_DATE = new Date(2019, 0, 1);\nvar FEBRUARY_DATE = new Date(2019, 1, 1);\nvar MARCH_DATE = new Date(2019, 2, 1);\nvar APRIL_DATE = new Date(2019, 3, 1);\nvar MAY_DATE = new Date(2019, 4, 1);\nvar JUNE_DATE = new Date(2019, 5, 1);\nvar JULY_DATE = new Date(2019, 6, 1);\nvar AUGUST_DATE = new Date(2019, 7, 1);\nvar SEPTEMBER_DATE = new Date(2019, 8, 1);\nvar OCTOBER_DATE = new Date(2019, 9, 1);\nvar NOVEMBER_DATE = new Date(2019, 10, 1);\nvar DECEMBER_DATE = new Date(2019, 11, 1);\nvar MONTHS_DATES = [JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE, JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE];\nvar FIRST_WEEK = 0;\nvar SECOND_WEEK = 1;\nvar THIRD_WEEK = 2;\nvar FOURTH_WEEK = 3;\nvar LAST_WEEK = 4;\nvar BASIC_YEALY_COUNT = 5;\nvar BASIC_MONTHLY_COUNT = 12;\nvar BASIC_WEEKLY_COUNT = 13;\nvar BASIC_DAILY_COUNT = 30;\n\nvar sliceAppointmentByWeek = function (timeBounds, appointment, step) {\n  var left = timeBounds.left,\n      right = timeBounds.right;\n  var pieces = [];\n\n  var start = appointment.start,\n      end = appointment.end,\n      key = appointment.key,\n      restFields = __rest(appointment, [\"start\", \"end\", \"key\"]);\n\n  var apptStart = start;\n  var apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  var pieceFrom = apptStart.clone();\n  var pieceTo = apptStart.clone();\n  var i = 0;\n\n  while (pieceTo.isBefore(apptEnd)) {\n    var currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push(__assign({\n          start: pieceFrom,\n          end: pieceTo,\n          key: addDateToKey(key, pieceFrom)\n        }, restFields));\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n\n    i += 1;\n  }\n\n  return pieces;\n};\n\nvar getMonthCellIndexByAppointmentData = function (viewCellsData, viewMetaData, date, appointment, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupedByDate = viewMetaData.groupedByDate,\n      groupCount = viewMetaData.groupCount;\n  var startViewDate = moment(viewCellsData[0][0].startDate);\n  var currentDate = moment(date);\n  var dayNumber = currentDate.diff(startViewDate, 'days');\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    dayNumber -= 1;\n  }\n\n  var weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);\n  var dayOfWeek = dayNumber % DAYS_IN_WEEK;\n  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getMonthHorizontallyGroupedColumnIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate) : dayOfWeek;\n  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? weekNumber : getMonthVerticallyGroupedRowIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount);\n  var totalCellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return totalCellIndex;\n};\n\nvar getMonthHorizontallyGroupedColumnIndex = function (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) {\n  var columnIndex = -1;\n  var currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;\n  var cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;\n\n  while (columnIndex === -1) {\n    var isCorrectCell = checkCellGroupingInfo(viewCellsData[weekNumber][currentColumnIndex], appointment);\n\n    if (isCorrectCell) {\n      columnIndex = currentColumnIndex;\n    }\n\n    currentColumnIndex += cellsInGroupRow;\n  }\n\n  return columnIndex;\n};\n\nvar getMonthVerticallyGroupedRowIndex = function (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount) {\n  var rowsInOneGroup = viewCellsData.length / groupCount;\n  var rowIndex = -1;\n  var currentRowIndex = weekNumber;\n\n  while (rowIndex === -1) {\n    var isCorrectCell = checkCellGroupingInfo(viewCellsData[currentRowIndex][dayOfWeek], appointment);\n\n    if (isCorrectCell) {\n      rowIndex = currentRowIndex;\n    }\n\n    currentRowIndex += rowsInOneGroup;\n  }\n\n  return rowIndex;\n};\n\nvar TOP_CELL_OFFSET = 0.32;\nvar CELL_BOUND_OFFSET_PX = 1;\n\nvar getCellRect$1 = function (date, appointment, viewCellsData, viewMetaData, cellElementsMeta, takePrev, multiline) {\n  var cellIndex = multiline ? getMonthCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) : getAllDayCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev);\n\n  var _a = cellElementsMeta.getCellRects[cellIndex](),\n      top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    height: height,\n    parentRect: parentRect\n  };\n};\n\nvar getHorizontalRectByAppointmentData = function (appointment, viewMetaData, _a) {\n  var multiline = _a.multiline,\n      viewCellsData = _a.viewCellsData,\n      cellElementsMeta = _a.cellElementsMeta;\n  var firstCellRect = getCellRect$1(appointment.start.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, false, multiline);\n  var lastCellRect = getCellRect$1(appointment.end.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, true, multiline);\n  var top = firstCellRect.top + firstCellRect.height * TOP_CELL_OFFSET;\n  var height = firstCellRect.height - firstCellRect.height * TOP_CELL_OFFSET;\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_OFFSET_PX,\n    width: lastCellRect.left - firstCellRect.left + firstCellRect.width - CELL_BOUND_OFFSET_PX,\n    height: height,\n    parentWidth: firstCellRect.parentRect.width\n  };\n};\n\nvar DAY_COUNT = 7;\nvar MONTH_LENGTH = 31;\n\nvar monthCellsData = function (currentDate, firstDayOfWeek, intervalCount, today) {\n  if (intervalCount === void 0) {\n    intervalCount = 1;\n  }\n\n  var targetDate = moment(currentDate);\n  var currentMonths = [targetDate.month()];\n\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n\n  var firstMonthDate = moment(currentDate).date(1);\n  var firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  var prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  var prevMonth = moment(currentDate).subtract(1, 'months');\n  var prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  var from = moment().year(prevMonth.year()).month(prevMonth.month()).date(prevMonthStartDay).startOf('day');\n  var result = [];\n\n  while (result.length < Math.trunc(MONTH_LENGTH * intervalCount / DAY_COUNT) + 2) {\n    var week = [];\n\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(function (month) {\n          return month === from.month();\n        }) === -1,\n        today: today ? moment(today).isSame(from, 'date') : false\n      });\n      from.add(1, 'day');\n    }\n\n    result.push(week);\n  }\n\n  return result;\n};\n\nvar calculateMonthDateIntervals = function (appointments, leftBound, rightBound) {\n  return [appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return __assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, [], false));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByWeek({\n      left: moment(leftBound),\n      right: moment(rightBound)\n    }, appointment, DAY_COUNT));\n  }, [])];\n};\n\nvar calculateAllDayDateIntervals = function (appointments, leftBound, rightBound, excludedDays) {\n  return [appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return __assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false));\n  }, []).filter(function (appointment) {\n    return allDayPredicate(appointment);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays));\n  }, [])];\n};\n\nvar getGroupFromResourceInstance = function (resourceInstance) {\n  return {\n    id: resourceInstance.id,\n    fieldName: resourceInstance.fieldName,\n    text: resourceInstance.text\n  };\n};\n\nvar addGroupInfoToCells = function (currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation) {\n  return viewCellRow.map(function (viewCell, cellIndex) {\n    var groupedCell = addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation);\n    return cellIndex === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? __assign(__assign({}, groupedCell), {\n      endOfGroup: true\n    }) : groupedCell;\n  });\n};\n\nvar addGroupInfoToCell = function (currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) {\n  var previousIndex = index;\n  var groupingInfo = groups.reduceRight(function (acc, group, currentIndex) {\n    if (currentIndex === groups.length - 1) return acc;\n    var previousResourceLength = sortedResources[currentIndex + 1].instances.length;\n    var currentGroupingInstance = group[Math.floor(previousIndex / previousResourceLength)];\n    previousIndex = currentIndex;\n    return __spread(acc, [currentGroupingInstance]);\n  }, [currentGroup]);\n  return __assign(__assign({}, viewCell), {\n    groupingInfo: groupingInfo,\n    endOfGroup: endOfGroup,\n    groupOrientation: groupOrientation\n  });\n};\n\nvar getCurrentGroup = function (groups, resources, index, group) {\n  var currentIndex = index;\n  return groups.reduceRight(function (groupAcc, groupsRow, rowIndex) {\n    if (rowIndex === groups.length - 1) {\n      return groupAcc;\n    }\n\n    currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);\n    var currentInstance = groupsRow[currentIndex];\n    return __spread(groupAcc, [currentInstance]);\n  }, [group]);\n};\n\nvar groupAppointments = function (appointments, resources, groups) {\n  if (!resources || !groups) return [appointments.slice()];\n  var mainResource = resources.find(function (resource) {\n    return resource.isMain;\n  });\n  return groups[groups.length - 1].map(function (group, index) {\n    var currentGroup = getCurrentGroup(groups, resources, index, group);\n    return appointments.reduce(function (acc, appointment) {\n      var _a;\n\n      var belongsToGroup = currentGroup.reduce(function (isBelonging, groupItem) {\n        return isBelonging && groupItem.id === appointment[groupItem.fieldName];\n      }, true);\n      if (!belongsToGroup) return acc;\n      var currentMainResourceId = currentGroup.find(function (groupItem) {\n        return groupItem.fieldName === mainResource.fieldName;\n      }).id;\n\n      var updatedAppointment = __assign(__assign({}, appointment), {\n        dataItem: __assign(__assign({}, appointment.dataItem), (_a = {}, _a[mainResource.fieldName] = rearrangeResourceIds(mainResource, appointment, currentMainResourceId), _a)),\n        resources: appointment.resources && rearrangeResources(mainResource, appointment, currentMainResourceId)\n      });\n\n      return __spread(acc, [updatedAppointment]);\n    }, []);\n  });\n};\n\nvar rearrangeResourceIds = function (mainResource, appointment, mainResourceId) {\n  if (!mainResource.allowMultiple) {\n    return mainResourceId;\n  }\n\n  return __spread([mainResourceId], appointment.dataItem[mainResource.fieldName].filter(function (id) {\n    return id !== mainResourceId;\n  }));\n};\n\nvar rearrangeResources = function (mainResource, appointment, currentResourceInstanceId) {\n  var _a;\n\n  if (!mainResource.allowMultiple) {\n    return appointment.resources;\n  }\n\n  var resources = appointment.resources.slice();\n  var firstMainResource = resources.findIndex(function (el) {\n    return el.isMain;\n  });\n  var currentResourceIndex = resources.findIndex(function (el) {\n    return el.isMain && el.id === currentResourceInstanceId;\n  });\n  _a = __read([resources[currentResourceIndex], resources[firstMainResource]], 2), resources[firstMainResource] = _a[0], resources[currentResourceIndex] = _a[1];\n  return resources;\n};\n\nvar expandGroupedAppointment = function (appointment, grouping, resources) {\n  if (!resources || !grouping) {\n    return [appointment];\n  }\n\n  return resources.reduce(function (acc, resource) {\n    var isGroupedByResource = grouping.find(function (group) {\n      return group.resourceName === resource.fieldName;\n    }) !== undefined;\n    if (!isGroupedByResource) return acc;\n    var resourceField = resource.fieldName;\n\n    if (!resource.allowMultiple) {\n      return acc.reduce(function (accumulatedAppointments, currentAppointment) {\n        var _a;\n\n        return __spread(accumulatedAppointments, [__assign(__assign({}, currentAppointment), (_a = {}, _a[resourceField] = currentAppointment.dataItem[resourceField], _a))]);\n      }, []);\n    }\n\n    return acc.reduce(function (accumulatedAppointments, currentAppointment) {\n      return __spread(accumulatedAppointments, currentAppointment.dataItem[resourceField].map(function (resourceValue) {\n        var _a;\n\n        return __assign(__assign({}, currentAppointment), (_a = {}, _a[resourceField] = resourceValue, _a.key = generateMultipleResourceKey(currentAppointment.key, resourceValue), _a));\n      }));\n    }, []);\n  }, [appointment]);\n};\n\nvar generateMultipleResourceKey = function (previousKey, resourceValue) {\n  return previousKey + \"_\" + resourceValue;\n};\n\nvar getGroupingInfoFromGroups = function (groups, groupIndex) {\n  var previousIndex = groupIndex;\n  return groups.reduceRight(function (acc, currentGroups, currentIndex) {\n    if (currentIndex === groups.length - 1) return acc;\n    var previousResourceLength = groups[currentIndex + 1].length / currentGroups.length;\n    var currentGroupingInstance = currentGroups[Math.floor(previousIndex / previousResourceLength)];\n    previousIndex = currentIndex;\n    return __spread(acc, [currentGroupingInstance]);\n  }, [getGroupsLastRow(groups)[groupIndex]]);\n};\n\nvar getGroupsLastRow = function (groups) {\n  return groups[groups.length - 1];\n};\n\nvar filterResourcesByGrouping = function (resources, grouping) {\n  return resources.filter(function (resource) {\n    return grouping.find(function (resourceId) {\n      return resource.fieldName === resourceId.resourceName;\n    });\n  });\n};\n\nvar sortFilteredResources = function (resources, grouping) {\n  return grouping.map(function (_a) {\n    var resourceName = _a.resourceName;\n    return resources.find(function (resource) {\n      return resource.fieldName === resourceName;\n    });\n  });\n};\n\nvar getGroupsFromResources = function (sortedAndFilteredResources) {\n  return sortedAndFilteredResources.reduce(function (acc, resource, index) {\n    if (index === 0) {\n      return [resource.instances.map(function (instance) {\n        return getGroupFromResourceInstance(instance);\n      })];\n    }\n\n    return __spread(acc, [acc[index - 1].reduce(function (currentResourceNames) {\n      return __spread(currentResourceNames, resource.instances.map(function (instance) {\n        return getGroupFromResourceInstance(instance);\n      }));\n    }, [])]);\n  }, []);\n};\n\nvar expandViewCellsDataWithGroups = function (viewCellsData, groups, sortedResources, groupByDate, groupOrientation) {\n  if (groups.length === 0) return viewCellsData;\n\n  if (groupByDate) {\n    return expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources);\n  }\n\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources);\n  }\n\n  return expandVerticallyGroupedCells(viewCellsData, groups, sortedResources);\n};\n\nvar expandCellsWithGroupedByDateData = function (viewCellsData, groups, sortedResources) {\n  return viewCellsData.map(function (cellsRow) {\n    return cellsRow.reduce(function (acc, viewCell) {\n      var groupedCells = getGroupsLastRow(groups).map(function (group, index) {\n        return addGroupInfoToCell(group, groups, sortedResources, viewCell, index, false, HORIZONTAL_GROUP_ORIENTATION);\n      });\n      groupedCells[groupedCells.length - 1] = __assign(__assign({}, groupedCells[groupedCells.length - 1]), {\n        endOfGroup: true\n      });\n      return __spread(acc, groupedCells);\n    }, []);\n  });\n};\n\nvar expandHorizontallyGroupedCells = function (viewCellsData, groups, sortedResources) {\n  return getGroupsLastRow(groups).reduce(function (acc, group, index) {\n    if (index === 0) {\n      return viewCellsData.map(function (viewCellsRow) {\n        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, false, HORIZONTAL_GROUP_ORIENTATION);\n      });\n    }\n\n    return acc.map(function (item, id) {\n      return __spread(item, addGroupInfoToCells(group, groups, sortedResources, viewCellsData[id], index, false, HORIZONTAL_GROUP_ORIENTATION));\n    });\n  }, [[]]);\n};\n\nvar expandVerticallyGroupedCells = function (viewCellsData, groups, sortedResources) {\n  return getGroupsLastRow(groups).reduce(function (acc, group, index) {\n    if (index === 0) {\n      return viewCellsData.map(function (viewCellsRow, viewRowIndex) {\n        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);\n      });\n    }\n\n    return __spread(acc, viewCellsData.map(function (viewCellsRow, viewRowIndex) {\n      return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);\n    }));\n  }, [[]]);\n};\n\nvar updateGroupingWithMainResource = function (grouping, resources) {\n  return grouping || [{\n    resourceName: resources.find(function (resource) {\n      return resource.isMain;\n    }).fieldName\n  }];\n};\n\nvar expandGroups = function (appointments, grouping, resources, groups, excludedDays, sliceByDay) {\n  if (sliceByDay === void 0) {\n    sliceByDay = false;\n  }\n\n  var slicedAppointments = sliceByDay ? appointments[0].reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByDays(appointment, excludedDays));\n  }, []) : appointments[0];\n  var expandedAppointments = slicedAppointments.reduce(function (acc, appointment) {\n    return __spread(acc, expandGroupedAppointment(appointment, grouping, resources));\n  }, []);\n  return groupAppointments(expandedAppointments, resources, groups);\n};\n\nvar updateTimeTableCellElementsMeta = function (timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView) {\n  if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {\n    return timeTableElementsMeta;\n  }\n\n  var _a = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups),\n      groupCount = _a.groupCount,\n      timeTableWidth = _a.timeTableWidth,\n      groupSize = _a.groupSize,\n      validGetCellRects = _a.validGetCellRects;\n\n  var allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(allDayPanelsLeft * (timeTableWidth + groupSize), timeTableWidth);\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects\n  };\n};\n\nvar updateAllDayCellElementsMeta = function (allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView) {\n  if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {\n    return allDayElementsMeta;\n  }\n\n  var _a = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups),\n      groupCount = _a.groupCount,\n      timeTableWidth = _a.timeTableWidth,\n      groupSize = _a.groupSize,\n      validGetCellRects = _a.validGetCellRects;\n\n  var allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(groupSize * allDayPanelsLeft + timeTableWidth * (allDayPanelsLeft + 1), groupSize);\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects\n  };\n};\n\nvar checkCellElementsMeta = function (cellElementsMeta, groupOrientation, currentView, allDayPanelExists) {\n  return groupOrientation(currentView.name) === HORIZONTAL_GROUP_ORIENTATION || !allDayPanelExists || !cellElementsMeta.getCellRects;\n};\n\nvar initializeCellElementsData = function (cellElementsMeta, viewCellsData, groups) {\n  var timeTableWidth = viewCellsData[0].length;\n  var groupCount = getGroupsLastRow(groups).length;\n  var groupHeight = viewCellsData.length / groupCount;\n  return {\n    groupCount: groupCount,\n    timeTableWidth: timeTableWidth,\n    groupSize: timeTableWidth * groupHeight,\n    validGetCellRects: cellElementsMeta.getCellRects.slice()\n  };\n};\n\nvar updateTimeCellsData = function (viewCellsData, timeCellsData, groups, sortedResources, groupOrientation) {\n  var firstViewDate = viewCellsData[0][0].startDate;\n\n  if (!containsDSTChange(firstViewDate)) {\n    return viewCellsData;\n  }\n\n  if (groupOrientation !== VERTICAL_GROUP_ORIENTATION) {\n    return timeCellsData;\n  }\n\n  return expandVerticallyGroupedCells(timeCellsData, groups, sortedResources);\n};\n\nvar allDayRects = function (appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {\n  var intervals = calculateAllDayDateIntervals(appointments, startViewDate, endViewDate, excludedDays);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, sliceAppointments);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: false\n  }, groupedIntervals, getHorizontalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta,\n    excludedDays: excludedDays\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: sliceAppointments,\n    groupCount: groups ? getGroupsLastRow(groups).length : 1\n  });\n};\n\nvar verticalTimeTableRects = function (appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration, cellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate) {\n  var intervals = calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, false);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: VERTICAL_TYPE,\n    multiline: false\n  }, groupedIntervals, getVerticalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    cellElementsMeta: cellElementsMeta\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: groupByDate,\n    groupCount: groups ? getGroupsLastRow(groups).length : 1\n  });\n};\n\nvar horizontalTimeTableRects = function (appointments, startViewDate, endViewDate, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {\n  var intervals = calculateMonthDateIntervals(appointments, startViewDate, endViewDate);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, [], sliceAppointments);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: true\n  }, groupedIntervals, getHorizontalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: sliceAppointments,\n    groupCount: groups ? getGroupsLastRow(groups).length : 1\n  });\n};\n\nvar dateTimeFormatInstance = function (locale, formatOptions) {\n  return new Intl.DateTimeFormat(locale, formatOptions);\n};\n\nvar appointments = function (data) {\n  return data.map(function (appointment, index) {\n    return __assign(__assign(__assign(__assign(__assign({\n      dataItem: appointment,\n      start: appointment.startDate\n    }, appointment.endDate !== undefined ? {\n      end: appointment.endDate\n    } : {\n      end: appointment.startDate,\n      dataItem: __assign(__assign({}, appointment), {\n        endDate: appointment.startDate\n      })\n    }), appointment.allDay !== undefined && {\n      allDay: appointment.allDay\n    }), appointment.rRule !== undefined && {\n      rRule: appointment.rRule\n    }), appointment.exDate !== undefined && {\n      exDate: appointment.exDate\n    }), {\n      key: appointment.id || index\n    });\n  });\n};\n\nvar formatDateTimeGetter = function (locale) {\n  var cache = new Map(); // any -> type\n\n  var formatter = function (nextDate, nextOptions) {\n    if (nextDate === undefined) return '';\n    var date = convertToMoment(nextDate).toDate();\n    var formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n\n  return formatter;\n};\n\nvar getCellKey = function (groups, groupIndex, rowNumber) {\n  var currentIndex = groupIndex;\n  return groups.reduceRight(function (acc, groupRow, rowIndex) {\n    if (rowNumber < rowIndex) return acc;\n    var currentKey = groupRow[currentIndex].id;\n\n    if (rowIndex > 0) {\n      var currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;\n      currentIndex = Math.floor(currentIndex / currentRowLength);\n    }\n\n    return acc + currentKey;\n  }, '');\n};\n\nvar getRowFromGroups = function (width, groupRow, cellStyle, groups, rowIndex) {\n  var row = [];\n  var currentRowLength = groupRow.length;\n  var standardWidth = width / getGroupsLastRow(groups).length;\n  var colSpan = getGroupsLastRow(groups).length / currentRowLength;\n\n  var _loop_1 = function (i) {\n    row = __spread(row, groupRow.reduce(function (acc, group, index) {\n      return __spread(acc, [{\n        group: group,\n        colSpan: colSpan,\n        key: getCellKey(groups, index, rowIndex) + i,\n        left: cellStyle.left,\n        endOfGroup: index === currentRowLength - 1\n      }]);\n    }, []));\n  };\n\n  for (var i = 0; i < standardWidth; i += 1) {\n    _loop_1(i);\n  }\n\n  return row;\n};\n\nvar getVerticalRowFromGroups = function (groups, groupIndex, groupingPanelRowSpan, timeTableCellHeight, addAllDayHeight, allDayCellHeight) {\n  return groups.reduce(function (acc, groupColumn, columnIndex) {\n    var groupSpan = getGroupsLastRow(groups).length / groupColumn.length;\n    var cellIndex = groupIndex / groupSpan;\n    var baseHeight = groupingPanelRowSpan * groupSpan * timeTableCellHeight / getGroupsLastRow(groups).length;\n    var allDayHeight = groupSpan * allDayCellHeight;\n    return groupIndex % groupSpan !== 0 ? acc : __spread(acc, [{\n      group: groupColumn[cellIndex],\n      rowSpan: groupSpan,\n      height: addAllDayHeight ? baseHeight + allDayHeight : baseHeight,\n      key: getCellKey(groups, cellIndex, columnIndex)\n    }]);\n  }, []);\n};\n\nvar getLabelsForSingleGroup = function (groups, cellsData, groupIndex, groupHeight) {\n  var currentGroupIndex = groupIndex * groupHeight;\n  var nextGroupIndex = currentGroupIndex + groupHeight;\n  return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce(function (acc, days) {\n    return __spread(acc, [{\n      startDate: days[0].startDate,\n      endDate: days[0].endDate,\n      key: days[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),\n      groupingInfo: days[0].groupingInfo\n    }]);\n  }, []);\n};\n\nvar getLabelsForAllGroups = function (cellsData, groups, groupOrientation) {\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return [cellsData.map(function (cellsRow) {\n      return {\n        startDate: cellsRow[0].startDate,\n        endDate: cellsRow[0].endDate,\n        groupingInfo: cellsRow[0].groupingInfo,\n        key: cellsRow[0].endDate\n      };\n    })];\n  }\n\n  var groupCount = getGroupsLastRow(groups).length;\n  var singleGroupHeight = cellsData.length / groupCount;\n  return getGroupsLastRow(groups).reduce(function (acc, group, groupIndex) {\n    return __spread(acc, [getLabelsForSingleGroup(groups, cellsData, groupIndex, singleGroupHeight)]);\n  }, []);\n};\n\nvar prepareVerticalViewCellsData = function (cellsData, allDayCellsData) {\n  var groupCount = (allDayCellsData === null || allDayCellsData === void 0 ? void 0 : allDayCellsData.length) || 1;\n  var validCellsData = [];\n  var groupHeight = cellsData.length / groupCount;\n\n  for (var i = 0; i < groupCount; i += 1) {\n    validCellsData.push(cellsData.slice(i * groupHeight, (i + 1) * groupHeight));\n  }\n\n  return validCellsData;\n};\n\nvar changeCurrentDate = function (currentDate, _a) {\n  var nextDate = _a.nextDate,\n      step = _a.step,\n      amount = _a.amount,\n      direction = _a.direction;\n  return nextDate || moment(currentDate)[direction === 'back' ? 'subtract' : 'add'](amount, step).toDate() || moment().subtract(amount, step);\n};\n\nvar setCurrentViewName = function (currentViewName, nextViewName) {\n  return nextViewName;\n};\n\nvar setAppointmentMeta = function (prevAppointmentMeta, _a) {\n  var target = _a.target,\n      data = _a.data;\n  return {\n    target: target,\n    data: data\n  };\n};\n\nvar OPEN_COMMAND_BUTTON = 'open';\nvar CLOSE_COMMAND_BUTTON = 'close';\nvar DELETE_COMMAND_BUTTON = 'delete';\nvar CANCEL_COMMAND_BUTTON = 'cancel';\nvar COMMIT_COMMAND_BUTTON = 'commit';\n\nvar setAppointmentData = function (prevAppointmentData, _a) {\n  var appointmentData = _a.appointmentData;\n  return appointmentData;\n};\n\nvar getWeekNumberLabels = function (getMessage) {\n  return WEEK_NUMBER_LABELS.map(function (weekNumberLabel, index) {\n    return {\n      text: getMessage(weekNumberLabel),\n      id: index\n    };\n  });\n};\n\nvar getDaysOfWeek = function (formatDate, firstDayOfWeek) {\n  var daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  var daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(function (day, index) {\n    return {\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0]\n    };\n  });\n};\n\nvar getMonths = function (formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonth(month, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthsWithOf = function (getMessage, formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonthWithOf(month, getMessage, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthWithOf = function (date, getMessage, formatDate) {\n  return getMessage('ofLabel') + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n};\n\nvar getMonth = function (date, formatDate) {\n  return formatDate(date, LONG_MONTH_OPTIONS);\n};\n\nvar getDayOfWeek = function (date, formatDate) {\n  return formatDate(date, LONG_WEEK_DAY_OPTIONS);\n};\n\nvar getMonthId = function (index) {\n  return index + 1;\n};\n\nvar getAvailableRecurrenceOptions = function (getMessage) {\n  return REPEAT_TYPES_ARRAY.map(function (type) {\n    return {\n      text: getMessage(type),\n      id: type\n    };\n  });\n};\n\nvar getCountDependingOnRecurrenceType = function (frequency) {\n  var count;\n\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n\n  return count;\n};\n\nvar checkIsNaturalNumber = function (number) {\n  return number > 0 && number <= Number.MAX_SAFE_INTEGER;\n};\n\nvar callActionIfExists = function (action, payload) {\n  if (action) {\n    action(payload);\n  }\n};\n\nvar isAllDayCell = function (startDate, endDate) {\n  return moment(endDate).diff(moment(startDate), 'days') >= 1;\n};\n\nvar changeRecurrenceFrequency = function (rule, freq, startDate) {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return new RRule(__assign(__assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return new RRule(__assign(__assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    return new RRule(__assign(__assign({}, DEFAULT_RULE_OBJECT), {\n      freq: freq,\n      count: getCountDependingOnRecurrenceType(freq)\n    })).toString();\n  }\n\n  var options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n\n  options.byweekday = undefined;\n  var nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nvar getRecurrenceOptions = function (rule) {\n  return !rule ? null : RRule.parseString(rule);\n};\n\nvar changeRecurrenceOptions = function (options) {\n  return options ? new RRule(__assign({}, options)).toString() : undefined;\n};\n\nvar handleStartDateChange = function (nextStartDay, options) {\n  if (nextStartDay <= 31) {\n    var nextOptions = __assign(__assign({}, options), {\n      bymonthday: nextStartDay\n    });\n\n    return changeRecurrenceOptions(nextOptions);\n  }\n\n  return changeRecurrenceOptions(options);\n};\n\nvar handleToDayOfWeekChange = function (weekNumber, dayOfWeek, options) {\n  var validDayOfWeek = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  var validWeekNumber = weekNumber === 4 ? -1 : weekNumber + 1;\n  var rruleDayOfWeek = RRULE_DAYS_OF_WEEK[validDayOfWeek];\n\n  var nextOptions = __assign(__assign({}, options), {\n    byweekday: [rruleDayOfWeek.nth(validWeekNumber)],\n    bymonthday: undefined\n  });\n\n  return changeRecurrenceOptions(nextOptions);\n};\n\nvar getRRuleFrequency = function (repeatType) {\n  return RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n};\n\nvar getFrequencyString = function (rRuleFrequency) {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nvar getRadioGroupDisplayData = function (recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption) {\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: recurrenceOptions.bymonthday,\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption\n    };\n  }\n\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber\n    };\n  }\n\n  var dayOfWeek = recurrenceOptions.byweekday[0].weekday < 6 ? recurrenceOptions.byweekday[0].weekday + 1 : 0;\n  var weekNumber = recurrenceOptions.byweekday[0].n === -1 ? LAST_WEEK : recurrenceOptions.byweekday[0].n - 1;\n  return {\n    dayOfWeek: dayOfWeek,\n    weekNumber: weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber\n  };\n};\n\nvar handleChangeFrequency = function (repeatType, rRule, startDate, action) {\n  var rruleRepeatType = getRRuleFrequency(repeatType);\n  var nextRRule;\n\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(rRule, rruleRepeatType, startDate);\n  }\n\n  action({\n    rRule: nextRRule\n  });\n};\n\nvar handleWeekDaysChange = function (options, currentWeekDay) {\n  var byWeekDay = options.byweekday || [];\n  var index = byWeekDay.findIndex(function (_a) {\n    var weekday = _a.weekday;\n    return weekday === currentWeekDay;\n  });\n  var isAdded = index === -1;\n\n  if (isAdded) {\n    byWeekDay.push(RRULE_DAYS_OF_WEEK[currentWeekDay]);\n  } else if (index > -1) {\n    byWeekDay.splice(index, 1);\n  }\n\n  if (byWeekDay === 0) return __assign(__assign({}, options), {\n    byweekday: undefined\n  });\n  return __assign(__assign({}, options), {\n    byweekday: byWeekDay\n  });\n};\n\nvar getDaysOfWeekArray = function (firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1;\n  });\n  var secondPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1;\n  });\n  return firstDayOfWeek !== 0 ? __spread(firstPart, secondPart) : __spread(secondPart, firstPart);\n};\n\nvar getDaysOfWeekDates = function (firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  var secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return __spread(firstPart, secondPart);\n};\n\nvar checkMultipleResourceFields = function (resourceFields, resources) {\n  return resources.reduce(function (acc, resource) {\n    var _a;\n\n    if (!resource.allowMultiple) {\n      return acc;\n    }\n\n    var fieldName = resource.fieldName;\n    var field = resourceFields[fieldName];\n    return __assign(__assign({}, acc), (_a = {}, _a[fieldName] = Array.isArray(field) ? field : [field], _a));\n  }, resourceFields);\n};\n\nvar addAppointment = function (addedAppointmentData, _a) {\n  var _b = _a === void 0 ? {\n    appointmentData: {}\n  } : _a,\n      appointmentData = _b.appointmentData;\n\n  return appointmentData;\n};\n\nvar cancelAddedAppointment = function () {\n  return {};\n};\n\nvar startEditAppointment = function (prevEditingAppointment, appointmentData) {\n  return appointmentData;\n};\n\nvar stopEditAppointment = function () {\n  return undefined;\n};\n\nvar changeAppointment = function (appointment, _a) {\n  var change = _a.change;\n  return __assign(__assign({}, appointment), change);\n};\n\nvar cancelChanges = function () {\n  return {};\n};\n\nvar changedAppointmentById = function (changes, appointmentId) {\n  var _a;\n\n  return _a = {}, _a[appointmentId] = changes, _a;\n};\n\nvar mergeNewChanges = function (appointmentData, changes) {\n  var appointment = __assign({}, appointmentData);\n\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return __assign(__assign({}, appointment), changes);\n};\n\nvar reduceExDate = function (prevExDate, boundDate) {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce(function (acc, date) {\n      var momentDate = moment.utc(date);\n\n      if (momentDate.isBefore(boundDate)) {\n        return __spread(acc, [date]);\n      }\n\n      return acc;\n    }, []).join(',');\n  }\n\n  return undefined;\n};\n\nvar configureExDate = function (exDate, date) {\n  var currentExDate = moment.utc(date).format('YYYYMMDDTHHmmss') + \"Z\";\n  return exDate ? exDate + \",\" + currentExDate : currentExDate;\n};\n\nvar configureDateSequence = function (rRule, exDate, prevStartDate, nextStartDate) {\n  var rruleSet = getRRuleSetWithExDates(exDate);\n  var currentOptions = RRule.parseString(rRule);\n  var correctedOptions = currentOptions.until ? __assign(__assign({}, currentOptions), {\n    until: moment(getUTCDate(currentOptions.until)).toDate()\n  }) : currentOptions;\n  var prevStartDateUTC = moment(getUTCDate(prevStartDate)).toDate();\n  rruleSet.rrule(new RRule(__assign(__assign({}, correctedOptions), {\n    dtstart: prevStartDateUTC\n  })));\n\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all() // we shouldn't use `new Date(string)` because this function has different results in Safari\n    .map(function (nextDate) {\n      return moment(formatDateToString(nextDate)).toDate();\n    });\n  }\n\n  var leftBound = prevStartDateUTC;\n  var rightBound = moment(getUTCDate(nextStartDate)).toDate();\n  return rruleSet.between(leftBound, rightBound, true).map(function (nextDate) {\n    return moment(formatDateToString(nextDate)).toDate();\n  });\n};\n\nvar configureICalendarRules = function (rRule, options) {\n  var rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule(__assign(__assign({}, RRule.parseString(rRule)), options)));\n  return rruleSet.valueOf();\n};\n\nvar changeCurrentAndFollowing = function (appointmentData, changes, changeAllAction) {\n  var _a;\n\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      parentData = appointmentData.parentData,\n      _b = appointmentData.exDate,\n      prevExDate = _b === void 0 ? '' : _b,\n      id = appointmentData.id;\n\n  var _c = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _c.initialSequence,\n      currentChildIndex = _c.currentChildIndex;\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n  var changedRules = configureICalendarRules(rRule, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null\n  });\n  var nextExDate = reduceExDate(prevExDate, startDate);\n  return {\n    changed: (_a = {}, _a[id] = __assign({\n      rRule: changedRules[1].slice(6)\n    }, nextExDate && prevExDate !== nextExDate ? {\n      exDate: nextExDate\n    } : {}), _a)\n  };\n};\n\nvar getAppointmentSequenceData = function (prevStartDate, startDate, exDate, rRule) {\n  var initialSequence = configureDateSequence(rRule, exDate, moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate());\n  var currentChildIndex = initialSequence.findIndex(function (date) {\n    return moment(date).isSame(startDate);\n  });\n  return {\n    initialSequence: initialSequence,\n    currentChildIndex: currentChildIndex\n  };\n};\n\nvar deleteCurrent = function (appointmentData) {\n  var _a;\n\n  var currentSequence = configureDateSequence(appointmentData.rRule, appointmentData.exDate, moment.utc(appointmentData.parentData.startDate).toDate(), moment.utc(appointmentData.startDate).toDate());\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  var nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate);\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: nextExDate\n    }, _a)\n  };\n};\n\nvar deleteAll = function (appointmentData) {\n  return {\n    deleted: appointmentData.id\n  };\n};\n\nvar deleteCurrentAndFollowing = function (appointmentData) {\n  return changeCurrentAndFollowing(appointmentData, {}, deleteAll);\n};\n\nvar editAll = function (appointmentData, changes) {\n  var _a, _b;\n\n  var rRule = appointmentData.rRule,\n      id = appointmentData.id;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  if (changes.startDate && moment.utc(changes.startDate).isAfter(initialRule.options.until)) {\n    return {\n      changed: (_a = {}, _a[id] = __assign(__assign({}, changes), {\n        rRule: 'FREQ=DAILY;COUNT=1',\n        exDate: ''\n      }), _a)\n    };\n  }\n\n  return {\n    changed: (_b = {}, _b[appointmentData.id] = changes, _b)\n  };\n};\n\nvar editCurrent = function (appointmentData, changes) {\n  var _a;\n\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate)\n    }, _a),\n    added: mergeNewChanges(appointmentData, changes)\n  };\n};\n\nvar editCurrentAndFollowing = function (appointmentData, changes) {\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      _a = appointmentData.exDate,\n      prevExDate = _a === void 0 ? '' : _a,\n      parentData = appointmentData.parentData;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  var _b = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _b.initialSequence,\n      currentChildIndex = _b.currentChildIndex;\n\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n  var addedOptions = initialRule.options.count || initialRule.options.until ? {\n    count: initialSequence.length - currentChildIndex\n  } : {};\n  var addedRules = configureICalendarRules(appointmentData.rRule, __assign({\n    dtstart: moment.utc(startDate).toDate()\n  }, addedOptions));\n  var addedAppointment = moment.utc(changes.startDate).isAfter(initialRule.options.until) ? {\n    rRule: 'FREQ=DAILY;COUNT=1',\n    exDate: ''\n  } : {\n    rRule: addedRules[1].slice(6)\n  };\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: __assign(__assign({}, addedAppointment), mergeNewChanges(appointmentData, changes))\n  };\n};\n\nvar preCommitChanges = function (changes, appointmentData, editType) {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return deleteAll(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return deleteCurrent(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return deleteCurrentAndFollowing(appointmentData);\n        }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return editAll(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return editCurrent(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return editCurrentAndFollowing(appointmentData, changes);\n        }\n    }\n  }\n\n  return {};\n};\n\nvar clamp = function (value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar calculateInsideOffset = function (targetType, insidePart, cellDurationMinutes) {\n  return targetType === VERTICAL_TYPE ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n};\n\nvar cellType = function (data) {\n  return moment(data.startDate).isSame(data.endDate, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n};\n\nvar intervalDuration = function (data, type) {\n  return moment(data.endDate).diff(data.startDate, type);\n};\n\nvar cellIndex = function (getCellRects, clientOffset) {\n  return getCellRects.findIndex(function (getCellRect) {\n    var _a = getCellRect(),\n        left = _a.left,\n        top = _a.top,\n        right = _a.right,\n        bottom = _a.bottom;\n\n    var isOver = clientOffset && clamp(clientOffset.x, left, right) === clientOffset.x && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n    return isOver;\n  });\n};\n\nvar cellData = function (timeTableIndex, allDayIndex, viewCellsData, allDayCellsData) {\n  var cellsData = allDayIndex !== -1 ? allDayCellsData : viewCellsData;\n  var currentIndex = allDayIndex !== -1 ? allDayIndex : timeTableIndex;\n  var tableWidth = cellsData[0].length;\n  var rowIndex = Math.floor(currentIndex / tableWidth);\n  var columnIndex = currentIndex % tableWidth;\n  return cellsData[rowIndex][columnIndex];\n};\n\nvar autoScroll = function (clientOffset, scrollingStrategy, scrollSpeed) {\n  scroll(clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary, scrollingStrategy.changeVerticalScroll, scrollSpeed);\n  scroll(clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary, scrollingStrategy.changeHorizontalScroll, scrollSpeed);\n};\n\nvar scroll = function (offset, firstBoundary, secondBoundary, changeScroll, scrollSpeed) {\n  if (offset < firstBoundary + SCROLL_OFFSET && offset > firstBoundary) {\n    changeScroll(-scrollSpeed);\n  }\n\n  if (secondBoundary - SCROLL_OFFSET < offset) {\n    changeScroll(+scrollSpeed);\n  }\n};\n\nvar timeBoundariesByResize = function (payload, targetData, targetType, cellDurationMinutes, insidePart) {\n  if (targetType !== payload.appointmentType) {\n    return {\n      appointmentStartTime: undefined,\n      appointmentEndTime: undefined\n    };\n  }\n\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    var insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate).add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  if (sourceType === RESIZE_BOTTOM) {\n    var insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate).add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate).toDate();\n  } // keep origin appointment duration if coordinates are wrong\n\n\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime\n  };\n};\n\nvar timeBoundariesByDrag = function (payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  if (targetType === HORIZONTAL_TYPE && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate,\n      appointmentEndTime: targetData.endDate,\n      offsetTimeTop: 0\n    };\n  }\n\n  var offsetTimeTop;\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  var start = moment(targetData.startDate).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate).diff(payload.startDate, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    var appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add(offsetTimeTop * -1, SECONDS).toDate();\n    appointmentEndTime = moment(start).add(appointmentDurationSeconds - offsetTimeTop, SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate).add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate).add(insideOffset, SECONDS).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime,\n    offsetTimeTop: offsetTimeTop\n  };\n};\n\nvar calculateAppointmentTimeBoundaries = function (payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  var isDragging = payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE;\n  return isDragging ? timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) : timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart);\n};\n\nvar calculateInsidePart = function (top, timeTableCellsRects, timeTableIndex) {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    var cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n\n  return 0;\n};\n\nvar calculateDraftAppointments = function (allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, targetType, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate) {\n  if (allDayIndex !== -1 || targetType === VERTICAL_TYPE && getAllDayCellsElementRects.getCellRects.length && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23) {\n    var allDayDrafts = draftAppointments.map(function (draftAppt) {\n      return __assign(__assign({}, draftAppt), {\n        allDay: true\n      });\n    });\n    return {\n      allDayDraftAppointments: allDayRects(allDayDrafts, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, grouping, resources, groups, groupOrientation, groupedByDate),\n      timeTableDraftAppointments: []\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)\n    };\n  }\n\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(draftAppointments, startViewDate, endViewDate, viewCellsData, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)\n  };\n};\n\nvar calculateAppointmentGroups = function (cellGroupingInfo, resources, appointmentData) {\n  if (!cellGroupingInfo) return {};\n  return cellGroupingInfo.reduce(function (acc, group) {\n    var _a;\n\n    var isMultipleResource = resources.find(function (resource) {\n      return resource.fieldName === group.fieldName;\n    }).allowMultiple;\n    return __assign(__assign({}, acc), (_a = {}, _a[group.fieldName] = isMultipleResource ? updateMultipleResourceInfo(group, appointmentData) : group.id, _a));\n  }, {});\n};\n\nvar updateMultipleResourceInfo = function (cellResource, appointmentData) {\n  var appointmentGroupItems = appointmentData[cellResource.fieldName];\n\n  if (appointmentGroupItems.findIndex(function (groupItem) {\n    return groupItem === cellResource.id;\n  }) !== -1) {\n    return appointmentGroupItems;\n  }\n\n  return [cellResource.id];\n};\n\nvar appointmentDragged = function (start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) {\n  if (moment(start).isSame(startPrev) && moment(end).isSame(endPrev) && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar groupingInfoNotChanged = function (groupingInfo, groupingInfoPrev) {\n  var fields = Object.getOwnPropertyNames(groupingInfo);\n  return fields.every(function (field) {\n    if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {\n      return groupingInfo[field].every(function (item, index) {\n        return item === groupingInfoPrev[field][index];\n      });\n    }\n\n    return groupingInfo[field] === groupingInfoPrev[field];\n  });\n};\n\nvar isMonthCell = function (otherMonth) {\n  return otherMonth !== undefined;\n};\n\nvar isShadedAppointment = function (_a, currentTime, shadePreviousAppointments) {\n  var appointmentData = _a.data;\n  var momentCurrentDate = moment(currentTime);\n\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate, 'day') && shadePreviousAppointments;\n  }\n\n  if (momentCurrentDate.isAfter(appointmentData.endDate)) {\n    return shadePreviousAppointments;\n  }\n\n  return false;\n};\n\nvar getCurrentTimeIndicatorTop = function (cellData, currentTime) {\n  var top = (currentTime - cellData.startDate.getTime()) * 100 / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return top < 0 || top > 100 ? undefined : top + \"%\";\n};\n\nvar isCellShaded = function (_a, currentTime, shadePreviousCells) {\n  var startDate = _a.startDate,\n      endDate = _a.endDate,\n      otherMonth = _a.otherMonth;\n  var monthCell = isMonthCell(otherMonth);\n  return (startDate.getTime() < currentTime && !monthCell || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n\nvar getAppointmentResources = function (appointment, resources, plainResources) {\n  if (!resources || resources.length === 0 || !plainResources || plainResources.length === 0) return [];\n  return resources.reduce(function (acc, resource) {\n    var appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId) || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return __spread(acc, appointmentResourceId.reduce(function (prevResources, itemId) {\n        return addResourceToAppointmentResources(plainResources, prevResources, resource, itemId);\n      }, []));\n    }\n\n    return addResourceToAppointmentResources(plainResources, acc, resource, appointmentResourceId);\n  }, []);\n};\n\nvar addResourceToAppointmentResources = function (plainResources, appointmentResources, resource, resourceId) {\n  var currentResource = plainResources.find(function (plainItem) {\n    return resource.fieldName === plainItem.fieldName && plainItem.id === resourceId;\n  });\n  return currentResource ? __spread(appointmentResources, [currentResource]) : appointmentResources;\n};\n\nvar convertResourcesToPlain = function (validResources) {\n  return validResources.reduce(function (acc, resource) {\n    return __spread(acc, resource.instances.map(function (item) {\n      return item;\n    }));\n  }, []);\n};\n\nvar validateResources = function (resources, mainResourceName, palette) {\n  var isMainResourceDefined = !!mainResourceName;\n  var currentPaletteIndex = 0;\n  return resources.map(function (resource, groupIndex) {\n    var fieldName = resource.fieldName;\n    var isMain = isMainResourceDefined && mainResourceName === fieldName || groupIndex === 0 && !isMainResourceDefined;\n    var title = resource.title || fieldName;\n    var allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName: fieldName,\n      isMain: isMain,\n      title: title,\n      allowMultiple: allowMultiple,\n      instances: resource.instances.map(function (resourceItem) {\n        var color = resourceItem.color || palette[currentPaletteIndex % palette.length];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n        return {\n          id: resourceItem.id,\n          color: color,\n          fieldName: fieldName,\n          text: resourceItem.text || title || fieldName,\n          title: title,\n          allowMultiple: allowMultiple,\n          isMain: isMain\n        };\n      })\n    };\n  });\n};\n\nvar addResourcesToAppointments = function (appointments, resources, plainResources) {\n  return [appointments.map(function (appointment) {\n    return __assign(__assign({}, appointment), {\n      resources: getAppointmentResources(appointment.dataItem, resources, plainResources)\n    });\n  })];\n};\n\nvar toggleExpandedGroups = function (state, _a) {\n  var groupKey = _a.groupKey;\n  var expandedGroups = slice(state.expandedGroups);\n  var groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups: expandedGroups\n  };\n};\n\nvar getDayScaleCellColSpan = function (cellsData) {\n  var firstDate = cellsData[0][0].startDate;\n  var count = 1;\n\n  while (cellsData[0][count] && moment(cellsData[0][count].startDate).isSame(firstDate, 'day')) {\n    count += 1;\n  }\n\n  return count;\n};\n\nvar getDayScaleCells = function (cellsData, groupedByDate) {\n  if (!groupedByDate) {\n    return cellsData[0].map(function (_a, index) {\n      var startDate = _a.startDate,\n          endDate = _a.endDate,\n          today = _a.today,\n          endOfGroup = _a.endOfGroup,\n          groupingInfo = _a.groupingInfo;\n      return {\n        key: index.toString(),\n        startDate: startDate,\n        endDate: endDate,\n        today: today,\n        endOfGroup: endOfGroup,\n        groupingInfo: groupingInfo\n      };\n    });\n  }\n\n  var prevDate;\n  var colSpan = getDayScaleCellColSpan(cellsData);\n  return cellsData[0].reduce(function (acc, _a, index) {\n    var startDate = _a.startDate,\n        endDate = _a.endDate,\n        today = _a.today;\n    var currentDate = moment(startDate);\n\n    if (currentDate.isSame(prevDate)) {\n      return acc;\n    }\n\n    prevDate = currentDate;\n    return __spread(acc, [{\n      key: index.toString(),\n      startDate: startDate,\n      endDate: endDate,\n      today: today,\n      colSpan: colSpan,\n      endOfGroup: true\n    }]);\n  }, []);\n};\n\nvar navigateByOneMonth = function (currentDate, isBackward) {\n  return moment(currentDate)[isBackward ? 'subtract' : 'add'](1, 'month').toDate();\n};\n/** @internal */\n\n\nvar RecurrenceFrequency;\n\n(function (RecurrenceFrequency) {\n  RecurrenceFrequency[RecurrenceFrequency[\"Daily\"] = RRULE_REPEAT_TYPES.DAILY] = \"Daily\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Weekly\"] = RRULE_REPEAT_TYPES.WEEKLY] = \"Weekly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Monthly\"] = RRULE_REPEAT_TYPES.MONTHLY] = \"Monthly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Yearly\"] = RRULE_REPEAT_TYPES.YEARLY] = \"Yearly\";\n})(RecurrenceFrequency || (RecurrenceFrequency = {}));\n\nexport { APRIL_DATE, AUGUST_DATE, AUTO_HEIGHT, BASIC_DAILY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_YEALY_COUNT, CANCEL_BUTTON, CANCEL_COMMAND_BUTTON, CLOSE_COMMAND_BUTTON, COMMIT_COMMAND_BUTTON, DAYS_IN_WEEK, DAYS_OF_WEEK, DAYS_OF_WEEK_ARRAY, DAYS_OF_WEEK_DATES, DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_LONG_MONTH_OPTIONS, DAY_OPTIONS, DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS, DECEMBER_DATE, DEFAULT_RULE_OBJECT, DELETE_BUTTON, DELETE_COMMAND_BUTTON, EMPTY_OPTIONS, END_REPEAT_RADIO_GROUP, FEBRUARY_DATE, FIRST_WEEK, FOURTH_WEEK, FRIDAY_DATE, HORIZONTAL_GROUP_ORIENTATION, HORIZONTAL_TYPE, HORIZONTAL_VIEW_LEFT_OFFSET, HOURS, HOUR_MINUTE_OPTIONS, JANUARY_DATE, JULY_DATE, JUNE_DATE, LAST_WEEK, LONG_MONTH_OPTIONS, LONG_WEEK_DAY_OPTIONS, MARCH_DATE, MAY_DATE, MINUTES, MONDAY_DATE, MONTHLY_RADIO_GROUP, MONTHS, MONTHS_DATES, MONTH_YEAR_OPTIONS, MULTILINE_TEXT_EDITOR, NOVEMBER_DATE, NUMBER_EDITOR, OCTOBER_DATE, OPEN_COMMAND_BUTTON, ORDINARY_LABEL, ORDINARY_TEXT_EDITOR, OUTLINED_SELECT, POSITION_END, POSITION_START, RECURRENCE_EDIT_SCOPE, REPEAT_TYPES, REPEAT_TYPES_ARRAY, RESIZE_BOTTOM, RESIZE_TOP, RRULE_DAYS_OF_WEEK, RRULE_REPEAT_TYPES, RecurrenceFrequency, SATURDAY_DATE, SAVE_BUTTON, SCROLL_OFFSET, SCROLL_SPEED_PX, SECONDS, SECOND_WEEK, SEPTEMBER_DATE, SHORT_MONTH_LONG_YEAR_OPTIONS, SHORT_MONTH_OPTIONS, SHORT_MONTH_SHORT_YEAR_OPTIONS, STANDARD_SELECT, SUNDAY_DATE, THIRD_WEEK, THURSDAY_DATE, TITLE, TITLE_TEXT_EDITOR, TOGGLE_APPOINTMENT_FORM_VISIBILITY, TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY, TUESDAY_DATE, VERTICAL_GROUP_ORIENTATION, VERTICAL_TYPE, VERTICAL_VIEW_LEFT_OFFSET, VIEW_TYPES, WEDNESDAY_DATE, WEEKDAY_INTERVAL, WEEK_DAY_OPTIONS, WEEK_NUMBER_LABELS, YEARLY_RADIO_GROUP, addAppointment, addDateToKey, addGroupInfoToCell, addGroupInfoToCells, addResourcesToAppointments, adjustByBlocks, allDayCells, allDayPredicate, allDayRects, appointmentDragged, appointments, areDatesSame, autoScroll, availableViews, calculateAllDayDateIntervals, calculateAppointmentGroups, calculateAppointmentLeftAndWidth, calculateAppointmentOffsets, calculateAppointmentTimeBoundaries, calculateAppointmentsMetaData, calculateBlocksLeftLimit, calculateBlocksTotalSize, calculateDraftAppointments, calculateFirstDateOfWeek, calculateIncludedBlockMaxRight, calculateInsidePart, calculateMonthDateIntervals, calculateRectByDateAndGroupIntervals, calculateWeekDateIntervals, callActionIfExists, cancelAddedAppointment, cancelChanges, cellData, cellIndex, cellType, changeAppointment, changeCurrentDate, changeRecurrenceFrequency, changeRecurrenceOptions, changedAppointmentById, checkCellGroupingInfo, checkIsNaturalNumber, checkMultipleResourceFields, computed, containsDSTChange, convertResourcesToPlain, convertToMoment, createAppointmentForest, dayBoundaryPredicate, dayScale, deleteAll, deleteCurrent, deleteCurrentAndFollowing, editAll, editCurrent, editCurrentAndFollowing, endViewDate, excludedIntervals, expandGroupedAppointment, expandGroups, expandViewCellsDataWithGroups, filterByViewBoundaries, filterResourcesByGrouping, findBlockIndexByAppointment, findChildBlocks, findChildrenMaxEndDate, findIncludedBlocks, findMaxReduceValue, findOverlappedAppointments, formatDateTimeGetter, formatDateToString, getAllDayCellIndexByAppointmentData, getAllDayHorizontallyGroupedColumnIndex, getAllDayVerticallyGroupedColumnIndex, getAllDayVerticallyGroupedRowIndex, getAppointmentResources, getAppointmentStyle, getAvailableRecurrenceOptions, getCellKey, getCountDependingOnRecurrenceType, getCurrentTimeIndicatorTop, getDayScaleCellColSpan, getDayScaleCells, getDaysOfWeek, getDaysOfWeekArray, getDaysOfWeekDates, getFrequencyString, getGroupFromResourceInstance, getGroupingInfoFromGroups, getGroupsFromResources, getGroupsLastRow, getHorizontalRectByAppointmentData, getLabelsForAllGroups, getMonthCellIndexByAppointmentData, getMonthHorizontallyGroupedColumnIndex, getMonthVerticallyGroupedRowIndex, getMonths, getMonthsWithOf, getRRuleFrequency, getRRuleSetWithExDates, getRadioGroupDisplayData, getRecurrenceOptions, getRowFromGroups, getTimeTableHeight, getUTCDate, getVerticalCellIndexByAppointmentData, getVerticalRectByAppointmentData, getVerticalRowFromGroups, getViewType, getWeekHorizontallyGroupedColumnIndex, getWeekHorizontallyGroupedRowIndex, getWeekNumberLabels, getWeekVerticallyGroupedColumnIndex, getWeekVerticallyGroupedRowIndex, groupAppointments, groupAppointmentsIntoBlocks, handleChangeFrequency, handleStartDateChange, handleToDayOfWeekChange, handleWeekDaysChange, horizontalTimeTableRects, intervalDuration, intervalIncludes, isAllDayCell, isAllDayElementsMetaActual, isCellShaded, isDateValid, isMidnight, isMonthCell, isOverlappingSubTreeRoot, isPossibleChild, isShadedAppointment, isTimeTableElementsMetaActual, monthCellsData, navigateByOneMonth, normalizeAppointmentDuration, preCommitChanges, prepareToGroupIntoBlocks, prepareVerticalViewCellsData, rearrangeResources, reduceAppointmentByDayBounds, setAppointmentData, setAppointmentMeta, setCurrentViewName, sliceAppointmentByDay, sliceAppointmentByWeek, sliceAppointmentsByBoundaries, sliceAppointmentsByDays, sortAppointments, sortFilteredResources, startEditAppointment, startViewDate, stopEditAppointment, timeBoundariesByDrag, timeBoundariesByResize, timeCellsData, timeScale, toPercentage, toggleExpandedGroups, unwrapGroups, updateAllDayCellElementsMeta, updateBlocksLeft, updateBlocksProportions, updateGroupingWithMainResource, updateTimeCellsData, updateTimeTableCellElementsMeta, validateResources, verticalTimeTableRects, viewBoundText, viewCellsData, viewPredicate };","map":{"version":3,"sources":["../src/utils.ts","../src/constants.ts","../src/plugins/common/helpers.ts","../src/plugins/common/computeds.ts","../src/plugins/appointments/helpers.ts","../src/plugins/week-view/helpers.ts","../src/plugins/week-view/computeds.ts","../src/plugins/vertical-rect/helpers.ts","../src/plugins/all-day-panel/helpers.ts","../src/plugins/appointment-form/constants.ts","../src/plugins/month-view/helpers.ts","../src/plugins/horizontal-rect/helpers.ts","../src/plugins/month-view/computeds.ts","../src/plugins/all-day-panel/computeds.ts","../src/plugins/integrated-grouping/helpers.ts","../src/plugins/integrated-grouping/computeds.ts","../src/plugins/common/calculate-rects.ts","../src/plugins/scheduler-core/helpers.ts","../src/plugins/scheduler-core/computeds.ts","../src/plugins/grouping-panel/utils.ts","../src/plugins/week-view/utils.ts","../src/plugins/view-state/reducers.ts","../src/plugins/appointment-tooltip/reducers.ts","../src/plugins/appointment-tooltip/constants.ts","../src/plugins/appointment-form/reducers.ts","../src/plugins/appointment-form/utils.ts","../src/plugins/appointment-form/helpers.ts","../src/plugins/editing-state/reducers.ts","../src/plugins/editing-state/computeds.ts","../src/plugins/editing-state/helpers.ts","../src/plugins/drag-drop-provider/helpers.ts","../src/plugins/current-time-indicator/helpers.tsx","../src/plugins/resources/helpers.ts","../src/plugins/resources/computeds.ts","../src/plugins/grouping-state/reducers.ts","../src/plugins/common/utils.ts","../src/plugins/date-navigator/helpers.ts","../src/types/appointment-form.types.ts"],"names":["isMidnight","getCellRect"],"mappings":"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","sourcesContent":["import moment from 'moment';\nimport { CustomFunction, PureComputed } from '@devexpress/dx-core';\nimport { RRule, RRuleSet } from 'rrule';\nimport {\n  ComputedHelperFn, ViewPredicateFn,\n  CalculateFirstDateOfWeekFn, AppointmentMoment,\n  Interval, Rect, AppointmentKey,\n} from './types';\n\nexport const computed: ComputedHelperFn = (getters, viewName, baseComputed, defaultValue) => {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n  return baseComputed(getters, viewName);\n};\n\nexport const toPercentage: PureComputed<\n  [number, number]\n> = (value, total) => (value * 100) / total;\n\nconst createExcludedInterval: CustomFunction<\n  [number, moment.Moment], Interval\n> = (day, start) => {\n  const leftBound = moment(start.day(day));\n  return [\n    leftBound,\n    moment(leftBound).hour(start.hour()).endOf('day'),\n  ];\n};\n\nexport const excludedIntervals: PureComputed<\n  [number[], moment.Moment], Interval[]\n> = (excludedDays, start) => excludedDays\n  .map(day => (day === 0 ? 7 : day))\n  .sort((a, b) => a - b)\n  .reduce((acc, day, i, allDays) => {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[acc.length - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n    return acc;\n  }, [] as Interval[]);\n\nconst inInterval = (\n  date: moment.Moment, interval: Interval,\n) => date.isBetween(interval[0], interval[1], undefined, '[]');\n\nexport const viewPredicate: ViewPredicateFn = (\n  appointment, left, right,\n  excludedDays = [],\n  removeAllDayAppointments = false,\n) => {\n  const { start, end } = appointment;\n  const isAppointmentInBoundary = end.isAfter(left as Date)\n    && start.isBefore(right as Date);\n\n  const isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left as Date))\n    .find(interval => (inInterval(start, interval) && inInterval(end, interval)));\n  const considerAllDayAppointment = removeAllDayAppointments\n    ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay\n    : true;\n\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nexport const calculateFirstDateOfWeek: CalculateFirstDateOfWeekFn = (\n  currentDate, firstDayOfWeek, excludedDays = [],\n) => {\n  const currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: { dow: firstDayOfWeek, doy: 1 }, // `doy` is required for TS using\n  });\n  const firstDateOfWeek = moment(currentDate as Date).startOf('week');\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach((day) => {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n  moment.locale(currentLocale);\n\n  return firstDateOfWeek.toDate();\n};\n\nexport const getAppointmentStyle: PureComputed<\n  [Rect], React.CSSProperties\n> = ({\n  top, left,\n  width, height,\n}) => ({\n  height,\n  width: `${width}%`,\n  transform: `translateY(${top}px)`,\n  msTransform: `translateY(${top}px)`,\n  left: `${left}%`,\n  position: 'absolute',\n});\n\nconst expandRecurrenceAppointment = (\n  appointment: AppointmentMoment, leftBound: Date, rightBound: Date,\n) => {\n  const rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  const leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  const appointmentStartDate = moment(appointment.start).toDate();\n  const options = {\n    ...RRule.parseString(appointment.rRule),\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate(),\n  };\n  const correctedOptions = options.until\n    ? { ...options, until: moment(getUTCDate(options.until)).toDate() }\n    : options;\n\n  const rruleSet = getRRuleSetWithExDates(appointment.exDate);\n\n  rruleSet.rrule(new RRule(correctedOptions));\n\n  // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n  const datesInBoundaries = rruleSet.between(leftBoundUTC as Date, rightBoundUTC as Date, true)\n    .map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n\n  const appointmentDuration = moment(appointment.end)\n    .diff(appointment.start, 'minutes');\n\n  return datesInBoundaries.map((startDate, index) => ({\n    ...appointment,\n    dataItem: {\n      ...appointment.dataItem,\n      startDate: moment(startDate).toDate(),\n      endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n      parentData: appointment.dataItem,\n    },\n    start: moment(startDate),\n    end: moment(startDate).add(appointmentDuration, 'minutes'),\n    key: `${appointment.key}_rec_${index}`,\n  }));\n};\n\nexport const filterByViewBoundaries: PureComputed<\n  [AppointmentMoment, Date, Date, number[], boolean], AppointmentMoment[]\n> = (appointment, leftBound, rightBound, excludedDays, removeAllDay) => {\n  let appointments = [appointment];\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(\n      appointment as AppointmentMoment, leftBound as Date, rightBound as Date,\n    );\n  }\n  return appointments.filter(appt => viewPredicate(\n    appt, leftBound, rightBound, excludedDays, removeAllDay,\n  ));\n};\n\nexport const getUTCDate: PureComputed<[Date], number> = date =>\n  Date.UTC(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n);\n\nexport const getRRuleSetWithExDates: PureComputed<\n  [string | undefined], RRuleSet\n> = (exDate) => {\n  const rruleSet = new RRuleSet();\n  if (exDate) {\n    exDate.split(',').map((date: string) => {\n      const currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n  return rruleSet;\n};\n\nexport const formatDateToString = (date: Date | string | number) => moment.utc(date).format('YYYY-MM-DDTHH:mm');\n\nexport const addDateToKey: PureComputed<\n  [AppointmentKey, moment.Moment], AppointmentKey\n> = (prevKey, momentDate) => `${prevKey}_${momentDate.toDate().toString()}`;\n","import { GroupOrientation } from './types';\n\nexport const VERTICAL_TYPE = 'vertical';\nexport const HORIZONTAL_TYPE = 'horizontal';\n\nexport const SCROLL_OFFSET = 50;\nexport const SCROLL_SPEED_PX = 15;\n\nexport const SECONDS = 'seconds';\nexport const MINUTES = 'minutes';\nexport const HOURS = 'hours';\n\nexport const RESIZE_TOP = 'resize-start';\nexport const RESIZE_BOTTOM = 'resize-end';\n\nexport const POSITION_START = 'start';\nexport const POSITION_END = 'end';\n\nexport const AUTO_HEIGHT = 'auto';\n\nexport const DAY_OPTIONS = { day: 'numeric' };\nexport const WEEK_DAY_OPTIONS = { weekday: 'short' };\nexport const SHORT_MONTH_OPTIONS = { month: 'short' };\nexport const HOUR_MINUTE_OPTIONS = { hour: 'numeric', minute: 'numeric' };\nexport const MONTH_YEAR_OPTIONS = { month: 'long', year: 'numeric' };\nexport const DAY_SHORT_MONTH_OPTIONS = { day: 'numeric', month: 'short' };\nexport const SHORT_MONTH_LONG_YEAR_OPTIONS = { month: 'short', year: 'numeric' };\nexport const SHORT_MONTH_SHORT_YEAR_OPTIONS = { month: 'short', year: '2-digit' };\nexport const DAY_LONG_MONTH_LONG_YEAR_OPTIONS = { day: 'numeric', month: 'long', year: 'numeric' };\nexport const DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric', month: 'short', year: 'numeric',\n};\nexport const DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric', month: 'short', year: '2-digit',\n};\nexport const LONG_WEEK_DAY_OPTIONS = { weekday: 'long' };\nexport const LONG_MONTH_OPTIONS = { month: 'long' };\nexport const DAY_LONG_MONTH_OPTIONS = { day: 'numeric', month: 'long' };\nexport const EMPTY_OPTIONS = {};\n\nexport const RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current',\n};\n\nexport const TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nexport const TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\n\nexport const WEEKDAY_INTERVAL = 'weekdayInterval';\n\nexport const VERTICAL_VIEW_LEFT_OFFSET = 80;\nexport const HORIZONTAL_VIEW_LEFT_OFFSET = 0;\n\nexport const VERTICAL_GROUP_ORIENTATION = 'Vertical' as GroupOrientation;\nexport const HORIZONTAL_GROUP_ORIENTATION = 'Horizontal' as GroupOrientation;\n\nexport const VIEW_TYPES = {\n  MONTH: 'month',\n  WEEK: 'week',\n  DAY: 'day',\n  ALL_DAY_PANEL: 'allDayPanel',\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE, DAY_OPTIONS, SHORT_MONTH_OPTIONS,\n  DAY_SHORT_MONTH_OPTIONS, SHORT_MONTH_LONG_YEAR_OPTIONS,\n  SHORT_MONTH_SHORT_YEAR_OPTIONS, MONTH_YEAR_OPTIONS,\n  DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS,\n  DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, LONG_WEEK_DAY_OPTIONS, EMPTY_OPTIONS,\n  WEEKDAY_INTERVAL,\n} from '../../constants';\nimport {\n  ViewBoundTextFn, FormatterFn, ViewCell,\n  AppointmentMoment, Group, SchedulerDateTime, CellElementsMeta,\n} from '../../types';\n\nconst MONTH_TYPE = 'month';\n\nexport const getViewType: PureComputed<[string], string> = (currentViewType) => {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nexport const isMidnight: PureComputed<\n  [Date], boolean\n> = (date) => {\n  const momentDate = moment(date as Date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nconst calculateTextByDays: PureComputed<\n  [Date, Date, FormatterFn, object], string\n> = (startViewDate, endViewDate, formatDate, additionalOptions) => {\n  const momentStartViewDate = moment(startViewDate as Date);\n  const momentEndViewDate = moment(endViewDate as Date);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), {\n      ...DAY_LONG_MONTH_LONG_YEAR_OPTIONS, ...additionalOptions,\n    });\n  }\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return `${\n        formatDate(momentStartViewDate.toDate(), DAY_OPTIONS)\n      }-${\n        formatDate(momentEndViewDate.toDate(), DAY_OPTIONS)\n      } ${\n        formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS)\n      }`;\n    }\n    return `${\n      formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS)\n    } - ${\n      formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS)\n    }`;\n  }\n  return `${\n    formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  } - ${\n    formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  }`;\n};\n\nconst calculateTextByMonths: PureComputed<\n  [Date, number, FormatterFn], string\n> = (currentDate, intervalCount, formatDate) => {\n  const momentCurrentDate = moment(currentDate as Date);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n  const lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return `${\n      formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS)\n    }-${\n      formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS)\n    }`;\n  }\n  return `${\n    formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  } - ${\n    formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  }`;\n};\n\nexport const viewBoundText: ViewBoundTextFn = (\n  startViewDate, endViewDate, type, currentDate, intervalCount, formatDate,\n) => (type !== 'month'\n  ? calculateTextByDays(\n    startViewDate, endViewDate, formatDate,\n    type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS,\n  )\n  : calculateTextByMonths(currentDate, intervalCount, formatDate)\n);\n\nexport const checkCellGroupingInfo: PureComputed<\n  [ViewCell, AppointmentMoment], boolean\n> = (cell, appointment) => cell.groupingInfo\n  ? cell.groupingInfo.every((group: Group) => (\n    group.id === appointment[group.fieldName]\n  ))\n  : true;\n\nexport const isDateValid: PureComputed<\n  [Date], boolean\n> = date => moment(date as Date).isValid();\n\nexport const convertToMoment: PureComputed<\n  [SchedulerDateTime], moment.Moment\n> = date => moment(date as SchedulerDateTime);\n\nexport const areDatesSame: PureComputed<\n  [SchedulerDateTime, SchedulerDateTime], boolean\n> = (firstDate, secondDate) => moment(firstDate as SchedulerDateTime)\n  .isSame(secondDate as SchedulerDateTime, 'date');\n\nexport const getTimeTableHeight: PureComputed<\n  [CellElementsMeta], number | undefined\n> = timeTableElementsMeta => timeTableElementsMeta.parentRect?.().height;\n\nexport const containsDSTChange = (date: SchedulerDateTime) => {\n  const momentDate = moment(date);\n  momentDate.startOf('day');\n  const isStartDST = momentDate.isDST();\n\n  momentDate.endOf('day');\n  const isEndDst = momentDate.isDST();\n\n  return (isStartDST && !isEndDst) || (!isStartDST && isEndDst);\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TimeScale, SchedulerDateTime, ViewCell,\n  DayScaleFn, TimeScaleFn, ViewCellsDataFn, AllDayCell,\n  SchedulerView,\n} from '../../types';\nimport { calculateFirstDateOfWeek } from '../../utils';\nimport {\n  isMidnight,\n  containsDSTChange,\n} from './helpers';\n\nconst subtractSecond: PureComputed<\n  [Date]\n> = date => moment(date as Date).subtract(1, 'second').toDate();\n\nexport const dayScale: DayScaleFn = (\n  currentDate,\n  firstDayOfWeek,\n  dayCount,\n  excluded = [],\n) => {\n  const result: Date[] = [];\n  const date = firstDayOfWeek !== undefined\n    ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded) as Date)\n    : moment(currentDate as Date);\n  for (let index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(item => item === date.day()) === -1) {\n      result.push(date.toDate());\n    }\n    date.add(1, 'days');\n  }\n  return result;\n};\n\nexport const timeScale: TimeScaleFn = (\n  currentDate,\n  firstDayOfWeek,\n  startDayHour,\n  endDayHour,\n  cellDuration,\n  excludedDays,\n) => {\n  const result: TimeScale[] = [];\n  const startDateOfView = firstDayOfWeek !== undefined\n    ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays)\n    : currentDate;\n\n  const isDSTChange = containsDSTChange(startDateOfView as Date);\n  const validDate = moment(startDateOfView as Date);\n  if (isDSTChange) {\n    validDate.subtract(1, 'day');\n  }\n\n  const left = moment(validDate)\n    .startOf('day')\n    .add(startDayHour, 'hour');\n  const right = moment(validDate)\n    .startOf('day')\n    .add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    const startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({ start: startDate, end: left.toDate() });\n  }\n\n  const timeScaleLastIndex = result.length - 1;\n  if (isMidnight(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end) as Date;\n  }\n  return result;\n};\n\nexport const availableViews: PureComputed<\n  [SchedulerView[], string, string], SchedulerView[]\n> = (views, viewName, viewDisplayName) => {\n  if (!views) return [{ name: viewName, displayName: viewDisplayName }];\n  if (views.findIndex(view => viewName === view.name) === -1) {\n    const nextViews = views.slice();\n    nextViews.push({ name: viewName, displayName: viewDisplayName });\n    return nextViews;\n  }\n  return views;\n};\n\nexport const viewCellsData: ViewCellsDataFn = (\n  currentDate, firstDayOfWeek,\n  dayCount, excludedDays,\n  startDayHour, endDayHour,\n  cellDuration, currTime,\n) => {\n  const days = dayScale(currentDate, firstDayOfWeek!, dayCount!, excludedDays);\n  const times = timeScale(\n    currentDate, firstDayOfWeek!, startDayHour, endDayHour, cellDuration, excludedDays,\n  );\n  const currentTime = moment(currTime as SchedulerDateTime);\n  return times.reduce((cellsAcc, time) => {\n    const start = moment(time.start);\n    const end = moment(time.end);\n    const rowCells = days.reduce((rowAcc, day) => {\n      const startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      const endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      const today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({ startDate, endDate, today });\n      return rowAcc;\n    }, [] as ViewCell[]);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, [] as ViewCell[][]);\n};\n\nexport const timeCellsData: PureComputed<\n  [ViewCell[][], number, number, number, number], ViewCell[][]\n> = (\n  cellsData, startDayHour, endDayHour, cellDuration, currentTime,\n) => {\n  const { startDate: firstViewDate } = cellsData[0][0];\n  if (!containsDSTChange(firstViewDate)) {\n    return cellsData;\n  }\n\n  const nextDay = moment(firstViewDate)\n    .add(1, 'day')\n    .toDate();\n  const validCellsData = viewCellsData(\n    nextDay, undefined, 1, [], startDayHour, endDayHour, cellDuration, currentTime,\n  );\n\n  return validCellsData;\n};\n\nexport const allDayCells: PureComputed<\n  [ViewCell[][]], AllDayCell[][]\n> = viewCells => [viewCells[0].map(cell => ({\n  startDate: moment(cell.startDate).startOf('day').toDate(),\n  endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),\n  groupingInfo: cell.groupingInfo,\n  endOfGroup: cell.endOfGroup,\n}))];\n\nexport const startViewDate: PureComputed<\n  [ViewCell[][]], Date\n> = viewCells => moment(viewCells[0][0].startDate).toDate();\n\nexport const endViewDate: PureComputed<\n  [ViewCell[][]], Date\n> = (viewCells) => {\n  const lastRowIndex = viewCells.length - 1;\n  const lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate!);\n};\n","import { PureComputed, CustomFunction } from '@devexpress/dx-core';\nimport {\n  ViewCell, CellElementsMeta, GroupOrientation, AppointmentMoment,\n  AppointmentUnwrappedGroup, ViewMetaData, ElementRect, AppointmentGroup,\n  AppointmentForestRoots, CalculatedTreeNode, TreeNodeWithOverlappingSubTreeRoots,\n  TreeNodeInBlock, AppointmentBlock, IncludedBlock, BlockWithChildren, CalculatedBlock,\n  GroupedIntoBlocksForest, AppointmentIndex,\n\n  VisitRootsFn, CalculateRectByDateAndGroupIntervalsFn, CreateAppointmentForestFn,\n  VisitChildFn, VisitAllChildrenFn, IsPossibleChildFn, FindMaxReduceValueFn,\n  CalculateAppointmentsMetaDataFn, CalulateRootsMetaDataFn, CalculateChildMetaDataFn,\n  CalculateChildrenMetaDataFn, CalculateAppointmentLeftAndWidthFn, PrepareToGroupIntoBlocksFn,\n  IsOverlappingSubTreeRootFn, FindChildrenMaxEndDateFn, GroupAppointmentsIntoBlocksFn,\n  CalculateBlockSizeBEndDateFn, FindBlockIndexByAppointmentFn, FindIncludedBlocksFn,\n  IsIncludedBlockFn, FindChildBlocksFn, IsChildBlockFn, AdjustByBlocksFn,\n  CalculateBlockDimensionsFn, AlignBlocksWithPreviousFn, AdjustAppointemntsByBlocksFn,\n  RedistributeBlocksFn, CalculateIncludedBlockMaxRightFn, CalculateBlocksTotalSizeFn,\n  CalculateSingleBlockTotalSizeFn, CalculateBlocksLeftLimitFn, CalculateSingleBlockLeftLimitFn,\n  UpdateBlocksProportionsFn, UpdateBlocksLeftFn, CreateAndAdjustAppointmentForestFn,\n} from '../../types';\nimport { HORIZONTAL_GROUP_ORIENTATION, HORIZONTAL_TYPE, VERTICAL_TYPE } from '../../constants';\nimport { toPercentage } from '../../utils';\nimport moment from 'moment';\n\nconst MAX_WIDTH = 1;\nconst INDIRECT_CHILD_LEFT_OFFSET = 0.05;\n\nexport const isAllDayElementsMetaActual: PureComputed<\n  [ViewCell[][], CellElementsMeta, GroupOrientation, number], boolean\n> = (viewCellsData, allDayElementsMeta, groupOrientation, groupCount) => {\n  const numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;\n  return isElementsMetaActual(viewCellsData, allDayElementsMeta, numberOfRows);\n};\n\nexport const isTimeTableElementsMetaActual: PureComputed<\n  [ViewCell[][], CellElementsMeta], boolean\n> = (viewCellsData, timeTableElementsMeta) => isElementsMetaActual(\n  viewCellsData, timeTableElementsMeta, viewCellsData.length,\n);\n\nconst isElementsMetaActual: PureComputed<\n  [ViewCell[][], CellElementsMeta, number], boolean\n> = (viewCellsData, elementsMeta, numberOfRows) => {\n  if (!elementsMeta?.getCellRects) {\n    return false;\n  }\n\n  const tableSize = numberOfRows * viewCellsData[0].length;\n  return tableSize === elementsMeta.getCellRects.length;\n};\n\nconst appointmentHeightType = (appointment: AppointmentMoment, cellDuration: number) => {\n  const durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nconst horizontalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, ViewMetaData, any], ElementRect\n> = (\n  appointment,\n  viewMetaData,\n  {\n    rectByDates: getRectByAppointment,\n    multiline,\n    rectByDatesMeta: {\n      cellElementsMeta,\n      viewCellsData,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = getRectByAppointment(\n    appointment,\n    viewMetaData,\n    {\n      multiline,\n      cellElementsMeta,\n      viewCellsData,\n    },\n  );\n\n  return {\n    resources: appointment.resources,\n    top: top + ((height / appointment.reduceValue) * appointment.offset),\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE,\n    key: appointment.key,\n  };\n};\n\nconst verticalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, ViewMetaData, any], ElementRect\n> = (\n  appointment,\n  viewMetaData,\n  {\n    rectByDates: getRectByAppointment,\n    multiline,\n    rectByDatesMeta: {\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n      excludedDays,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = getRectByAppointment(\n    appointment,\n    viewMetaData,\n    {\n      multiline,\n      viewCellsData,\n      cellDuration,\n      excludedDays,\n      cellElementsMeta,\n    },\n  );\n\n  const { offset, width: relativeWidth, left: relativeLeft  } = appointment;\n  const widthMultiplier = (relativeWidth! * 5 / 3 + relativeLeft!) <= 1 ? 5 / 3 : 1;\n  let validWidth = widthMultiplier === 5 / 3\n    ? widthMultiplier * relativeWidth! : relativeWidth! + 0.02;\n  if (validWidth + relativeLeft! > 1) {\n    validWidth = 1 - relativeLeft!;\n  }\n\n  return {\n    resources: appointment.resources,\n    top,\n    height,\n    left: toPercentage(left + relativeLeft! * width, parentWidth),\n    width: toPercentage(validWidth! * width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    offset,\n    key: appointment.key,\n  };\n};\n\nconst oldVerticalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, ViewMetaData, any], ElementRect\n> = (\n  appointment,\n  viewMetaData,\n  {\n    rectByDates: getRectByAppointment,\n    multiline,\n    rectByDatesMeta: {\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n      excludedDays,\n      placeAppointmentsNextToEachOther,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = getRectByAppointment(\n    appointment,\n    viewMetaData,\n    {\n      multiline,\n      viewCellsData,\n      cellDuration,\n      excludedDays,\n      cellElementsMeta,\n      placeAppointmentsNextToEachOther,\n    },\n  );\n\n  const widthInPx = width / appointment.reduceValue;\n\n  return {\n    resources: appointment.resources,\n    top,\n    height,\n    left: toPercentage(left + (widthInPx * appointment.offset), parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    key: appointment.key,\n  };\n};\n\nconst compareByDay: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nconst compareByAllDay: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nconst compareByTime: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nexport const sortAppointments: PureComputed<\n  [AppointmentMoment[]], AppointmentMoment[]\n> = appointments => appointments\n  .slice().sort((a, b) => compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b));\n\nconst byDayPredicate: PureComputed<\n  [moment.Moment, moment.Moment], boolean\n> = (boundary, date) => (\n  boundary.isSameOrAfter(date, 'day')\n  && !boundary.isSame(boundary.clone().startOf('day'))\n);\n\nexport const findOverlappedAppointments: CustomFunction<\n  [AppointmentMoment[], boolean], any[]\n> = (sortedAppointments, byDay = false) => {\n  const appointments = sortedAppointments.slice();\n  const groups: AppointmentMoment[][] = [];\n  let totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    const current = appointments[totalIndex];\n    const currentGroup = groups[groups.length - 1];\n    let next = appointments[totalIndex + 1];\n    let maxBoundary = current.end;\n\n    currentGroup.push(current);\n    totalIndex += 1;\n    while (next && (maxBoundary.isAfter(next.start)\n      || (byDay && byDayPredicate(maxBoundary, next.start)))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n  return groups;\n};\n\nconst isMidnight: PureComputed<\n  [moment.Moment], boolean\n> = date => date.isSame(date.clone().startOf('day'));\n\nconst maxBoundaryPredicate: PureComputed<\n  [moment.Moment, Date], boolean\n> = (maxBoundary, startDate) => ((maxBoundary.isBefore(startDate as Date, 'day'))\n  || (isMidnight(maxBoundary) && maxBoundary.isSame(startDate as Date, 'day')));\n\nexport const calculateAppointmentOffsets: CustomFunction<\n  [any[], boolean], AppointmentGroup[]\n> = (groups, byDay = false) => groups.map((items) => {\n  let offset = 0;\n  let reduceValue = 1;\n  const appointments = items.map((appointment: any) => ({ ...appointment }));\n  const groupLength = appointments.length;\n  for (let startIndex = 0; startIndex < groupLength; startIndex += 1) {\n    const appointment = appointments[startIndex];\n    if (appointment.offset === undefined) {\n      let maxBoundary = appointment.end;\n      appointment.offset = offset;\n      for (let index = startIndex + 1; index < groupLength; index += 1) {\n        if (appointments[index].offset === undefined) {\n          if ((!byDay && maxBoundary.isSameOrBefore(appointments[index].start))\n            || (byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start))) {\n            maxBoundary = appointments[index].end;\n            appointments[index].offset = offset;\n          }\n        }\n      }\n\n      offset += 1;\n      if (reduceValue < offset) reduceValue = offset;\n    }\n  }\n  return { items: appointments, reduceValue };\n});\n\nconst unwrapAppointmentForest: PureComputed<\n  [GroupedIntoBlocksForest[]], AppointmentUnwrappedGroup[]\n> = (appointmentForests) => {\n  const forestUnwrapped = appointmentForests.map(({ items, reduceValue }) => ({\n    reduceValue,\n    items: items.map(({ data }) => ({ ...data })),\n  }));\n  return unwrapGroups(forestUnwrapped);\n};\n\nexport const unwrapGroups: PureComputed<\n  [AppointmentGroup[]], AppointmentUnwrappedGroup[]\n> = groups => groups.reduce((acc, { items, reduceValue }) => {\n  acc.push(...items.map(({ start, end, dataItem, offset, resources, key, ...restProps }) => ({\n    start, end, dataItem, offset, reduceValue, resources,\n    fromPrev: moment(start).diff(dataItem.startDate, 'minutes') > 1,\n    toNext: moment(dataItem.endDate).diff(end, 'minutes') > 1,\n    key,\n    ...restProps,\n  })));\n  return acc;\n}, [] as AppointmentUnwrappedGroup[]);\n\nexport const intervalIncludes: PureComputed<\n  [moment.Moment, moment.Moment, moment.Moment], boolean\n> = (intervalStart, intervalEnd, date) => date\n  .isBetween(intervalStart, intervalEnd, undefined, '[)');\n\nexport const createAppointmentForest: CreateAppointmentForestFn = (\n  appointmentGroups, cellDuration,\n) => appointmentGroups.map((appointmentGroup) => {\n  const { items } = appointmentGroup;\n  let nextItems;\n  let roots;\n  if (items.length === 1) {\n    nextItems = [{\n      data: items[0], children: [], treeDepth: 0, isDirectChild: false, hasDirectChild: false,\n    }];\n    roots = [0];\n  } else {\n    const {\n      appointments, roots: appointmentTreeRoots,\n    } = visitRoots(items, cellDuration) as AppointmentForestRoots;\n    nextItems = appointments;\n    roots = appointmentTreeRoots;\n  }\n  return {\n    ...appointmentGroup,\n    items: nextItems,\n    roots,\n  };\n});\n\nconst visitRoots: VisitRootsFn = (appointmentItems, cellDuration) => {\n  const appointmentNodes: any[] = appointmentItems.map(props => ({\n    data: props,\n  }));\n\n  const roots = appointmentNodes.reduce((acc, appointment, appointmentIndex) => {\n    const { offset: appointmentOffset } = appointment.data;\n\n    if (appointmentOffset === 0) {\n      if (appointmentIndex + 1 === appointmentNodes.length) {\n        appointment.children = [];\n        appointment.hasDirectChild = false;\n        appointment.treeDepth = 0;\n      } else {\n        appointment.treeDepth = visitAllChildren(\n          appointmentNodes, appointmentIndex, cellDuration, 0,\n        );\n      }\n\n      appointment.parent = undefined;\n      appointment.isDirectChild = false;\n      return [...acc, appointmentIndex];\n    }\n    return acc;\n  }, []);\n  return { appointments: appointmentNodes, roots };\n};\n\nconst visitChild: VisitChildFn = (\n  appointmentNodes, index, parentAppointmentIndex, cellDuration, isDirectChild, treeDepth,\n) => {\n  const appointmentNode = appointmentNodes[index];\n  appointmentNode.isDirectChild = isDirectChild;\n  appointmentNode.parent = parentAppointmentIndex;\n  const nextTreeDepth = treeDepth + 1;\n  const { end } = appointmentNode.data;\n\n  if (index === appointmentNodes.length - 1\n    || end.isSameOrBefore(appointmentNodes[index + 1].data.start)) {\n    appointmentNode.children = [];\n    appointmentNode.treeDepth = 0;\n    appointmentNode.hasDirectChild = false;\n    return nextTreeDepth;\n  }\n\n  const calculatedTreeDepth = visitAllChildren(\n    appointmentNodes, index, cellDuration, treeDepth,\n  );\n\n  appointmentNode.treeDepth = calculatedTreeDepth;\n  return calculatedTreeDepth + 1;\n};\n\nconst visitAllChildren: VisitAllChildrenFn = (\n  appointmentNodes, appointmentIndex, cellDuration, treeDepth,\n) => {\n  const appointment = appointmentNodes[appointmentIndex];\n  const { end, offset: appointmentOffset, start } = appointment.data;\n  const directChildTimeLimit = moment(start).add(cellDuration, 'minutes');\n  let maxAppointmentTreeDepth = 0;\n  const children = [] as AppointmentIndex[];\n\n  let nextChildIndex = appointmentIndex + 1;\n  while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n    const nextAppointment = appointmentNodes[nextChildIndex];\n    const { offset: nextOffset, start: nextStart } = nextAppointment.data;\n\n    if (nextOffset === appointmentOffset + 1) {\n      const isDirectChild = intervalIncludes(start, directChildTimeLimit, nextStart);\n      const nextTreeDepth = visitChild(\n        appointmentNodes, nextChildIndex, appointmentIndex, cellDuration, isDirectChild, treeDepth,\n      );\n\n      if (maxAppointmentTreeDepth < nextTreeDepth) {\n        maxAppointmentTreeDepth = nextTreeDepth;\n      }\n      children.push(nextChildIndex);\n    }\n    nextChildIndex += 1;\n  }\n  appointment.hasDirectChild = children.length !== 0 && appointmentNodes[children[0]].isDirectChild;\n  appointment.children = children;\n\n  return maxAppointmentTreeDepth;\n};\n\nexport const isPossibleChild: IsPossibleChildFn = (\n  appointments, possibleChildIndex, parentEnd, parentOffset,\n) => {\n  const possibleChild = appointments[possibleChildIndex];\n  return (\n    possibleChildIndex < appointments.length\n    && possibleChild.data.offset !== parentOffset\n    && possibleChild.data.start.isBefore(parentEnd)\n  );\n};\n\nexport const findMaxReduceValue: FindMaxReduceValueFn =\n  appointmentGroups => appointmentGroups.reduce((maxReduceValue, group) => {\n    const currentReduceValue = group.reduceValue;\n    return maxReduceValue > currentReduceValue ? maxReduceValue : currentReduceValue;\n  }, 1);\n\nexport const calculateAppointmentsMetaData: CalculateAppointmentsMetaDataFn = (\n  appointmentGroups, indirectChildLeftOffset,\n) => appointmentGroups.map((appointmentForest) => {\n  const { items, roots } = appointmentForest;\n  const firstNode = items[0];\n  return {\n    ...appointmentForest,\n    items: items.length === 1\n      ? [{\n        ...firstNode,\n        data: {\n          ...firstNode.data,\n          left: 0,\n          width: 1,\n        },\n      }]\n      : calculateRootsMetaData(items, roots, indirectChildLeftOffset) as CalculatedTreeNode[],\n  };\n});\n\nconst calculateRootsMetaData: CalulateRootsMetaDataFn = (\n  appointmentNodes, roots, indirectChildLeftOffset,\n) => {\n  const appointments = appointmentNodes.map(props => ({ ...props })) as CalculatedTreeNode[];\n\n  roots.forEach((appointmentIndex) => {\n    const appointment = appointments[appointmentIndex];\n    const { left, width } = calculateAppointmentLeftAndWidth(\n      appointments, undefined, appointment, MAX_WIDTH, indirectChildLeftOffset, undefined,\n    );\n    appointment.data.left = left;\n    appointment.data.width = width;\n    calculateChildrenMetaData(appointments, appointment, MAX_WIDTH, indirectChildLeftOffset);\n  });\n  return appointments;\n};\n\nconst calculateChildMetaData: CalculateChildMetaDataFn = (\n  appointmentNodes, appointmentIndex, maxWidth, indirectChildLeftOffset,\n) => {\n  const appointment = appointmentNodes[appointmentIndex];\n  const { left, width } = calculateAppointmentLeftAndWidth(\n    appointmentNodes, undefined, appointment, maxWidth, indirectChildLeftOffset, undefined,\n  );\n  appointment.data.left = left;\n  appointment.data.width = width;\n\n  calculateChildrenMetaData(\n    appointmentNodes, appointment, maxWidth, indirectChildLeftOffset,\n  );\n};\n\nconst calculateChildrenMetaData: CalculateChildrenMetaDataFn = (\n  appointmentNodes, appointmentNode, maxWidth, indirectChildLeftOffset,\n) => {\n  appointmentNode.children.forEach((childIndex) => {\n    calculateChildMetaData(appointmentNodes, childIndex, maxWidth, indirectChildLeftOffset);\n  });\n};\n\nexport const calculateAppointmentLeftAndWidth: CalculateAppointmentLeftAndWidthFn = (\n  appointmentNodes, blocks, appointmentNode, maxRight, indirectChildLeftOffset, defaultLeft,\n) => {\n  const {\n    hasDirectChild, treeDepth, isDirectChild, parent: parentIndex, children, blockIndex,\n  } = appointmentNode as TreeNodeInBlock;\n  const firstChild = appointmentNodes[children[0]];\n  const firstChildBlockIndex = (firstChild as TreeNodeInBlock)?.blockIndex;\n\n  const hasDirectChildAndInSameBlock = hasDirectChild\n    && (firstChildBlockIndex === undefined || (blockIndex === firstChildBlockIndex\n      || blocks![firstChildBlockIndex].includedInto === blockIndex\n      || maxRight === 1));\n\n  if (parentIndex === undefined) {\n    return ({\n      width: hasDirectChildAndInSameBlock ? maxRight / (treeDepth + 1) : maxRight,\n      left: 0,\n    });\n  }\n\n  const parent = appointmentNodes[parentIndex];\n  const {\n    width: parentWidth,\n    left: parentLeft,\n  } = parent.data;\n  const calculatedLeft = isDirectChild\n    ? parentLeft + parentWidth : parentLeft + indirectChildLeftOffset;\n  const left = defaultLeft !== undefined ? Math.max(defaultLeft, calculatedLeft) : calculatedLeft;\n  const unoccupiedSpace = maxRight - left;\n\n  return ({\n    width: hasDirectChildAndInSameBlock ? unoccupiedSpace / (treeDepth + 1) : unoccupiedSpace,\n    left,\n  });\n};\n\nexport const prepareToGroupIntoBlocks: PrepareToGroupIntoBlocksFn =\n  appointments => appointments.map((appointmentForest) => {\n    const { items: nodes } = appointmentForest;\n    const appointmentNodes = nodes.map(props => ({\n      ...props,\n    })) as TreeNodeWithOverlappingSubTreeRoots[];\n\n    appointmentNodes.forEach((appointmentNode, index) => {\n      if (index === 0) {\n        appointmentNode.overlappingSubTreeRoots = [];\n        return;\n      }\n      const overlappingSubTreeRoots = [] as any[];\n      const { offset: appointmentOffset, end } = appointmentNode.data;\n\n      let nextChildIndex = index + 1;\n      let currentBlockEnd;\n      while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n        const nextAppointment = appointmentNodes[nextChildIndex];\n        if (nextAppointment.data.offset < appointmentOffset\n          && nextAppointment.maxOffset === undefined) {\n          nextAppointment.maxOffset = appointmentOffset;\n        }\n\n        const previousSubTreeRoot = overlappingSubTreeRoots.length > 0\n          ? appointmentNodes[overlappingSubTreeRoots[overlappingSubTreeRoots.length - 1]]\n          : undefined;\n        if (isOverlappingSubTreeRoot(\n          appointmentNode, nextAppointment, previousSubTreeRoot, currentBlockEnd,\n        )) {\n          overlappingSubTreeRoots.push(nextChildIndex);\n          nextAppointment.overlappingSubTreeRoot = true;\n          const maxChildDate = findChildrenMaxEndDate(appointmentNodes, nextAppointment);\n          if (!currentBlockEnd || currentBlockEnd.isBefore(maxChildDate)) {\n            currentBlockEnd = maxChildDate;\n          }\n        }\n        nextChildIndex += 1;\n      }\n      appointmentNode.overlappingSubTreeRoots = overlappingSubTreeRoots;\n    });\n    return {\n      ...appointmentForest,\n      items: appointmentNodes,\n    };\n  });\n\nexport const isOverlappingSubTreeRoot: IsOverlappingSubTreeRootFn = (\n  appointmentNode, nextAppointment, previousSubTreeRoot, previousEndDate,\n) => {\n  const {\n    overlappingSubTreeRoot, maxOffset, data: nextData,\n  } = nextAppointment;\n  const { offset: nextOffset, start: nextStart } = nextData;\n  const { offset } = appointmentNode.data;\n\n  return (\n    nextOffset < offset\n      && !overlappingSubTreeRoot\n      && (maxOffset === undefined || maxOffset >= offset)\n      && (!previousSubTreeRoot\n        || (previousSubTreeRoot.data.offset >= nextOffset\n        && nextStart.isSameOrAfter(previousEndDate)))\n  );\n};\n\nexport const findChildrenMaxEndDate: FindChildrenMaxEndDateFn = (\n  appointmentNodes, appointmentNode,\n) => {\n  const { children, data } = appointmentNode;\n  const { end } = data;\n\n  const maxDate = children.reduce((currentMaxDate, childIndex) => {\n    const child = appointmentNodes[childIndex];\n    const maxChildrenDate = findChildrenMaxEndDate(appointmentNodes, child);\n    if (maxChildrenDate.isAfter(currentMaxDate)) {\n      return maxChildrenDate;\n    }\n    return currentMaxDate;\n  }, end);\n  return maxDate;\n};\n\nexport const groupAppointmentsIntoBlocks: GroupAppointmentsIntoBlocksFn =\n  appointmentForests => appointmentForests.map((appointmentForest) => {\n    const { items, reduceValue } = appointmentForest;\n    const { blocks: nextBlocks, appointments } = items.reduce((acc, appointment, index) => {\n      const blocks = acc.blocks.slice();\n      const {\n        treeDepth, data, overlappingSubTreeRoots, overlappingSubTreeRoot,\n      } = appointment;\n      const { offset, start, end } = data;\n\n      if (overlappingSubTreeRoots.length !== 0) {\n        if (!overlappingSubTreeRoot) {\n          blocks.push({\n            start, end, minOffset: offset, maxOffset: offset + treeDepth,\n            size: treeDepth + 1, items: [], endForChildren: end,\n          });\n        }\n        overlappingSubTreeRoots.forEach((subTreeRootIndex) => {\n          const subTreeRoot = items[subTreeRootIndex];\n          const { data: subTreeRootData } = subTreeRoot;\n          blocks.push({\n            start: subTreeRootData.start, end,\n            minOffset: subTreeRootData.offset, maxOffset: offset - 1,\n            size: calculateBlockSizeByEndDate(items, subTreeRoot, end), items: [],\n            endForChildren: subTreeRootData.end,\n          });\n        });\n      }\n\n      const blockIndex = findBlockIndexByAppointment(blocks, appointment);\n      blocks[blockIndex].items.push(index);\n      const appointmentInBlock = { ...appointment, blockIndex };\n\n      return {\n        blocks,\n        appointments: [...acc.appointments, appointmentInBlock],\n      };\n    }, {\n      blocks: [{\n        start: items[0].data.start,\n        end: items[0].data.end,\n        minOffset: 0,\n        maxOffset: reduceValue - 1,\n        size: reduceValue,\n        items: [],\n        endForChildren: items[0].data.end,\n      }] as AppointmentBlock[],\n      appointments: [] as TreeNodeInBlock[],\n    });\n    return {\n      blocks: nextBlocks,\n      appointmentForest: {\n        ...appointmentForest,\n        items: appointments,\n      },\n    };\n  });\n\nconst calculateBlockSizeByEndDate: CalculateBlockSizeBEndDateFn = (\n  appointmentNodes, subTreeRoot, blockEndDate,\n) => {\n  const { children, data } = subTreeRoot;\n  const { start } = data;\n\n  if (children.length === 0) {\n    if (blockEndDate.isAfter(start)) {\n      return 1;\n    }\n    return 0;\n  }\n  const maxSize = Math.max(\n    ...children.map(childIndex => calculateBlockSizeByEndDate(\n      appointmentNodes, appointmentNodes[childIndex], blockEndDate),\n    ),\n  );\n\n  if (blockEndDate.isSameOrBefore(start) && maxSize === 0) {\n    return 0;\n  }\n  return maxSize + 1;\n};\n\nexport const findBlockIndexByAppointment: FindBlockIndexByAppointmentFn = (\n  blocks, appointment,\n) => {\n  const { start, offset } = appointment.data;\n\n  let blockIndex = blocks.length - 1;\n  while (blockIndex > 0) {\n    const currentBlock = blocks[blockIndex];\n    if (intervalIncludes(currentBlock.start, currentBlock.end, start)\n      && offset >= currentBlock.minOffset && offset <= currentBlock.maxOffset\n    ) {\n      break;\n    }\n    blockIndex -= 1;\n  }\n\n  return blockIndex;\n};\n\nexport const findIncludedBlocks: FindIncludedBlocksFn = (groupedIntoBlocks) => {\n  return groupedIntoBlocks.map(({ blocks, appointmentForest }) => {\n    const nextBlocks = blocks.map(props => ({ ...props })) as IncludedBlock[];\n\n    nextBlocks.forEach((block, blockIndex) => {\n      block.includedBlocks = [];\n      for (\n        let currentBlockIndex = blockIndex + 1;\n        currentBlockIndex < nextBlocks.length;\n        currentBlockIndex += 1\n      ) {\n        const currentBlock = nextBlocks[currentBlockIndex];\n        if (isIncludedBlock(block, currentBlock)) {\n          block.includedBlocks.push(currentBlockIndex);\n          currentBlock.includedInto = blockIndex;\n        }\n      }\n    });\n    return {\n      blocks: nextBlocks, appointmentForest,\n    };\n  });\n};\n\nconst isIncludedBlock: IsIncludedBlockFn = (block, possibleIncludedBlock) => {\n  const { start, end, minOffset, maxOffset } = block;\n  const {\n    start: possibleIncludedStart, end: possibleIncludedEnd,\n    minOffset: possibleMinOffset, maxOffset: possibleMaxOffset,\n  } = possibleIncludedBlock;\n  return intervalIncludes(start, end, possibleIncludedStart)\n    && intervalIncludes(start, end, possibleIncludedEnd)\n    && possibleMaxOffset <= maxOffset && possibleMinOffset >= minOffset;\n};\n\nexport const findChildBlocks: FindChildBlocksFn = (groupedIntoBlocks) => {\n  return groupedIntoBlocks.map(({ blocks, appointmentForest }) => {\n    const nextBlocks = blocks.map(props => ({ ...props })) as BlockWithChildren[];\n\n    nextBlocks.forEach((block, index) => {\n      block.children = [];\n      for (let currentIndex = index + 1; currentIndex < nextBlocks.length; currentIndex += 1) {\n        const nextBlock = nextBlocks[currentIndex];\n\n        if (isChildBlock(block, nextBlock)) {\n          block.children.push(currentIndex);\n          nextBlock.parent = index;\n        }\n      }\n      return block;\n    });\n    return {\n      appointmentForest, blocks: nextBlocks,\n    };\n  });\n};\n\nconst isChildBlock: IsChildBlockFn = (block, possibleChildBlock) => {\n  const { start, endForChildren, minOffset, includedInto } = block;\n  const {\n    start: childStart, includedInto: childIncludedInto, maxOffset: childMaxOffset,\n  } = possibleChildBlock;\n  return intervalIncludes(start, endForChildren, childStart)\n    && childMaxOffset + 1 === minOffset\n    && (\n      childIncludedInto === undefined\n      || childIncludedInto === includedInto\n    );\n};\n\nexport const adjustByBlocks: AdjustByBlocksFn = (\n  groupedIntoBlocks, indirectChildLeftOffset,\n) => {\n  const updatedBlocks = groupedIntoBlocks.map(({ blocks, appointmentForest }) => {\n    const dimensionsCalculated = calculateBlocksDimensions(blocks, appointmentForest.items);\n\n    return {\n      blocks: alignBlocksWithPrevious(dimensionsCalculated, appointmentForest.items),\n      appointmentForest,\n    };\n  });\n  const adjustedByBlocks = updatedBlocks.map(({ blocks, appointmentForest }) => {\n    return {\n      ...appointmentForest,\n      items: adjustAppointmentsByBlocks(\n        appointmentForest.items, blocks, indirectChildLeftOffset,\n        ) as TreeNodeInBlock[],\n    };\n  });\n  return adjustedByBlocks;\n};\n\nconst calculateBlocksDimensions: CalculateBlockDimensionsFn = (\n  blocks, appointments,\n) => updateBlocksProportions(calculateBlocksLeftLimit(\n  calculateBlocksTotalSize(blocks), appointments,\n));\n\nconst alignBlocksWithPrevious: AlignBlocksWithPreviousFn = (blocks, appointments) => {\n  const nextBlocks = blocks.map(({ right, ...restProps }) => ({ ...restProps }));\n\n  const leftLimitCalculated = calculateBlocksLeftLimit(\n    updateBlocksLeft(nextBlocks as CalculatedBlock[], appointments), appointments,\n  );\n  return updateBlocksProportions(leftLimitCalculated);\n};\n\nconst adjustAppointmentsByBlocks: AdjustAppointemntsByBlocksFn = (\n  appointments, blocks, indirectChildLeftOffset,\n) => {\n  const nextAppointments = appointments.map(props => ({ ...props }));\n  const nextBlocks = blocks.map(props => ({ ...props }));\n\n  nextBlocks.forEach((block, index) => {\n    if (index !== 0) {\n      const { items, left: blockLeft, right, children } = block;\n      const maxRight = calculateIncludedBlockMaxRight(nextBlocks, block);\n      const finalMaxRight = maxRight * right;\n      const defaultLeft = blockLeft! * maxRight;\n\n      items.forEach((appointmentIndex, itemIndex) => {\n        const appointment = nextAppointments[appointmentIndex];\n        if (itemIndex === 0) {\n          const { left, width } = calculateAppointmentLeftAndWidth(\n            nextAppointments, nextBlocks, appointment,\n            finalMaxRight, indirectChildLeftOffset, defaultLeft,\n          );\n          appointment.data.left = left;\n          appointment.data.width = width;\n          if (defaultLeft !== left) {\n            children.forEach((childIndex) => {\n              redistributeChildBlocks(nextBlocks, childIndex, left / maxRight);\n            });\n          }\n        } else {\n          const {\n            left, width,\n          } = calculateAppointmentLeftAndWidth(\n            nextAppointments, nextBlocks, appointment,\n            finalMaxRight, indirectChildLeftOffset, undefined,\n          );\n          appointment.data.left = left;\n          appointment.data.width = width;\n        }\n      });\n    }\n  });\n  blocks[0].items.forEach((appointmentIndex) => {\n    const appointment = nextAppointments[appointmentIndex];\n    const {\n      left, width,\n    } = calculateAppointmentLeftAndWidth(\n      nextAppointments, blocks, appointment, 1, indirectChildLeftOffset, undefined,\n    );\n    appointment.data.left = left;\n    appointment.data.width = width;\n  });\n  return nextAppointments;\n};\n\nconst redistributeChildBlocks: RedistributeBlocksFn = (blocks, blockIndex, right) => {\n  const block = blocks[blockIndex];\n  const { leftOffset, size, leftLimit, children } = block;\n  block.right = right;\n  const width = size + leftOffset;\n  const relativeWidth = right - leftLimit;\n  const left = right - relativeWidth * size / width;\n  block.left = left;\n  children.forEach((childIndex) => {\n    redistributeChildBlocks(blocks, childIndex, left);\n  });\n};\n\nexport const calculateIncludedBlockMaxRight: CalculateIncludedBlockMaxRightFn = (\n  blocks, includedBlock,\n) => {\n  const { includedInto: includedIntoIndex } = includedBlock;\n  if (includedIntoIndex === undefined) {\n    return 1;\n  }\n\n  const includedInto = blocks[includedIntoIndex];\n  const currentMaxRight = includedInto.right;\n  return currentMaxRight * calculateIncludedBlockMaxRight(blocks, includedInto);\n\n};\n\nexport const calculateBlocksTotalSize: CalculateBlocksTotalSizeFn = (blocks) => {\n  const result = blocks.map((block) => {\n    const totalSize = calculateSingleBlockTotalSize(blocks, block);\n    return {\n      ...block,\n      totalSize,\n      leftOffset: totalSize - block.size,\n    };\n  });\n  return result;\n};\n\nconst calculateSingleBlockTotalSize: CalculateSingleBlockTotalSizeFn = (\n  blocks, block,\n) => {\n  const { children, size } = block;\n  if (children.length === 0) {\n    return size;\n  }\n  return Math.max(\n    ...children.map(childIndex => calculateSingleBlockTotalSize(blocks, blocks[childIndex])),\n  ) + size;\n};\n\nexport const calculateBlocksLeftLimit: CalculateBlocksLeftLimitFn = (\n  blocks, appointments,\n) => (blocks as CalculatedBlock[]).map((block) => {\n  const leftLimit = calculateSingleBlockLeftLimit(blocks, appointments, block);\n  return {\n    ...block,\n    leftLimit,\n  };\n});\n\nconst calculateSingleBlockLeftLimit: CalculateSingleBlockLeftLimitFn = (\n  blocks, appointments, block,\n) => {\n  const { children, items, left } = block as CalculatedBlock;\n  if (children.length === 0) {\n    return left !== undefined\n      ? Math.min(left, appointments[items[0]].data.left)\n      : appointments[items[0]].data.left;\n  }\n  return Math.min(\n    ...children.map(childIndex => calculateSingleBlockLeftLimit(\n      blocks, appointments, blocks[childIndex],\n    )),\n  );\n};\n\nexport const updateBlocksProportions: UpdateBlocksProportionsFn = (blocks) => {\n  const nextBlocks = (blocks as CalculatedBlock[]).map(props => ({ ...props }));\n\n  nextBlocks.forEach((block) => {\n    const { parent: parentIndex, leftLimit, leftOffset, totalSize } = block;\n    if (parentIndex === undefined) {\n      block.right = 1;\n      block.left = (1 - leftLimit) * leftOffset / totalSize + leftLimit;\n      return;\n    }\n\n    const parent = nextBlocks[parentIndex];\n    const { left: parentLeft, totalSize: parentTotalSize } = parent as CalculatedBlock;\n    block.totalSize = parentTotalSize;\n    block.right = parentLeft as number;\n    block.left = (1 - leftLimit) * leftOffset / parentTotalSize + leftLimit;\n  });\n\n  return nextBlocks;\n};\n\nexport const updateBlocksLeft: UpdateBlocksLeftFn = (\n  blocks, appointments,\n) => blocks.map((block) => {\n  const { items, left } = block;\n  const firstItem = appointments[items[0]];\n  const { parent: firstItemParentIndex } = firstItem;\n  if (firstItemParentIndex === undefined) {\n    return block;\n  }\n\n  const firstItemParent = appointments[firstItemParentIndex];\n  const parentBlock = blocks[firstItemParent.blockIndex];\n\n  return {\n    ...block,\n    left: parentBlock.parent === undefined ? left : blocks[parentBlock.parent].left,\n  };\n});\n\nconst createAndAdjustAppointmentForest: CreateAndAdjustAppointmentForestFn = (\n  appointmentGroups, cellDuration,\n) => {\n  const appointmentForest = createAppointmentForest(appointmentGroups, cellDuration);\n  const indirectChildLeftOffset = Math.min(\n    1 / findMaxReduceValue(appointmentForest),\n    INDIRECT_CHILD_LEFT_OFFSET,\n  );\n  const baseCalculated = calculateAppointmentsMetaData(\n    appointmentForest, indirectChildLeftOffset,\n  );\n\n  const preparedToGroupIntoBlocks = prepareToGroupIntoBlocks(baseCalculated);\n  const groupedIntoBlocks = groupAppointmentsIntoBlocks(preparedToGroupIntoBlocks);\n  const blocksWithIncluded = findIncludedBlocks(groupedIntoBlocks);\n  const blocksWithParents = findChildBlocks(blocksWithIncluded);\n  return adjustByBlocks(blocksWithParents, indirectChildLeftOffset);\n};\n\nexport const calculateRectByDateAndGroupIntervals: CalculateRectByDateAndGroupIntervalsFn = (\n  type, intervals, rectByDates, rectByDatesMeta, viewMetaData,\n) => {\n  const { growDirection, multiline } = type;\n  const isHorizontal = growDirection === HORIZONTAL_TYPE;\n\n  const sorted = intervals.map(sortAppointments);\n  const grouped = sorted.reduce(((acc, sortedGroup) => [\n    ...acc,\n    ...findOverlappedAppointments(sortedGroup as AppointmentMoment[], isHorizontal),\n  ]), [] as AppointmentMoment[]);\n\n  const { cellDuration, placeAppointmentsNextToEachOther } = rectByDatesMeta;\n  const rectCalculator = isHorizontal\n    ? horizontalRectCalculator\n    : placeAppointmentsNextToEachOther ? oldVerticalRectCalculator : verticalRectCalculator;\n\n  const groupsCalculated = calculateAppointmentOffsets(\n    grouped as any[], isHorizontal,\n  );\n  const isAppointmentForestNeeded = !isHorizontal && !placeAppointmentsNextToEachOther;\n  let appointmentForest: GroupedIntoBlocksForest[];\n\n  if (isAppointmentForestNeeded) {\n    appointmentForest = createAndAdjustAppointmentForest(\n      groupsCalculated as AppointmentGroup[], cellDuration,\n    ) as GroupedIntoBlocksForest[];\n  }\n\n  const unwrappedAppointments = isAppointmentForestNeeded\n    ? unwrapAppointmentForest(appointmentForest!)\n    : unwrapGroups(groupsCalculated);\n  const rects = unwrappedAppointments.map(appointment => rectCalculator(\n    appointment, viewMetaData,\n    { rectByDates, multiline, rectByDatesMeta },\n  ));\n  return rects.sort((first, second) => first.offset! >= second.offset! ? 1 : -1);\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  AppointmentMoment, DayBoundaryPredicateFn,\n  ReduceAppointmentByDayBoundsFn, NormalizeAppointmentDurationFn, ViewCell, SchedulerDateTime,\n} from '../../types';\nimport { checkCellGroupingInfo } from '../common/helpers';\nimport { addDateToKey } from '../../utils';\n\nexport const sliceAppointmentByDay: PureComputed<\n  [AppointmentMoment, number], AppointmentMoment[]\n> = (appointment, cellDuration) => {\n  const { start, end, dataItem, key } = appointment;\n  if (start.isSame(end, 'day')) return [appointment];\n\n  const minDuration = cellDuration / 2;\n  const isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  const isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n  const firstAppointmentKey = addDateToKey(key, start);\n  const secondAppointmentKey = addDateToKey(key, end);\n\n  return [\n    isShortOnFirstDay ? {\n      start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n      end: start.clone().endOf('day'),\n      dataItem,\n      key: firstAppointmentKey,\n    } : {\n      start, end: start.clone().endOf('day'), dataItem,\n      key: firstAppointmentKey,\n    },\n    isShortOnSecondDay ? {\n      start: end.clone().startOf('day'),\n      end: end.clone().startOf('day').add(minDuration, 'minutes'),\n      dataItem,\n      key: secondAppointmentKey,\n    } : {\n      start: end.clone().startOf('day'), end, dataItem,\n      key: secondAppointmentKey,\n    },\n  ];\n};\n\nexport const dayBoundaryPredicate: DayBoundaryPredicateFn = (\n  appointment,\n  leftBound, rightBound,\n  excludedDays = [],\n) => {\n  const dayStart = moment(leftBound as Date);\n  const dayEnd = moment(rightBound as Date);\n  const startDayTime = moment(appointment.start)\n    .hour(dayStart.hour())\n    .minutes(dayStart.minutes());\n  const endDayTime = moment(appointment.start)\n    .hour(dayEnd.hour())\n    .minutes(dayEnd.minutes());\n\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(day => day === moment(appointment.start).day()) !== -1) return false;\n  return (appointment.end.isAfter(startDayTime)\n    && appointment.start.isBefore(endDayTime));\n};\n\nexport const reduceAppointmentByDayBounds: ReduceAppointmentByDayBoundsFn = (\n  appointment, leftBound, rightBound, cellDuration,\n) => {\n  const dayStart = moment(leftBound as Date);\n  const dayEnd = moment(rightBound as Date);\n  const startDayTime = moment(appointment.start)\n    .hour(dayStart.hour())\n    .minutes(dayStart.minutes())\n    .seconds(dayStart.seconds());\n  const endDayTime = moment(appointment.start)\n    .hour(dayEnd.hour())\n    .minutes(dayEnd.minutes())\n    .seconds(dayEnd.seconds());\n\n  const minDuration = cellDuration / 2;\n  const isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  const isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return {\n      ...appointment, start: endDayTime.clone().add(-minDuration, 'minutes'), end: endDayTime,\n    };\n  }\n\n  if (isShortOnSecondDay) {\n    return {\n      ...appointment, start: startDayTime, end: startDayTime.clone().add(minDuration, 'minutes'),\n    };\n  }\n\n  return {\n    ...appointment,\n    ...(appointment.start.isSameOrBefore(startDayTime) ? { start: startDayTime } : null),\n    ...(appointment.end.isSameOrAfter(endDayTime) ? { end: endDayTime } : null),\n  };\n};\n\nexport const normalizeAppointmentDuration: NormalizeAppointmentDurationFn = (\n  appointment, cellDuration,\n) => {\n  const minDuration = cellDuration / 2;\n  const start = moment(appointment.start as Date);\n  const end = moment(appointment.end as Date);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return { ...appointment, start, end };\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return { ...appointment, start, end: start.clone().add(minDuration, 'minutes') };\n  }\n\n  return {\n    ...appointment,\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n  };\n};\n\nexport const getWeekVerticallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], SchedulerDateTime], number\n> = (viewCellsData, date) =>  viewCellsData[0].findIndex((\n  timeCell: ViewCell,\n) => moment(date as SchedulerDateTime).isSame(timeCell.startDate, 'date'));\n\nexport const getWeekHorizontallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, SchedulerDateTime], number\n> = (viewCellsData, appointment, date) => viewCellsData[0].findIndex((timeCell: ViewCell) => {\n  const isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);\n  return moment(date as SchedulerDateTime).isSame(timeCell.startDate, 'date') && isCorrectGroup;\n});\n\nexport const getWeekVerticallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, SchedulerDateTime, number, boolean, number], number\n> = (viewCellsData, appointment, date, columnIndex, takePrev, groupCount) => {\n  const timeTableHeight = viewCellsData.length / groupCount;\n  let timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(\n    viewCellsData, date, columnIndex, takePrev,\n  );\n\n  if (!viewCellsData[0][0].groupingInfo) return timeTableRowIndex;\n\n  let isWrongCell = !checkCellGroupingInfo(\n    viewCellsData[timeTableRowIndex][columnIndex], appointment,\n  );\n  while (isWrongCell) {\n    timeTableRowIndex += timeTableHeight;\n    isWrongCell = !checkCellGroupingInfo(\n      viewCellsData[timeTableRowIndex][columnIndex], appointment,\n    );\n  }\n  return timeTableRowIndex;\n};\n\nexport const getWeekHorizontallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], SchedulerDateTime, number, boolean], number\n> = (viewCellsData, date, columnIndex, takePrev) => viewCellsData.findIndex(\n  timeCell => moment(date as SchedulerDateTime)\n    .isBetween(\n      timeCell[columnIndex].startDate,\n      timeCell[columnIndex].endDate,\n      'seconds',\n      takePrev ? '(]' : '[)'),\n    );\n","import { CalculateWeekDateIntervalsFn, AppointmentMoment } from '../../types';\nimport {\n  sliceAppointmentByDay, dayBoundaryPredicate, reduceAppointmentByDayBounds,\n  normalizeAppointmentDuration,\n} from './helpers';\nimport { filterByViewBoundaries } from '../../utils';\n\nexport const calculateWeekDateIntervals: CalculateWeekDateIntervalsFn = (\n  appointments,\n  leftBound, rightBound, // startViewDate, endViewDate\n  excludedDays,\n  cellDuration,\n) => [\n  appointments\n    .map(appointment => normalizeAppointmentDuration(appointment, cellDuration))\n    .reduce((acc, appointment) =>\n      [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true)],\n      [] as AppointmentMoment[],\n    )\n    .reduce((acc, appointment) => (\n      [...acc, ...sliceAppointmentByDay(appointment, cellDuration)]), [] as AppointmentMoment[],\n    )\n    .filter(appointment => dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays))\n    .map(appointment => reduceAppointmentByDayBounds(\n      appointment, leftBound, rightBound, cellDuration,\n    )),\n];\n","import moment from 'moment';\nimport {\n  GetCellByAppointmentDataFn, GetVerticalRectByAppointmentDataFn,\n  GetCellRectVerticalFn, SchedulerDateTime,\n} from '../../types';\nimport { VERTICAL_GROUP_ORIENTATION } from '../../constants';\nimport {\n  getWeekHorizontallyGroupedRowIndex, getWeekVerticallyGroupedRowIndex,\n  getWeekHorizontallyGroupedColumnIndex, getWeekVerticallyGroupedColumnIndex,\n} from '../week-view/helpers';\n\nconst CELL_GAP_PX = 10;\nconst CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nconst CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nexport const getVerticalCellIndexByAppointmentData: GetCellByAppointmentDataFn = (\n  appointment, viewCellsData, viewMetaData, date, takePrev = false,\n) => {\n  const { groupOrientation, groupCount } = viewMetaData;\n\n  const columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION\n    ? getWeekVerticallyGroupedColumnIndex(viewCellsData, date)\n    : getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date);\n  const rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION\n    ? getWeekVerticallyGroupedRowIndex(\n      viewCellsData, appointment, date, columnIndex, takePrev, groupCount,\n    ) : getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n\n  const cellIndex = (rowIndex * viewCellsData[0].length) + columnIndex;\n  return {\n    index: cellIndex,\n    startDate: viewCellsData[rowIndex][columnIndex].startDate,\n  };\n};\n\nconst getCellRect: GetCellRectVerticalFn = (\n  date, appointment, viewCellsData, cellDuration,\n  cellElementsMeta, takePrev, viewMetaData,\n) => {\n  const {\n    index: cellIndex,\n    startDate: cellStartDate,\n  } = getVerticalCellIndexByAppointmentData(\n    appointment, viewCellsData, viewMetaData, date, takePrev,\n  );\n\n  const {\n    top,\n    left,\n    width,\n    height: cellHeight,\n  } = cellElementsMeta.getCellRects[cellIndex]();\n  const timeOffset = moment(date as SchedulerDateTime).diff(cellStartDate as Date, 'minutes');\n  const topOffset = cellHeight * (timeOffset / cellDuration);\n  const parentRect = cellElementsMeta.parentRect();\n\n  return {\n    top,\n    left,\n    width,\n    topOffset,\n    parentRect,\n  };\n};\n\nexport const getVerticalRectByAppointmentData: GetVerticalRectByAppointmentDataFn = (\n  appointment,\n  viewMetaData,\n  {\n    viewCellsData,\n    cellDuration,\n    cellElementsMeta,\n    placeAppointmentsNextToEachOther,\n  },\n) => {\n  const firstCellRect = getCellRect(\n    appointment.start.toDate(), appointment, viewCellsData,\n    cellDuration, cellElementsMeta, false, viewMetaData,\n  );\n  const lastCellRect = getCellRect(\n    appointment.end.toDate(), appointment, viewCellsData,\n    cellDuration, cellElementsMeta, true, viewMetaData,\n  );\n\n  const top = firstCellRect.top + firstCellRect.topOffset;\n  const height = (lastCellRect.top + lastCellRect.topOffset) - top;\n\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: placeAppointmentsNextToEachOther ? height - CELL_BOUND_VERTICAL_OFFSET_PX : height,\n  };\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  AppointmentMoment, GetAllDayCellIndexByAppointmentDataFn,\n  SliceAppointmentsByBoundariesFn, SchedulerDateTime, ViewCell,\n} from '../../types';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\nimport { checkCellGroupingInfo } from '../common/helpers';\n\nexport const allDayPredicate: PureComputed<[AppointmentMoment], boolean> = appointment => (\n  appointment.end.diff(appointment.start, 'hours') > 23\n  || !!appointment.allDay\n);\n\nexport const getAllDayCellIndexByAppointmentData: GetAllDayCellIndexByAppointmentDataFn = (\n  viewCellsData, viewMetaData, date, appointment, takePrev,\n) => {\n  const currentDate = moment(date as SchedulerDateTime);\n  const { groupOrientation, groupCount } = viewMetaData;\n\n  const columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData, currentDate, appointment)\n    : getAllDayVerticallyGroupedColumnIndex(viewCellsData, currentDate);\n  const rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount);\n\n  let cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n  return cellIndex;\n};\n\nexport const getAllDayVerticallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], moment.Moment], number\n> = (viewCellsData, date) => viewCellsData[0].findIndex((timeCell) => {\n  return date.isSame(timeCell.startDate, 'date');\n});\n\nexport const getAllDayHorizontallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], moment.Moment, AppointmentMoment], number\n> = (viewCellsData, date, appointment) => viewCellsData[0].findIndex(timeCell => (\n  date.isSame(timeCell.startDate, 'date') && checkCellGroupingInfo(timeCell, appointment)\n));\n\nexport const getAllDayVerticallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, number], number\n> = (viewCellsData, appointment, groupCount) => {\n  const index = viewCellsData.findIndex(viewCellsDataRow => checkCellGroupingInfo(\n    viewCellsDataRow[0], appointment,\n  ));\n  return index * groupCount / viewCellsData.length;\n};\n\nexport const sliceAppointmentsByBoundaries: SliceAppointmentsByBoundariesFn = (\n  appointment, left, right, excludedDays = [],\n) => {\n  const startDate = appointment.start.clone();\n  const endDate = appointment.end.clone();\n  let nextStart = startDate.clone();\n  let nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left as Date)) {\n    nextStart = moment(left as Date);\n    nextStart.startOf('day');\n  }\n  if (endDate.isAfter(right as Date)) {\n    nextEnd = moment(right as Date);\n    nextEnd.endOf('day');\n  }\n  if (excludedDays.findIndex(day => day === startDate.day()) !== -1) {\n    while (excludedDays.findIndex(day => day === nextStart.day()) !== -1\n      && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n  if (excludedDays.findIndex(day => day === endDate.day()) !== -1) {\n    while (excludedDays.findIndex(day => day === nextEnd.day()) !== -1\n      && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n  return [{ ...appointment, start: nextStart, end: nextEnd }];\n};\n\nexport const sliceAppointmentsByDays: PureComputed<\n  [AppointmentMoment, number[]], AppointmentMoment[]\n> = (appointment, excludedDays = []) => {\n  const startDate = appointment.start;\n  const endDate = appointment.end;\n  let nextStart = startDate.clone();\n  const appointments = [] as AppointmentMoment[];\n\n  while (nextStart.isBefore(endDate)) {\n    if (excludedDays.findIndex(day => day === nextStart.day()) === - 1) {\n      appointments.push({\n        ...appointment,\n        start: nextStart,\n        end: moment(nextStart).endOf('day'),\n      });\n    }\n    nextStart = moment(nextStart).add(1, 'day');\n  }\n  return appointments;\n};\n","import { RRule } from 'rrule';\n\nexport const DEFAULT_RULE_OBJECT = {\n  interval: 1,\n};\n\nexport const DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6,\n};\n\nexport const RRULE_DAYS_OF_WEEK = [\n  RRule.MO,\n  RRule.TU,\n  RRule.WE,\n  RRule.TH,\n  RRule.FR,\n  RRule.SA,\n  RRule.SU,\n];\n\nexport const DAYS_IN_WEEK = 7;\n\nexport const DAYS_OF_WEEK_ARRAY = [\n  DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY,\n  DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY,\n];\n\nexport const MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12,\n};\n\nexport const RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY as number,\n  MONTHLY: RRule.MONTHLY as number,\n  WEEKLY: RRule.WEEKLY as number,\n  DAILY: RRule.DAILY as number,\n  HOURLY: RRule.HOURLY as number,\n  MINUTELY: RRule.MINUTELY as number,\n};\n\nexport const REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never',\n};\n\nexport const REPEAT_TYPES_ARRAY = [\n  REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY,\n];\n\nexport const WEEK_NUMBER_LABELS = [\n  'firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel',\n];\n\nexport const END_REPEAT_RADIO_GROUP = 'endRepeat';\nexport const MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nexport const YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\n\nexport const TITLE_TEXT_EDITOR = 'titleTextEditor';\nexport const MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nexport const ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nexport const NUMBER_EDITOR = 'numberEditor';\n\nexport const TITLE = 'title';\nexport const ORDINARY_LABEL = 'ordinaryLabel';\n\nexport const SAVE_BUTTON = 'saveButton';\nexport const DELETE_BUTTON = 'deleteButton';\nexport const CANCEL_BUTTON = 'cancelButton';\n\nexport const OUTLINED_SELECT = 'outlinedSelect';\nexport const STANDARD_SELECT = 'standardSelect';\n\nexport const SUNDAY_DATE = new Date(2019, 7, 11);\nexport const MONDAY_DATE = new Date(2019, 7, 12);\nexport const TUESDAY_DATE = new Date(2019, 7, 13);\nexport const WEDNESDAY_DATE = new Date(2019, 7, 14);\nexport const THURSDAY_DATE = new Date(2019, 7, 15);\nexport const FRIDAY_DATE = new Date(2019, 7, 16);\nexport const SATURDAY_DATE = new Date(2019, 7, 17);\n\nexport const DAYS_OF_WEEK_DATES = [\n  SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE,\n  THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE,\n];\n\nexport const JANUARY_DATE = new Date(2019, 0, 1);\nexport const FEBRUARY_DATE = new Date(2019, 1, 1);\nexport const MARCH_DATE = new Date(2019, 2, 1);\nexport const APRIL_DATE = new Date(2019, 3, 1);\nexport const MAY_DATE = new Date(2019, 4, 1);\nexport const JUNE_DATE = new Date(2019, 5, 1);\nexport const JULY_DATE = new Date(2019, 6, 1);\nexport const AUGUST_DATE = new Date(2019, 7, 1);\nexport const SEPTEMBER_DATE = new Date(2019, 8, 1);\nexport const OCTOBER_DATE = new Date(2019, 9, 1);\nexport const NOVEMBER_DATE = new Date(2019, 10, 1);\nexport const DECEMBER_DATE = new Date(2019, 11, 1);\n\nexport const MONTHS_DATES = [\n  JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE,\n  JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE,\n];\n\nexport const FIRST_WEEK = 0;\nexport const SECOND_WEEK = 1;\nexport const THIRD_WEEK = 2;\nexport const FOURTH_WEEK = 3;\nexport const LAST_WEEK = 4;\n\nexport const BASIC_YEALY_COUNT = 5;\nexport const BASIC_MONTHLY_COUNT = 12;\nexport const BASIC_WEEKLY_COUNT = 13;\nexport const BASIC_DAILY_COUNT = 30;\n","import moment from 'moment';\nimport {\n  SliceAppointmentByWeekFn, GetMonthCellIndexByAppointmentDataFn,\n  SchedulerDateTime, AppointmentMoment, ViewCell,\n} from '../../types';\nimport { DAYS_IN_WEEK } from '../appointment-form/constants';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\nimport { checkCellGroupingInfo } from '../common/helpers';\nimport { addDateToKey } from '../../utils';\n\nexport const sliceAppointmentByWeek: SliceAppointmentByWeekFn = (timeBounds, appointment, step) => {\n  const { left, right } = timeBounds;\n  const pieces: AppointmentMoment[] = [];\n  const { start, end, key, ...restFields } = appointment;\n  let apptStart = start;\n  let apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  let pieceFrom = apptStart.clone();\n  let pieceTo = apptStart.clone();\n  let i = 0;\n  while (pieceTo.isBefore(apptEnd)) {\n    const currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push({\n          start: pieceFrom,\n          end: pieceTo,\n          key: addDateToKey(key, pieceFrom),\n          ...restFields,\n        });\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n    i += 1;\n  }\n  return pieces;\n};\n\nexport const getMonthCellIndexByAppointmentData: GetMonthCellIndexByAppointmentDataFn = (\n  viewCellsData, viewMetaData, date, appointment, takePrev = false,\n) => {\n  const {\n    groupOrientation,\n    groupedByDate,\n    groupCount,\n  } = viewMetaData;\n\n  const startViewDate = moment(viewCellsData[0][0].startDate);\n  const currentDate = moment(date as SchedulerDateTime);\n  let dayNumber = currentDate.diff(startViewDate, 'days');\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    dayNumber -= 1;\n  }\n  const weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);\n  const dayOfWeek = dayNumber % DAYS_IN_WEEK;\n\n  const columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? getMonthHorizontallyGroupedColumnIndex(\n      viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate,\n    )\n    : dayOfWeek;\n  const rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? weekNumber\n    : getMonthVerticallyGroupedRowIndex(\n      viewCellsData, appointment, weekNumber, dayOfWeek, groupCount,\n    );\n\n  const totalCellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return totalCellIndex;\n};\n\nexport const getMonthHorizontallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, number, number, number, boolean], number\n> = (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) => {\n  let columnIndex = -1;\n  let currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;\n  const cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;\n\n  while (columnIndex === -1) {\n    const isCorrectCell = checkCellGroupingInfo(\n      viewCellsData[weekNumber][currentColumnIndex], appointment,\n    );\n    if (isCorrectCell) {\n      columnIndex = currentColumnIndex;\n    }\n    currentColumnIndex += cellsInGroupRow;\n  }\n  return columnIndex;\n};\n\nexport const getMonthVerticallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, number, number, number], number\n> = (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount) => {\n  const rowsInOneGroup = viewCellsData.length / groupCount;\n  let rowIndex = -1;\n  let currentRowIndex = weekNumber;\n  while (rowIndex === -1) {\n    const isCorrectCell = checkCellGroupingInfo(\n      viewCellsData[currentRowIndex][dayOfWeek], appointment,\n    );\n    if (isCorrectCell) {\n      rowIndex = currentRowIndex;\n    }\n    currentRowIndex += rowsInOneGroup;\n  }\n  return rowIndex;\n};\n","import { GetCellRectHorizontalFn, GetHorizontalRectByAppointmentDataFn } from '../../types';\nimport { getAllDayCellIndexByAppointmentData } from '../all-day-panel/helpers';\nimport { getMonthCellIndexByAppointmentData } from '../month-view/helpers';\n\nconst TOP_CELL_OFFSET = 0.32;\nconst CELL_BOUND_OFFSET_PX = 1;\n\nconst getCellRect: GetCellRectHorizontalFn = (\n  date, appointment, viewCellsData, viewMetaData, cellElementsMeta, takePrev, multiline,\n) => {\n  const cellIndex = multiline\n    ? getMonthCellIndexByAppointmentData(\n      viewCellsData, viewMetaData, date, appointment, takePrev,\n    ) : getAllDayCellIndexByAppointmentData(\n      viewCellsData, viewMetaData, date, appointment, takePrev,\n    );\n\n  const {\n    top,\n    left,\n    width,\n    height,\n  } = cellElementsMeta.getCellRects[cellIndex]();\n  const parentRect = cellElementsMeta.parentRect();\n  return {\n    top,\n    left,\n    width,\n    height,\n    parentRect,\n  };\n};\n\nexport const getHorizontalRectByAppointmentData: GetHorizontalRectByAppointmentDataFn = (\n  appointment,\n  viewMetaData,\n  {\n    multiline,\n    viewCellsData,\n    cellElementsMeta,\n  },\n) => {\n  const firstCellRect = getCellRect(\n    appointment.start.toDate(), appointment, viewCellsData,\n    viewMetaData, cellElementsMeta, false, multiline,\n  );\n  const lastCellRect = getCellRect(\n    appointment.end.toDate(), appointment, viewCellsData,\n    viewMetaData, cellElementsMeta, true, multiline,\n  );\n\n  const top = firstCellRect.top + (firstCellRect.height * TOP_CELL_OFFSET);\n  const height = firstCellRect.height - (firstCellRect.height * TOP_CELL_OFFSET);\n\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: (firstCellRect.left - firstCellRect.parentRect.left) + CELL_BOUND_OFFSET_PX,\n    width: ((lastCellRect.left - firstCellRect.left) + firstCellRect.width) - CELL_BOUND_OFFSET_PX,\n    height,\n    parentWidth: firstCellRect.parentRect.width,\n  };\n};\n","import moment from 'moment';\nimport {\n  MonthCellsDataComputedFn, MonthCellData,\n  CalculateMonthDateIntervalsFn, AppointmentMoment,\n} from '../../types';\nimport { filterByViewBoundaries } from '../../utils';\nimport { sliceAppointmentByWeek } from './helpers';\n\nconst DAY_COUNT = 7;\nconst MONTH_LENGTH = 31;\n\nexport const monthCellsData: MonthCellsDataComputedFn = (\n  currentDate,\n  firstDayOfWeek,\n  intervalCount = 1,\n  today,\n) => {\n  const targetDate = moment(currentDate as Date);\n  const currentMonths = [targetDate.month()];\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n  const firstMonthDate = moment(currentDate as Date).date(1);\n  const firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  const prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  const prevMonth = moment(currentDate as Date).subtract(1, 'months');\n  const prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  const from = moment()\n    .year(prevMonth.year())\n    .month(prevMonth.month())\n    .date(prevMonthStartDay)\n    .startOf('day');\n\n  const result: MonthCellData[][] = [];\n  while (result.length < (Math.trunc((MONTH_LENGTH * intervalCount) / DAY_COUNT) + 2)) {\n    const week: MonthCellData[] = [];\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(month => month === from.month()) === -1,\n        today: today ? moment(today as Date).isSame(from, 'date') : false,\n      });\n      from.add(1, 'day');\n    }\n    result.push(week);\n  }\n  return result;\n};\n\nexport const calculateMonthDateIntervals: CalculateMonthDateIntervalsFn = (\n  appointments, leftBound, rightBound,\n) => [\n  appointments\n    .map(({ start, end, ...restArgs }) => ({ start: moment(start), end: moment(end), ...restArgs }))\n    .reduce((acc, appointment) =>\n      [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, [], false)],\n      [] as AppointmentMoment[],\n    )\n    .reduce((acc, appointment) => ([\n      ...acc,\n      ...sliceAppointmentByWeek(\n        { left: moment(leftBound as Date), right: moment(rightBound as Date) },\n        appointment,\n        DAY_COUNT,\n      ),\n    ]), [] as AppointmentMoment[]),\n];\n","import moment from 'moment';\nimport {\n  AppointmentMoment, CalculateAllDayDateIntervalsFn,\n} from '../../types';\nimport { allDayPredicate, sliceAppointmentsByBoundaries } from './helpers';\nimport { filterByViewBoundaries } from '../../utils';\n\nexport const calculateAllDayDateIntervals: CalculateAllDayDateIntervalsFn = (\n  appointments,\n  leftBound, rightBound,\n  excludedDays,\n) => [\n  appointments\n    .map(({ start, end, ...restArgs }) => ({ start: moment(start), end: moment(end), ...restArgs }))\n    .reduce((acc, appointment) =>\n      [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false)],\n      [] as AppointmentMoment[],\n    )\n    .filter(appointment => allDayPredicate(appointment))\n    .reduce((acc, appointment) => ([\n      ...acc,\n      ...sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays),\n    ]), [] as AppointmentMoment[]),\n];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  ValidResourceInstance, Group, ViewCell, ValidResource,\n  AppointmentMoment, Grouping, GroupOrientation, AppointmentKey,\n} from '../../types';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\n\nexport const getGroupFromResourceInstance: PureComputed<\n  [ValidResourceInstance], Group\n> = resourceInstance => ({\n  id: resourceInstance.id,\n  fieldName: resourceInstance.fieldName,\n  text: resourceInstance.text,\n});\n\nexport const addGroupInfoToCells: PureComputed<\n  [Group, Group[][], ValidResource[],\n  ViewCell[], number, boolean, GroupOrientation], ViewCell[]\n> = (\n  currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation,\n) => viewCellRow.map((\n    viewCell: ViewCell, cellIndex: number,\n  ) => {\n  const groupedCell = addGroupInfoToCell(\n    currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation,\n  ) as ViewCell;\n  return cellIndex === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? { ...groupedCell, endOfGroup: true }\n    : groupedCell;\n});\n\nexport const addGroupInfoToCell: PureComputed<\n  [Group, Group[][], ValidResource[],\n  ViewCell, number, boolean, GroupOrientation], ViewCell\n> = (currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) => {\n  let previousIndex = index;\n  const groupingInfo = groups.reduceRight((\n    acc: Group[], group: Group[], currentIndex: number,\n  ) => {\n    if (currentIndex === groups.length - 1) return acc;\n    const previousResourceLength = sortedResources[currentIndex + 1].instances.length;\n    const currentGroupingInstance = group[Math.floor(\n      previousIndex / previousResourceLength,\n    )];\n    previousIndex = currentIndex;\n    return [...acc, currentGroupingInstance];\n  }, [currentGroup]);\n  return { ...viewCell, groupingInfo, endOfGroup, groupOrientation };\n};\n\nconst getCurrentGroup: PureComputed<\n  [Group[][], ValidResource[], number, Group], Group[]\n> = (groups, resources, index, group) => {\n  let currentIndex = index;\n  return groups.reduceRight((groupAcc, groupsRow, rowIndex) => {\n    if (rowIndex === groups!.length - 1) {\n      return groupAcc;\n    }\n    currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);\n    const currentInstance = groupsRow[currentIndex];\n    return [\n      ...groupAcc,\n      currentInstance,\n    ];\n  }, [group]);\n};\n\nexport const groupAppointments: PureComputed<\n  [AppointmentMoment[], ValidResource[] | undefined,\n  Group[][] | undefined], AppointmentMoment[][]\n> = (appointments, resources, groups) => {\n  if (!resources || !groups) return [appointments.slice()];\n  const mainResource = resources.find(resource => resource.isMain);\n  return groups![groups!.length - 1].map((group, index) => {\n    const currentGroup = getCurrentGroup(groups, resources, index, group);\n\n    return appointments.reduce((acc, appointment) => {\n      const belongsToGroup = currentGroup.reduce((isBelonging, groupItem) => (\n        isBelonging && groupItem.id === appointment[groupItem.fieldName]\n      ), true);\n      if (!belongsToGroup) return acc;\n      const currentMainResourceId = currentGroup.find(\n        groupItem => groupItem.fieldName === mainResource!.fieldName,\n      )!.id;\n\n      const updatedAppointment = {\n        ...appointment,\n        dataItem: {\n          ...appointment.dataItem,\n          [mainResource!.fieldName]: rearrangeResourceIds(\n            mainResource!, appointment, currentMainResourceId,\n          ),\n        },\n        resources: appointment.resources && rearrangeResources(\n          mainResource!, appointment, currentMainResourceId,\n        ),\n      };\n      return [...acc, updatedAppointment];\n    }, [] as AppointmentMoment[]);\n  });\n};\n\nconst rearrangeResourceIds: PureComputed<\n  [ValidResource, AppointmentMoment, any], any[] | any\n> = (mainResource, appointment, mainResourceId) => {\n  if (!mainResource.allowMultiple) {\n    return mainResourceId;\n  }\n  return [\n    mainResourceId,\n    ...appointment.dataItem[mainResource!.fieldName].filter((id: any) => id !== mainResourceId),\n  ];\n};\n\nexport const rearrangeResources: PureComputed<\n  [ValidResource, AppointmentMoment, any], ValidResourceInstance[]\n> = (mainResource, appointment, currentResourceInstanceId) => {\n  if (!mainResource.allowMultiple) {\n    return appointment.resources;\n  }\n  const resources = appointment.resources.slice();\n  const firstMainResource = resources.findIndex((el: ValidResourceInstance) => el.isMain);\n  const currentResourceIndex = resources.findIndex(\n    (el: ValidResourceInstance) => el.isMain && el.id === currentResourceInstanceId,\n  );\n  [resources[firstMainResource], resources[currentResourceIndex]] =\n    [resources[currentResourceIndex], resources[firstMainResource]];\n  return resources;\n};\n\nexport const expandGroupedAppointment: PureComputed<\n  [AppointmentMoment, Grouping[], ValidResource[]], AppointmentMoment[]\n> = (appointment, grouping, resources) => {\n  if (!resources || !grouping) {\n    return [appointment];\n  }\n  return resources\n    .reduce((acc: AppointmentMoment[], resource: ValidResource) => {\n      const isGroupedByResource = grouping.find(\n        group => group.resourceName === resource.fieldName,\n      ) !== undefined;\n      if (!isGroupedByResource) return acc;\n      const resourceField = resource.fieldName;\n      if (!resource.allowMultiple) {\n        return acc.reduce((accumulatedAppointments, currentAppointment) => [\n          ...accumulatedAppointments,\n          { ...currentAppointment, [resourceField]: currentAppointment.dataItem[resourceField] },\n        ], [] as AppointmentMoment[]);\n      }\n      return acc.reduce((accumulatedAppointments, currentAppointment) => [\n        ...accumulatedAppointments,\n        ...currentAppointment.dataItem[resourceField].map(\n          (resourceValue: number | string) => ({\n            ...currentAppointment,\n            [resourceField]: resourceValue,\n            key: generateMultipleResourceKey(currentAppointment.key, resourceValue),\n          }),\n        ),\n      ], [] as AppointmentMoment[]);\n    }, [appointment] as AppointmentMoment[]);\n};\n\nconst generateMultipleResourceKey: PureComputed<\n  [AppointmentKey, number | string], AppointmentKey\n> = (previousKey, resourceValue) => `${previousKey}_${resourceValue}`;\n\nexport const getGroupingInfoFromGroups: PureComputed<\n  [Group[][], number], Group[]\n> = (groups, groupIndex) => {\n  let previousIndex = groupIndex;\n  return groups.reduceRight((acc, currentGroups, currentIndex) => {\n    if (currentIndex === groups.length - 1) return acc;\n    const previousResourceLength = groups[currentIndex + 1].length / currentGroups.length;\n    const currentGroupingInstance = currentGroups[Math.floor(\n      previousIndex / previousResourceLength,\n    )];\n    previousIndex = currentIndex;\n    return [...acc, currentGroupingInstance];\n  }, [getGroupsLastRow(groups)[groupIndex]]);\n};\n\nexport const getGroupsLastRow: PureComputed<\n  [Group[][]], Group[]\n> = groups => groups[groups.length - 1];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  Grouping, ValidResourceInstance, ViewCell, ValidResource,\n  Group, AppointmentMoment, ExpandGroupingPanelCellFn, GroupOrientation,\n  CellElementsMeta, SchedulerView,\n} from '../../types';\nimport {\n  getGroupFromResourceInstance, addGroupInfoToCells,\n  groupAppointments, expandGroupedAppointment, addGroupInfoToCell, getGroupsLastRow,\n} from './helpers';\nimport { sliceAppointmentsByDays } from '../all-day-panel/helpers';\nimport { HORIZONTAL_GROUP_ORIENTATION, VERTICAL_GROUP_ORIENTATION } from '../../constants';\nimport { containsDSTChange } from '../common/helpers';\n\nexport const filterResourcesByGrouping: PureComputed<\n  [Array<ValidResource>, Array<Grouping>], Array<ValidResource>\n> = (resources, grouping) => resources.filter(\n  resource => grouping.find(resourceId => resource.fieldName === resourceId.resourceName),\n);\n\nexport const sortFilteredResources: PureComputed<\n  [Array<ValidResource>, Array<Grouping>], Array<ValidResource>\n> = (resources, grouping) => grouping.map(({ resourceName }: Grouping) => (\n  resources.find(resource => resource.fieldName === resourceName) as ValidResource\n));\n\nexport const getGroupsFromResources: PureComputed<\n  [Array<ValidResource>], Array<Array<Group>>\n> = sortedAndFilteredResources => sortedAndFilteredResources.reduce((\n    acc: Array<Array<Group>>, resource: ValidResource, index: number,\n  ) => {\n  if (index === 0) {\n    return [resource.instances.map(instance => getGroupFromResourceInstance(instance))];\n  }\n\n  return [\n    ...acc,\n    acc[index - 1].reduce((currentResourceNames: Array<Group>) => [\n      ...currentResourceNames,\n      ...resource.instances.map(\n        (instance: ValidResourceInstance) => getGroupFromResourceInstance(instance),\n      ),\n    ], []),\n  ];\n}, []);\n\nexport const expandViewCellsDataWithGroups: PureComputed<\n  [ViewCell[][], Group[][], ValidResource[], boolean, GroupOrientation], ViewCell[][]\n> = (viewCellsData, groups, sortedResources, groupByDate, groupOrientation) => {\n  if (groups.length === 0) return viewCellsData;\n  if (groupByDate) {\n    return expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources);\n  }\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources);\n  }\n  return expandVerticallyGroupedCells(viewCellsData, groups, sortedResources);\n};\n\nconst expandCellsWithGroupedByDateData: ExpandGroupingPanelCellFn = (\n  viewCellsData, groups, sortedResources,\n) => viewCellsData.map(\n  (cellsRow: ViewCell[]) => cellsRow.reduce((acc: ViewCell[], viewCell: ViewCell) => {\n    const groupedCells = getGroupsLastRow(groups).map((\n      group: Group, index: number,\n    ) => addGroupInfoToCell(\n      group, groups, sortedResources, viewCell, index,\n      false, HORIZONTAL_GROUP_ORIENTATION,\n    ));\n    groupedCells[groupedCells.length - 1] = {\n      ...groupedCells[groupedCells.length - 1],\n      endOfGroup: true,\n    };\n    return [...acc, ...groupedCells] as ViewCell[];\n  }, [] as ViewCell[]),\n);\n\nconst expandHorizontallyGroupedCells: ExpandGroupingPanelCellFn = (\n  viewCellsData, groups, sortedResources,\n) => getGroupsLastRow(groups).reduce((\n  acc: ViewCell[][], group: Group, index: number,\n) => {\n  if (index === 0) {\n    return viewCellsData.map((viewCellsRow: ViewCell[]) =>\n      addGroupInfoToCells(\n        group, groups, sortedResources, viewCellsRow, index,\n        false, HORIZONTAL_GROUP_ORIENTATION,\n      ) as ViewCell[],\n    );\n  }\n  return acc.map((item: ViewCell[], id: number) => [\n    ...item,\n    ...addGroupInfoToCells(\n      group, groups, sortedResources, viewCellsData[id], index,\n      false, HORIZONTAL_GROUP_ORIENTATION,\n    ),\n  ]);\n}, [[]] as ViewCell[][]);\n\nconst expandVerticallyGroupedCells: ExpandGroupingPanelCellFn = (\n  viewCellsData, groups, sortedResources,\n) => getGroupsLastRow(groups).reduce((\n  acc: ViewCell[][], group: Group, index: number,\n) => {\n  if (index === 0) {\n    return viewCellsData.map((\n      viewCellsRow: ViewCell[], viewRowIndex: number,\n    ) => addGroupInfoToCells(\n        group, groups, sortedResources, viewCellsRow,\n        index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION,\n      ) as ViewCell[]);\n  }\n  return [\n    ...acc,\n    ...viewCellsData.map((viewCellsRow: ViewCell[], viewRowIndex: number) =>\n      addGroupInfoToCells(\n        group, groups, sortedResources, viewCellsRow,\n        index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION,\n      ) as ViewCell[],\n    ),\n  ];\n}, [[]] as ViewCell[][]);\n\nexport const updateGroupingWithMainResource: PureComputed<\n  [Grouping[] | undefined, ValidResource[]], Grouping[]\n> = (grouping, resources) => grouping\n  || [{ resourceName: resources.find(resource => resource.isMain)!.fieldName }];\n\nexport const expandGroups: PureComputed<\n  [AppointmentMoment[][], Grouping[], ValidResource[],\n  Group[][], number[], boolean], AppointmentMoment[][]\n> = (appointments, grouping, resources, groups, excludedDays, sliceByDay = false) => {\n  const slicedAppointments = sliceByDay ?\n    appointments[0].reduce((acc: AppointmentMoment[], appointment: AppointmentMoment) => ([\n      ...acc,\n      ...sliceAppointmentsByDays(appointment, excludedDays),\n    ]), [] as AppointmentMoment[]) : appointments[0];\n\n  const expandedAppointments = (slicedAppointments as AppointmentMoment[])\n    .reduce((acc: AppointmentMoment[], appointment: AppointmentMoment) => [\n      ...acc,\n      ...expandGroupedAppointment(appointment, grouping, resources),\n    ], [] as AppointmentMoment[]);\n  return groupAppointments(expandedAppointments, resources, groups);\n};\n\nexport const updateTimeTableCellElementsMeta: PureComputed<\n  [CellElementsMeta, (viewName: string) => GroupOrientation, Group[][],\n  boolean, ViewCell[][], SchedulerView], CellElementsMeta\n> = (\n  timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView,\n) => {\n  if (checkCellElementsMeta(\n    timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists,\n  )) {\n    return timeTableElementsMeta;\n  }\n\n  const {\n    groupCount, timeTableWidth, groupSize, validGetCellRects,\n  } = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups);\n  let allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(allDayPanelsLeft * (timeTableWidth + groupSize), timeTableWidth);\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects,\n  };\n};\n\nexport const updateAllDayCellElementsMeta: PureComputed<\n  [CellElementsMeta, CellElementsMeta, (viewName: string) => GroupOrientation, Group[][],\n  boolean, ViewCell[][], SchedulerView], CellElementsMeta\n> = (\n  allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups,\n  allDayPanelExists, viewCellsData, currentView,\n) => {\n  if (checkCellElementsMeta(\n    timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists,\n  )) {\n    return allDayElementsMeta;\n  }\n\n  const {\n    groupCount, timeTableWidth, groupSize, validGetCellRects,\n  } = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups);\n  let allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(\n      groupSize * allDayPanelsLeft + timeTableWidth * (allDayPanelsLeft + 1), groupSize,\n    );\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects,\n  };\n};\n\nconst checkCellElementsMeta: PureComputed<\n  [CellElementsMeta, (viewName: string) => GroupOrientation, SchedulerView, boolean], boolean\n> = (\n  cellElementsMeta, groupOrientation, currentView, allDayPanelExists,\n) => groupOrientation(currentView.name) === HORIZONTAL_GROUP_ORIENTATION\n  || !allDayPanelExists || !cellElementsMeta.getCellRects;\n\nconst initializeCellElementsData: PureComputed<\n  [CellElementsMeta, ViewCell[][], Group[][]], any\n> = (cellElementsMeta, viewCellsData, groups) => {\n  const timeTableWidth = viewCellsData[0].length;\n  const groupCount = getGroupsLastRow(groups).length;\n  const groupHeight = viewCellsData.length / groupCount;\n  return {\n    groupCount,\n    timeTableWidth,\n    groupSize: timeTableWidth * groupHeight,\n    validGetCellRects: cellElementsMeta.getCellRects.slice(),\n  };\n};\n\nexport const updateTimeCellsData: PureComputed<\n  [ViewCell[][], ViewCell[][], Group[][], ValidResource[], GroupOrientation], ViewCell[][]\n> = (viewCellsData, timeCellsData, groups, sortedResources, groupOrientation) => {\n  const { startDate: firstViewDate } = viewCellsData[0][0];\n  if (!containsDSTChange(firstViewDate)) {\n    return viewCellsData;\n  }\n\n  if (groupOrientation !== VERTICAL_GROUP_ORIENTATION) {\n    return timeCellsData;\n  }\n\n  return expandVerticallyGroupedCells(timeCellsData, groups, sortedResources);\n};\n","import {\n  AllDayRects, VerticalRects, HorizontalRects,\n} from '../../types';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE,\n} from '../../constants';\nimport { calculateRectByDateAndGroupIntervals } from '../appointments/helpers';\nimport { calculateWeekDateIntervals } from '../week-view/computeds';\nimport { getVerticalRectByAppointmentData } from '../vertical-rect/helpers';\nimport { getHorizontalRectByAppointmentData } from '../horizontal-rect/helpers';\nimport { calculateMonthDateIntervals } from '../month-view/computeds';\nimport { calculateAllDayDateIntervals } from '../all-day-panel/computeds';\nimport { expandGroups } from '../integrated-grouping/computeds';\nimport { getGroupsLastRow } from '../integrated-grouping/helpers';\n\nexport const allDayRects: AllDayRects = (\n  appointments, startViewDate, endViewDate,\n  excludedDays, viewCellsData, cellElementsMeta,\n  grouping, resources, groups, groupOrientation, sliceAppointments,\n) => {\n  const intervals = calculateAllDayDateIntervals(\n    appointments, startViewDate, endViewDate, excludedDays,\n  );\n  const groupedIntervals = expandGroups(\n    intervals, grouping, resources, groups, excludedDays, sliceAppointments,\n  );\n\n  return calculateRectByDateAndGroupIntervals(\n    {\n      growDirection: HORIZONTAL_TYPE,\n      multiline: false,\n    },\n    groupedIntervals,\n    getHorizontalRectByAppointmentData,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellElementsMeta,\n      excludedDays,\n    },\n    {\n      groupOrientation,\n      groupedByDate: sliceAppointments,\n      groupCount: groups ? getGroupsLastRow(groups).length : 1,\n    },\n  );\n};\n\nexport const verticalTimeTableRects: VerticalRects = (\n  appointments, startViewDate, endViewDate, excludedDays, viewCellsData,\n  cellDuration, cellElementsMeta, grouping, resources, groups,  groupOrientation, groupByDate,\n) => {\n  const intervals = calculateWeekDateIntervals(\n    appointments, startViewDate, endViewDate, excludedDays, cellDuration,\n  );\n  const groupedIntervals = expandGroups(\n    intervals, grouping, resources, groups, excludedDays, false,\n  );\n\n  return calculateRectByDateAndGroupIntervals(\n    {\n      growDirection: VERTICAL_TYPE,\n      multiline: false,\n    },\n    groupedIntervals,\n    getVerticalRectByAppointmentData,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n    },\n    {\n      groupOrientation,\n      groupedByDate: groupByDate,\n      groupCount: groups ? getGroupsLastRow(groups).length : 1,\n    },\n  );\n};\n\nexport const horizontalTimeTableRects: HorizontalRects = (\n  appointments, startViewDate, endViewDate, viewCellsData,\n  cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments,\n) => {\n  const intervals = calculateMonthDateIntervals(\n    appointments, startViewDate, endViewDate,\n  );\n  const groupedIntervals = expandGroups(\n    intervals, grouping, resources, groups, [], sliceAppointments,\n  );\n\n  return calculateRectByDateAndGroupIntervals(\n    {\n      growDirection: HORIZONTAL_TYPE,\n      multiline: true,\n    },\n    groupedIntervals,\n    getHorizontalRectByAppointmentData,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellElementsMeta,\n    },\n    {\n      groupOrientation,\n      groupedByDate: sliceAppointments,\n      groupCount: groups ? getGroupsLastRow(groups).length : 1,\n    },\n  );\n};\n","import { DateTimeFormatInstanceFn } from '../../types';\n\nexport const dateTimeFormatInstance: DateTimeFormatInstanceFn = (\n  locale, formatOptions,\n) => new Intl.DateTimeFormat(locale, formatOptions);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { AppointmentModel, Appointment, FormatDateTimeGetterFn, FormatterFn } from '../../types';\nimport { convertToMoment } from '../common/helpers';\nimport { dateTimeFormatInstance } from './helpers';\n\nexport const appointments: PureComputed<\n  [AppointmentModel[]], Appointment[]\n> = data => data.map((appointment, index) => ({\n  dataItem: appointment,\n  start: appointment.startDate,\n  ...appointment.endDate !== undefined ? {\n    end: appointment.endDate,\n  } : {\n    end: appointment.startDate,\n    dataItem: { ...appointment, endDate: appointment.startDate },\n  },\n  ...appointment.allDay !== undefined && {\n    allDay: appointment.allDay,\n  },\n  ...appointment.rRule !== undefined && {\n    rRule: appointment.rRule,\n  },\n  ...appointment.exDate !== undefined && {\n    exDate: appointment.exDate,\n  },\n  key: appointment.id || index,\n}));\n\nexport const formatDateTimeGetter: FormatDateTimeGetterFn = (locale) => {\n  const cache = new Map<Intl.DateTimeFormatOptions, Intl.DateTimeFormat>(); // any -> type\n\n  const formatter: FormatterFn = (nextDate, nextOptions) => {\n    if (nextDate === undefined) return '';\n    const date = convertToMoment(nextDate).toDate();\n    let formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n  return formatter;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Group, HorizontalGroupingCellData, VerticalGroupingCellData } from '../../types';\nimport { getGroupsLastRow } from '../integrated-grouping/helpers';\n\nexport const getCellKey: PureComputed<\n  [Group[][], number, number], string\n> = (groups, groupIndex, rowNumber) => {\n  let currentIndex = groupIndex;\n  return groups.reduceRight((acc: string, groupRow: Group[], rowIndex: number) => {\n    if (rowNumber < rowIndex) return acc;\n    const currentKey = groupRow[currentIndex].id;\n    if (rowIndex > 0) {\n      const currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;\n      currentIndex = Math.floor(currentIndex / currentRowLength);\n    }\n    return acc + currentKey;\n  }, '' as string);\n};\n\nexport const getRowFromGroups: PureComputed<\n  [number, Group[], any, Group[][], number], HorizontalGroupingCellData[]\n> = (width, groupRow, cellStyle, groups, rowIndex) => {\n  let row = [] as any[];\n  const currentRowLength = groupRow.length;\n  const standardWidth = width / getGroupsLastRow(groups).length;\n  const colSpan = getGroupsLastRow(groups).length / currentRowLength;\n  for (let i = 0; i < standardWidth; i += 1) {\n    row = [...row, ...groupRow.reduce((acc, group, index) => [\n      ...acc,\n      {\n        group,\n        colSpan,\n        key: getCellKey(groups, index, rowIndex) + i,\n        left: cellStyle.left,\n        endOfGroup: index === currentRowLength - 1,\n      },\n    ], [] as any[])];\n  }\n  return row;\n};\n\nexport const getVerticalRowFromGroups: PureComputed<\n  [Group[][], number, number, number, boolean, number], VerticalGroupingCellData[]\n> = (\n  groups, groupIndex, groupingPanelRowSpan,\n  timeTableCellHeight, addAllDayHeight, allDayCellHeight,\n) => groups.reduce((\n  acc, groupColumn, columnIndex,\n) => {\n  const groupSpan = getGroupsLastRow(groups).length / groupColumn.length;\n  const cellIndex = groupIndex / groupSpan;\n  const baseHeight = (groupingPanelRowSpan * groupSpan * timeTableCellHeight)\n    / getGroupsLastRow(groups).length;\n  const allDayHeight = groupSpan * allDayCellHeight;\n\n  return groupIndex % groupSpan !== 0 ? acc : [\n    ...acc,\n    {\n      group: groupColumn[cellIndex],\n      rowSpan: groupSpan,\n      height: addAllDayHeight ? baseHeight + allDayHeight : baseHeight,\n      key: getCellKey(groups, cellIndex, columnIndex),\n    },\n  ];\n}, [] as VerticalGroupingCellData[]);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\nimport { ViewCell, Group, GroupOrientation, TimeScaleLabelData, AllDayCell } from '../../types';\nimport { getCellKey } from '../grouping-panel/utils';\nimport { getGroupsLastRow } from '../integrated-grouping/helpers';\n\nconst getLabelsForSingleGroup: PureComputed<\n  [Group[][], ViewCell[][], number, number], TimeScaleLabelData[]\n> = (groups, cellsData, groupIndex, groupHeight) => {\n  const currentGroupIndex = groupIndex * groupHeight;\n  const nextGroupIndex = currentGroupIndex + groupHeight;\n\n  return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce((\n    acc: TimeScaleLabelData[], days: ViewCell[],\n  ) => (([\n    ...acc,\n    {\n      startDate: days[0].startDate,\n      endDate: days[0].endDate,\n      key: days[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),\n      groupingInfo: days[0].groupingInfo,\n    },\n  ])), [] as TimeScaleLabelData[]);\n};\n\nexport const getLabelsForAllGroups: PureComputed<\n  [ViewCell[][], Group[][], GroupOrientation], TimeScaleLabelData[][]\n> = (cellsData, groups, groupOrientation) => {\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return [cellsData.map(cellsRow => ({\n      startDate: cellsRow[0].startDate,\n      endDate: cellsRow[0].endDate,\n      groupingInfo: cellsRow[0].groupingInfo,\n      key: cellsRow[0].endDate,\n    }))];\n  }\n\n  const groupCount = getGroupsLastRow(groups).length;\n  const singleGroupHeight = cellsData.length / groupCount;\n\n  return getGroupsLastRow(groups).reduce((\n    acc: TimeScaleLabelData[][], group: Group, groupIndex: number,\n  ) => [\n    ...acc,\n    getLabelsForSingleGroup(\n      groups, cellsData, groupIndex, singleGroupHeight,\n    ) as TimeScaleLabelData[],\n  ], [] as TimeScaleLabelData[][]);\n};\n\nexport const prepareVerticalViewCellsData: PureComputed<\n  [ViewCell[][], AllDayCell[][]], ViewCell[][][]\n> = (cellsData, allDayCellsData) => {\n  const groupCount = allDayCellsData?.length || 1;\n  const validCellsData = [] as ViewCell[][][];\n  const groupHeight = cellsData.length / groupCount;\n  for (let i = 0; i < groupCount; i += 1) {\n    validCellsData.push(cellsData.slice(i * groupHeight, (i + 1) * groupHeight));\n  }\n  return validCellsData;\n};\n","import moment from 'moment';\nimport { PureReducer } from '@devexpress/dx-core';\nimport { ChangeCurrentDatePayload } from '../../types';\n\nexport const changeCurrentDate: PureReducer<Date, ChangeCurrentDatePayload> = (\n  currentDate, {\n  nextDate, step, amount, direction,\n}) => (\n  nextDate\n  || moment(currentDate as Date)[direction === 'back' ? 'subtract' : 'add'](amount, step)\n    .toDate()\n  || moment().subtract(amount, step)\n);\n\nexport const setCurrentViewName: PureReducer<\n  string, string, string\n> = (currentViewName, nextViewName) => nextViewName;\n","import { PureReducer } from '@devexpress/dx-core';\nimport { AppointmentMeta } from '../../types';\n\nexport const setAppointmentMeta: PureReducer<AppointmentMeta, AppointmentMeta> = (\n  prevAppointmentMeta,\n  { target, data },\n) => ({ target, data });\n","export const OPEN_COMMAND_BUTTON = 'open';\nexport const CLOSE_COMMAND_BUTTON = 'close';\nexport const DELETE_COMMAND_BUTTON = 'delete';\nexport const CANCEL_COMMAND_BUTTON = 'cancel';\nexport const COMMIT_COMMAND_BUTTON = 'commit';\n","import { PureReducer } from '@devexpress/dx-core';\nimport { AppointmentModel, AppointmentDataPayload } from '../../types';\n\nexport const setAppointmentData: PureReducer<\n  AppointmentModel, AppointmentDataPayload\n> = (prevAppointmentData, { appointmentData }) => appointmentData;\n","import {\n  LONG_WEEK_DAY_OPTIONS, DAY_LONG_MONTH_OPTIONS,\n  LONG_MONTH_OPTIONS,\n} from '@devexpress/dx-scheduler-core';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  SelectOption, OptionsFormatterFn, DateFormatterFn, RecurrenceFrequency,\n} from '../../types';\nimport {\n  MONTHS_DATES, REPEAT_TYPES_ARRAY, WEEK_NUMBER_LABELS, DAYS_IN_WEEK, RRULE_REPEAT_TYPES,\n  BASIC_YEALY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_DAILY_COUNT,\n} from './constants';\nimport { getDaysOfWeekDates, getDaysOfWeekArray } from './helpers';\n\nexport const getWeekNumberLabels: OptionsFormatterFn = getMessage =>\n  WEEK_NUMBER_LABELS.map((weekNumberLabel, index) => ({\n    text: getMessage(weekNumberLabel),\n    id: index,\n  }));\n\nexport const getDaysOfWeek: PureComputed<\n  [(date: Date, formatOptions: object) => string, number], Array<SelectOption>\n> = (formatDate, firstDayOfWeek) => {\n  const daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  const daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(\n    (day, index) => ({\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0],\n    }),\n  );\n};\n\nexport const getMonths: DateFormatterFn = formatDate => MONTHS_DATES.map((month, index) => ({\n  text: getMonth(month, formatDate),\n  id: getMonthId(index),\n}));\n\nexport const getMonthsWithOf: PureComputed<\n  [(messageKey: string) => string, (date: Date, formatOptions: object) => string],\n    Array<SelectOption>\n> = (getMessage, formatDate) => MONTHS_DATES.map((month, index) => ({\n  text: getMonthWithOf(month, getMessage, formatDate),\n  id: getMonthId(index),\n}));\n\nconst getMonthWithOf = (\n  date: Date,\n  getMessage: (messageKey: string) => string,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => getMessage('ofLabel')\n  + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n\nconst getMonth = (\n  date: Date,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => formatDate(date, LONG_MONTH_OPTIONS);\n\nconst getDayOfWeek = (\n  date: Date,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => formatDate(date, LONG_WEEK_DAY_OPTIONS);\n\nconst getMonthId: PureComputed<\n  [number], number\n> = index => index + 1;\n\nexport const getAvailableRecurrenceOptions: OptionsFormatterFn = getMessage =>\n  REPEAT_TYPES_ARRAY.map(type => ({\n    text: getMessage(type),\n    id: type,\n  }));\n\nexport const getCountDependingOnRecurrenceType = (frequency: RecurrenceFrequency) => {\n  let count;\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n  return count;\n};\n\nexport const checkIsNaturalNumber: PureComputed<\n  [number], boolean\n> = number => number > 0 && number <= Number.MAX_SAFE_INTEGER;\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { RRule, Options, Weekday } from 'rrule';\nimport {\n  Action,\n  StartDate,\n  EndDate,\n  RadioGroupDisplayData,\n  ValidResource,\n} from '../../types';\nimport {\n  DEFAULT_RULE_OBJECT, RRULE_REPEAT_TYPES, REPEAT_TYPES, LAST_WEEK,\n  DAYS_OF_WEEK_ARRAY, DAYS_IN_WEEK, DAYS_OF_WEEK_DATES, RRULE_DAYS_OF_WEEK,\n} from './constants';\nimport { getCountDependingOnRecurrenceType } from './utils';\n\nexport const callActionIfExists: PureComputed<[Action, object], void> = (action, payload) => {\n  if (action) {\n    action(payload);\n  }\n};\n\nexport const isAllDayCell: PureComputed<\n  [StartDate, EndDate], boolean\n> = (\n  startDate, endDate,\n) => moment(endDate as EndDate).diff(moment(startDate as StartDate), 'days') >= 1;\n\nexport const changeRecurrenceFrequency: PureComputed<\n  [string, number, Date], string\n> = (\n  rule, freq, startDate,\n) => {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return (new RRule({\n        ...DEFAULT_RULE_OBJECT,\n        freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq),\n      })).toString();\n    }\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return (new RRule({\n        ...DEFAULT_RULE_OBJECT,\n        freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq),\n      })).toString();\n    }\n    return (new RRule({\n      ...DEFAULT_RULE_OBJECT, freq, count: getCountDependingOnRecurrenceType(freq),\n    })).toString();\n  }\n\n  const options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n  options.byweekday = undefined;\n  const nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nexport const getRecurrenceOptions: PureComputed<\n  [string | undefined], Partial<Options> | null\n> = rule => !rule ? null : RRule.parseString(rule);\n\nexport const changeRecurrenceOptions = (options: Partial<Options>) => {\n  return options ? (new RRule({ ...options })).toString() : undefined;\n};\n\nexport const handleStartDateChange = (nextStartDay: number, options: Partial<Options>) => {\n  if (nextStartDay <= 31) {\n    const nextOptions = { ...options, bymonthday: nextStartDay };\n    return changeRecurrenceOptions(nextOptions);\n  }\n  return changeRecurrenceOptions(options);\n};\n\nexport const handleToDayOfWeekChange = (\n  weekNumber: number, dayOfWeek: number, options: Partial<Options>,\n) => {\n  const validDayOfWeek = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  const validWeekNumber = weekNumber === 4 ? -1 : weekNumber + 1;\n  const rruleDayOfWeek = RRULE_DAYS_OF_WEEK[validDayOfWeek];\n\n  const nextOptions = {\n    ...options,\n    byweekday: [rruleDayOfWeek.nth(validWeekNumber)],\n    bymonthday: undefined,\n  };\n\n  return changeRecurrenceOptions(nextOptions);\n};\n\nexport const getRRuleFrequency: PureComputed<\n  [string], number\n> = repeatType => RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n\nexport const getFrequencyString: PureComputed<\n  [number], string\n> = (rRuleFrequency) => {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nexport const getRadioGroupDisplayData: PureComputed<\n  [Partial<Options>, number, number, number, string, string], RadioGroupDisplayData\n> = (\n  recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption,\n) => {\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: (recurrenceOptions.bymonthday as number),\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption,\n    };\n  }\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber,\n    };\n  }\n  const dayOfWeek = recurrenceOptions.byweekday[0].weekday < 6\n    ? recurrenceOptions.byweekday[0].weekday + 1 : 0;\n  const weekNumber = recurrenceOptions.byweekday[0].n === -1\n    ? LAST_WEEK\n    : recurrenceOptions.byweekday[0].n - 1;\n\n  return {\n    dayOfWeek,\n    weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber,\n  };\n};\n\nexport const handleChangeFrequency: PureComputed<\n  [string, string, Date, Action], void\n> = (repeatType, rRule, startDate, action) => {\n  const rruleRepeatType = getRRuleFrequency(repeatType);\n  let nextRRule;\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(\n      rRule,\n      rruleRepeatType,\n      startDate,\n    );\n  }\n  action({ rRule: nextRRule });\n};\n\nexport const handleWeekDaysChange: PureComputed<\n[Partial<Options>, number], void\n> = (options, currentWeekDay) => {\n  const byWeekDay = options.byweekday || [];\n  const index = (byWeekDay as Weekday[]).findIndex(({ weekday }) => weekday === currentWeekDay);\n\n  const isAdded = index === -1;\n\n  if (isAdded) {\n    (byWeekDay as Weekday[]).push(RRULE_DAYS_OF_WEEK[currentWeekDay]);\n  } else if (index > -1) {\n    (byWeekDay as Weekday[]).splice(index, 1);\n  }\n  if (byWeekDay === 0) return { ...options, byweekday: undefined };\n  return { ...options, byweekday: byWeekDay };\n};\n\nexport const getDaysOfWeekArray: PureComputed<[number], Array<number>> = (firstDayOfWeek) => {\n  const firstPart = DAYS_OF_WEEK_ARRAY.filter(\n    dayOfWeek => dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1,\n  );\n  const secondPart = DAYS_OF_WEEK_ARRAY.filter(\n    dayOfWeek => dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1,\n  );\n  return firstDayOfWeek !== 0 ? [...firstPart, ...secondPart] : [...secondPart, ...firstPart];\n};\n\nexport const getDaysOfWeekDates: PureComputed<[number], Array<Date>> = (firstDayOfWeek) => {\n  const firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  const secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return [...firstPart, ...secondPart];\n};\n\nexport const checkMultipleResourceFields: PureComputed<\n  [object, ValidResource[]], object\n> = (resourceFields, resources) => resources.reduce((acc, resource) => {\n  if (!resource.allowMultiple) {\n    return acc;\n  }\n\n  const fieldName = resource.fieldName;\n  const field = resourceFields[fieldName];\n  return {\n    ...acc,\n    [fieldName]: Array.isArray(field) ? field : [field],\n  };\n}, resourceFields);\n","import { PureReducer } from '@devexpress/dx-core';\nimport {\n  AddedAppointmentDataPayload, AppointmentModel, Changes, EditAppointmentPayload,\n} from '../../types';\n\nexport const addAppointment: PureReducer<\n  AppointmentModel, AddedAppointmentDataPayload, AppointmentModel | {}\n> = (\n  addedAppointmentData, { appointmentData } = { appointmentData:  {} },\n) => appointmentData;\n\nexport const cancelAddedAppointment = () => ({});\n\nexport const startEditAppointment: PureReducer<\n  Partial<AppointmentModel>, EditAppointmentPayload\n> = (prevEditingAppointment, appointmentData) => appointmentData;\n\nexport const stopEditAppointment = () => undefined;\n\nexport const changeAppointment: PureReducer<\nAppointmentModel, Changes\n> = (\n  appointment, { change },\n) => ({ ...appointment, ...change });\n\nexport const cancelChanges = () => ({});\n","import { PureComputed } from '@devexpress/dx-core';\nimport { AppointmentId, AppointmentChanges, Changes } from '../../types';\n\nexport const changedAppointmentById: PureComputed<\n  [Changes, AppointmentId], AppointmentChanges\n> = (changes, appointmentId) => (\n  { [appointmentId]: changes }\n);\n","import moment from 'moment';\nimport { RRule, RRuleSet } from 'rrule';\nimport {\n  AppointmentModel, PreCommitChangesFn, Changes, MakeDateSequenceFn, EditFn, DeleteFn, ChangeFn,\n} from '../../types';\nimport { RECURRENCE_EDIT_SCOPE } from '../../constants';\nimport { getUTCDate, getRRuleSetWithExDates, formatDateToString } from '../../utils';\n\nconst mergeNewChanges = (\n  appointmentData: Partial<AppointmentModel>, changes: Changes,\n) => {\n  const appointment = {\n    ...appointmentData,\n  };\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return { ...appointment, ...changes };\n};\n\nconst reduceExDate = (prevExDate: string, boundDate: Date) => {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce((acc: string[], date: string) => {\n      const momentDate = moment.utc(date);\n      if (momentDate.isBefore(boundDate)) {\n        return [...acc, date];\n      }\n      return acc;\n    }, []).join(',');\n  }\n  return undefined;\n};\n\nconst configureExDate = (exDate: string | undefined, date: Date) => {\n  const currentExDate = `${moment.utc(date).format('YYYYMMDDTHHmmss')}Z`;\n  return exDate\n    ? `${exDate},${currentExDate}`\n    : currentExDate;\n};\n\nconst configureDateSequence: MakeDateSequenceFn = (rRule, exDate, prevStartDate, nextStartDate) => {\n  const rruleSet = getRRuleSetWithExDates(exDate);\n\n  const currentOptions = RRule.parseString(rRule as string);\n  const correctedOptions = currentOptions.until\n    ? { ...currentOptions, until: moment(getUTCDate(currentOptions.until)).toDate() }\n    : currentOptions;\n  const prevStartDateUTC = moment(getUTCDate(prevStartDate!)).toDate();\n  rruleSet.rrule(new RRule({\n    ...correctedOptions,\n    dtstart: prevStartDateUTC,\n  }));\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all()\n      // we shouldn't use `new Date(string)` because this function has different results in Safari\n      .map(nextDate => moment(formatDateToString(nextDate)).toDate());\n  }\n  const leftBound = prevStartDateUTC;\n  const rightBound = moment(getUTCDate(nextStartDate!)).toDate();\n  return rruleSet.between(leftBound, rightBound, true)\n    .map(nextDate => moment(formatDateToString(nextDate)).toDate());\n};\n\nconst configureICalendarRules = (rRule: string | undefined, options: object) => {\n  const rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule({\n    ...RRule.parseString(rRule as string),\n    ...options,\n  }));\n  return rruleSet.valueOf();\n};\n\nconst changeCurrentAndFollowing: ChangeFn = (appointmentData, changes, changeAllAction) => {\n  const { rRule, startDate, parentData, exDate: prevExDate = '', id } = appointmentData;\n\n  const { initialSequence, currentChildIndex } = getAppointmentSequenceData(\n    parentData.startDate, moment.utc(startDate as Date).toDate(), prevExDate, rRule,\n  );\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n\n  const changedRules = configureICalendarRules(rRule as string, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null,\n  });\n\n  const nextExDate = reduceExDate(prevExDate, startDate as Date);\n  return {\n    changed: {\n      [id!]: {\n        rRule: changedRules[1].slice(6),\n        ...nextExDate && prevExDate !== nextExDate ? { exDate: nextExDate } : {},\n      },\n    },\n  };\n};\n\nconst getAppointmentSequenceData = (\n  prevStartDate: Date, startDate: Date, exDate: string, rRule: string | undefined,\n) => {\n  const initialSequence: Date[] = configureDateSequence(rRule, exDate,\n    moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate(),\n  );\n  const currentChildIndex = initialSequence\n    .findIndex(date => moment(date).isSame(startDate as Date));\n  return { initialSequence, currentChildIndex };\n};\n\nexport const deleteCurrent: DeleteFn = (appointmentData) => {\n  const currentSequence: Date[] = configureDateSequence(\n    appointmentData.rRule, appointmentData.exDate,\n    moment.utc(appointmentData.parentData.startDate).toDate(),\n    moment.utc(appointmentData.startDate).toDate(),\n  );\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  const nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate as Date);\n  return { changed: { [appointmentData.id!]: { exDate: nextExDate } } };\n};\n\nexport const deleteAll: DeleteFn = (appointmentData) => {\n  return { deleted: appointmentData.id };\n};\n\nexport const deleteCurrentAndFollowing: DeleteFn = appointmentData => changeCurrentAndFollowing(\n  appointmentData, {}, deleteAll,\n);\n\nexport const editAll: EditFn = (appointmentData, changes) => {\n  const { rRule, id } = appointmentData;\n\n  const initialRule = new RRule(RRule.parseString(rRule as string));\n  if (changes.startDate\n    && moment.utc(changes.startDate as Date).isAfter(initialRule.options.until!)) {\n    return {\n      changed: {\n        [id!]: {\n          ...changes,\n          rRule: 'FREQ=DAILY;COUNT=1',\n          exDate: '',\n        },\n      },\n    };\n  }\n\n  return  { changed: {  [appointmentData.id!]: changes } };\n};\n\nexport const editCurrent: EditFn = (appointmentData, changes) => ({\n  changed: {\n    [appointmentData.id!]: {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate as Date),\n    },\n  },\n  added: mergeNewChanges(appointmentData as Partial<AppointmentModel>, changes as Changes),\n});\n\nexport const editCurrentAndFollowing: EditFn = (appointmentData, changes) => {\n  const { rRule, startDate, exDate: prevExDate = '', parentData } = appointmentData;\n  const initialRule = new RRule(RRule.parseString(rRule as string));\n\n  const { initialSequence, currentChildIndex } = getAppointmentSequenceData(\n    parentData.startDate, moment.utc(startDate as Date).toDate(),  prevExDate, rRule,\n  );\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n\n  const addedOptions = initialRule.options.count || initialRule.options.until\n    ? { count: initialSequence.length - currentChildIndex }\n    : {};\n  const addedRules = configureICalendarRules(appointmentData.rRule as string, {\n    dtstart: moment.utc(startDate as Date).toDate(),\n    ...addedOptions,\n  });\n\n  const addedAppointment = moment.utc(changes.startDate as Date).isAfter(initialRule.options.until!)\n    ? { rRule: 'FREQ=DAILY;COUNT=1', exDate: '' } : { rRule: addedRules[1].slice(6) };\n\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: {\n      ...addedAppointment, ...mergeNewChanges(appointmentData, changes),\n    },\n  };\n};\n\nexport const preCommitChanges: PreCommitChangesFn = (\n  changes, appointmentData, editType,\n) => {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL: {\n        return deleteAll(appointmentData);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT: {\n        return deleteCurrent(appointmentData);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {\n        return deleteCurrentAndFollowing(appointmentData);\n      }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL: {\n        return editAll(appointmentData, changes);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT: {\n        return editCurrent(appointmentData, changes);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {\n        return editCurrentAndFollowing(appointmentData, changes);\n      }\n    }\n  }\n  return {};\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  ViewCell, ClientOffset, TimeType, ScrollingStrategy,\n  AllDayCell, CalculateAppointmentTimeBoundaries,\n  TimeBoundariesByDrag, TimeBoundariesByResize, AppointmentModel,\n  CellElementsMeta, Grouping, ValidResource, Group, SchedulerDateTime, GroupOrientation,\n} from '../../types';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE, SCROLL_OFFSET, MINUTES,\n  SECONDS, RESIZE_TOP, RESIZE_BOTTOM, HOURS,\n} from '../../constants';\nimport {\n  allDayRects, horizontalTimeTableRects, verticalTimeTableRects,\n} from '../common/calculate-rects';\n\nconst clamp: PureComputed<\n  [number, number, number]\n> = (value, min, max) => Math.max(Math.min(value, max), min);\n\nconst calculateInsideOffset: PureComputed<\n  [string, number, number], number\n> = (targetType, insidePart, cellDurationMinutes) => targetType === VERTICAL_TYPE\n  ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n\nexport const cellType: PureComputed<\n  [ViewCell | AllDayCell], string\n> = data => moment(data.startDate as Date)\n  .isSame(data.endDate as Date, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n\nexport const intervalDuration: PureComputed<\n  [ViewCell | AllDayCell, TimeType], number\n> = (data, type) => moment(data.endDate as Date).diff(data.startDate as Date, type);\n\nexport const cellIndex: PureComputed<\n  [Array<() => ClientRect>, ClientOffset], number\n> = (getCellRects, clientOffset) => getCellRects.findIndex((getCellRect) => {\n  const { left, top, right, bottom } = getCellRect();\n  const isOver = clientOffset\n      && clamp(clientOffset.x, left, right) === clientOffset.x\n      && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n  return isOver;\n});\n\nexport const cellData: PureComputed<\n  [number, number, ViewCell[][], ViewCell[][]], ViewCell | AllDayCell\n> = (timeTableIndex, allDayIndex, viewCellsData, allDayCellsData) => {\n  const cellsData = allDayIndex !== -1 ? allDayCellsData : viewCellsData;\n  const currentIndex = allDayIndex !== -1 ? allDayIndex : timeTableIndex;\n  const tableWidth = cellsData[0].length;\n\n  const rowIndex = Math.floor(currentIndex / tableWidth);\n  const columnIndex = currentIndex % tableWidth;\n  return cellsData[rowIndex][columnIndex];\n};\n\nexport const autoScroll: PureComputed<\n  [ClientOffset, ScrollingStrategy, number], void\n> = (clientOffset, scrollingStrategy, scrollSpeed) => {\n  scroll(\n    clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary,\n    scrollingStrategy.changeVerticalScroll, scrollSpeed,\n  );\n  scroll(\n    clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary,\n    scrollingStrategy.changeHorizontalScroll, scrollSpeed,\n  );\n};\n\nconst scroll: PureComputed<\n  [number, number, number, (value: number) => void, number], void\n> = (offset, firstBoundary, secondBoundary, changeScroll, scrollSpeed) => {\n  if ((offset < firstBoundary + SCROLL_OFFSET) && (offset > firstBoundary)) {\n    changeScroll(-scrollSpeed);\n  }\n  if (secondBoundary - SCROLL_OFFSET < offset) {\n    changeScroll(+scrollSpeed);\n  }\n};\n\nexport const timeBoundariesByResize: TimeBoundariesByResize = (\n  payload, targetData, targetType, cellDurationMinutes, insidePart,\n) => {\n  if (targetType !== payload.appointmentType) {\n    return { appointmentStartTime: undefined, appointmentEndTime: undefined };\n  }\n\n  let appointmentStartTime;\n  let appointmentEndTime;\n  const sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    const insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate as Date)\n      .add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate as Date).toDate();\n  }\n  if (sourceType === RESIZE_BOTTOM) {\n    const insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE\n      ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate as Date)\n      .add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate as Date).toDate();\n  }\n  // keep origin appointment duration if coordinates are wrong\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate as Date).toDate();\n    appointmentEndTime = moment(payload.endDate as Date).toDate();\n  }\n  return { appointmentStartTime, appointmentEndTime };\n};\n\nexport const timeBoundariesByDrag: TimeBoundariesByDrag = (\n  payload, targetData, targetType,\n  cellDurationMinutes, insidePart, offsetTimeTopBase,\n) => {\n  if (targetType === HORIZONTAL_TYPE\n    && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate as Date,\n      appointmentEndTime: targetData.endDate as Date,\n      offsetTimeTop: 0,\n    };\n  }\n  let offsetTimeTop;\n  let appointmentStartTime;\n  let appointmentEndTime;\n\n  const insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  const start = moment(targetData.startDate as Date).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate as Date)\n      .diff(payload.startDate as Date, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    const appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add((offsetTimeTop) * (-1), SECONDS).toDate();\n    appointmentEndTime = moment(start)\n      .add((appointmentDurationSeconds - offsetTimeTop), SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate as Date)\n      .add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate as Date).add(insideOffset, SECONDS).toDate();\n  }\n\n  return { appointmentStartTime, appointmentEndTime, offsetTimeTop };\n};\n\nexport const calculateAppointmentTimeBoundaries: CalculateAppointmentTimeBoundaries = (\n  payload, targetData, targetType,\n  cellDurationMinutes, insidePart, offsetTimeTopBase,\n) => {\n  const isDragging = (payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE);\n\n  return(isDragging\n    ? timeBoundariesByDrag(\n        payload, targetData as AppointmentModel, targetType,\n        cellDurationMinutes, insidePart, offsetTimeTopBase,\n      )\n    : timeBoundariesByResize(\n        payload, targetData as AppointmentModel, targetType, cellDurationMinutes, insidePart,\n      )\n  );\n};\n\nexport const calculateInsidePart: PureComputed<\n  [number, Array<() => ClientRect>, number]\n> = (top, timeTableCellsRects, timeTableIndex) => {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    const cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n  return 0;\n};\n\nexport const calculateDraftAppointments = (\n  allDayIndex: number, draftAppointments: any, startViewDate: Date,\n  endViewDate: Date, excludedDays: number[], viewCellsData: any,\n  getAllDayCellsElementRects: CellElementsMeta,\n  targetType: string, cellDurationMinutes: number,\n  getTableCellElementRects: CellElementsMeta,\n  grouping: Grouping[], resources: ValidResource[], groups: Group[][],\n  groupOrientation: GroupOrientation, groupedByDate: boolean,\n) => {\n  if (allDayIndex !== -1 || (targetType === VERTICAL_TYPE\n    && getAllDayCellsElementRects.getCellRects.length\n    && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23)) {\n    const allDayDrafts = draftAppointments.map((draftAppt: any) => ({\n      ...draftAppt,\n      allDay: true,\n    }));\n\n    return {\n      allDayDraftAppointments: allDayRects(\n        allDayDrafts, startViewDate, endViewDate,\n        excludedDays, viewCellsData, getAllDayCellsElementRects,\n        grouping, resources, groups, groupOrientation, groupedByDate,\n      ),\n      timeTableDraftAppointments: [],\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(\n        draftAppointments, startViewDate, endViewDate,\n        excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects,\n        grouping, resources, groups, groupOrientation, groupedByDate,\n      ),\n    };\n  }\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(\n      draftAppointments, startViewDate, endViewDate,\n      viewCellsData, getTableCellElementRects,\n      grouping, resources, groups, groupOrientation, groupedByDate,\n    ),\n  };\n};\n\nexport const calculateAppointmentGroups: PureComputed<\n  [Array<Group> | undefined, Array<ValidResource>, AppointmentModel], any\n> = (cellGroupingInfo, resources, appointmentData) => {\n  if (!cellGroupingInfo) return {};\n  return cellGroupingInfo.reduce((acc, group: Group) => {\n    const isMultipleResource = resources.find(\n      resource => (resource.fieldName === group.fieldName),\n    )!.allowMultiple;\n    return {\n      ...acc,\n      [group.fieldName]: isMultipleResource\n        ? updateMultipleResourceInfo(group, appointmentData) : group.id,\n    };\n  }, {});\n};\n\nconst updateMultipleResourceInfo: PureComputed<\n  [Group, AppointmentModel], any\n> = (cellResource, appointmentData) => {\n  const appointmentGroupItems = appointmentData[cellResource.fieldName];\n  if (appointmentGroupItems.findIndex((groupItem: any) => groupItem === cellResource.id) !== -1) {\n    return appointmentGroupItems;\n  }\n  return [cellResource.id];\n};\n\nexport const appointmentDragged: PureComputed<\n  [SchedulerDateTime, SchedulerDateTime, SchedulerDateTime, SchedulerDateTime, any, any], boolean\n> = (start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) => {\n  if (moment(start as Date).isSame(startPrev as Date)\n      && moment(end as Date).isSame(endPrev as Date)\n      && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {\n    return false;\n  }\n  return true;\n};\n\nconst groupingInfoNotChanged: PureComputed<\n  [any, any], boolean\n> = (groupingInfo, groupingInfoPrev) => {\n  const fields = Object.getOwnPropertyNames(groupingInfo);\n  return fields.every((field) => {\n    if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {\n      return groupingInfo[field].every((item: any, index: number) => (\n        item === groupingInfoPrev[field][index]\n      ));\n    }\n    return groupingInfo[field] === groupingInfoPrev[field];\n  });\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport moment from 'moment';\nimport {\n  IsCellShadedFn, IsShadedAppointment,\n  GetCurrentTimeIndicatorTopFn,\n} from '../../types';\n\nexport const isMonthCell: PureComputed<\n  [boolean | undefined], boolean\n> = otherMonth => otherMonth !== undefined;\n\nexport const isShadedAppointment: IsShadedAppointment = (\n  { data: appointmentData }, currentTime, shadePreviousAppointments,\n) => {\n  const momentCurrentDate = moment(currentTime);\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate as Date, 'day')\n    && shadePreviousAppointments;\n  }\n  if (momentCurrentDate.isAfter(appointmentData.endDate as Date)) {\n    return shadePreviousAppointments;\n  }\n  return false;\n};\n\nexport const getCurrentTimeIndicatorTop: GetCurrentTimeIndicatorTopFn = (\n  cellData, currentTime,\n) => {\n  const top = ((currentTime - cellData.startDate.getTime()) * 100)\n  / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return (top < 0 || top > 100) ? undefined : `${top}%`;\n};\n\nexport const isCellShaded: IsCellShadedFn = (\n  { startDate, endDate, otherMonth }, currentTime, shadePreviousCells,\n) => {\n  const monthCell = isMonthCell(otherMonth);\n  return ((startDate.getTime() < currentTime && !monthCell)\n    || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n","import { GetAppointmentResources, ValidResourceInstance, ValidResource } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const getAppointmentResources: GetAppointmentResources = (\n  appointment, resources, plainResources,\n) => {\n  if (\n    !resources || resources.length === 0\n    || !plainResources || plainResources.length === 0\n  ) return [];\n\n  return resources.reduce((acc, resource) => {\n    const appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId)\n    || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return [\n        ...acc,\n        ...(appointmentResourceId as Array<number | string>)\n        .reduce((prevResources, itemId) => addResourceToAppointmentResources(\n          plainResources, prevResources, resource, itemId,\n        ) as Array<ValidResourceInstance>, [] as Array<ValidResourceInstance>),\n      ];\n    }\n\n    return addResourceToAppointmentResources(\n      plainResources, acc, resource, appointmentResourceId,\n    ) as Array<ValidResourceInstance>;\n  }, [] as Array<ValidResourceInstance>);\n};\n\nconst addResourceToAppointmentResources: PureComputed<\n  [Array<ValidResourceInstance>, Array<ValidResourceInstance>, ValidResource,\n  number | string], Array<ValidResourceInstance>\n> = (plainResources, appointmentResources, resource, resourceId) => {\n  const currentResource = plainResources.find(\n    plainItem => resource.fieldName === plainItem.fieldName && plainItem.id === resourceId,\n  );\n\n  return currentResource ? [\n    ...appointmentResources,\n    currentResource!,\n  ] : appointmentResources;\n};\n","import {\n  ConvertResourcesToPlain, ValidateResources, ValidResourceInstance, AddResourcesToAppointments,\n} from '../../types';\nimport { getAppointmentResources } from './helpers';\n\nexport const convertResourcesToPlain: ConvertResourcesToPlain = (validResources) => {\n  return validResources.reduce((acc, resource) => [\n    ...acc,\n    ...resource.instances.map(item => item),\n  ], [] as Array<ValidResourceInstance>);\n};\n\nexport const validateResources: ValidateResources = (resources, mainResourceName, palette) => {\n  const isMainResourceDefined = !!mainResourceName;\n  let currentPaletteIndex = 0;\n  return resources.map((resource, groupIndex) => {\n    const fieldName = resource.fieldName;\n    const isMain = isMainResourceDefined && mainResourceName === fieldName\n      || groupIndex === 0 && !isMainResourceDefined;\n    const title = resource.title || fieldName;\n    const allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName,\n      isMain,\n      title,\n      allowMultiple,\n      instances: resource.instances.map((resourceItem) => {\n        const color = resourceItem.color || palette[currentPaletteIndex % palette.length];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n\n        return ({\n          id: resourceItem.id,\n          color,\n          fieldName,\n          text: resourceItem.text || title || fieldName,\n          title,\n          allowMultiple,\n          isMain,\n        });\n      }),\n    };\n  });\n};\n\nexport const addResourcesToAppointments: AddResourcesToAppointments = (\n  appointments, resources, plainResources,\n) => [\n  appointments.map(appointment => ({\n    ...appointment,\n    resources: getAppointmentResources(appointment.dataItem, resources, plainResources),\n  })),\n];\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport {\n  ResourceGroupingState, ToggleGroupPayload,\n} from '../../types';\n\nexport const toggleExpandedGroups: PureReducer<ResourceGroupingState, ToggleGroupPayload> = (\n  state, { groupKey },\n) => {\n  const expandedGroups = slice(state.expandedGroups);\n  const groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return { expandedGroups };\n};\n","import moment, { Moment } from 'moment';\nimport { ViewCell } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const getDayScaleCellColSpan: PureComputed<\n  [ViewCell[][]], number\n> = (cellsData) => {\n  const firstDate = cellsData[0][0].startDate;\n  let count = 1;\n  while (cellsData[0][count] && moment(cellsData[0][count].startDate).isSame(firstDate, 'day')) {\n    count += 1;\n  }\n  return count;\n};\n\nexport const getDayScaleCells: PureComputed<\n[ViewCell[][], boolean], ViewCell[]\n> = (cellsData, groupedByDate) => {\n  if (!groupedByDate) {\n    return cellsData[0].map(({\n      startDate, endDate, today, endOfGroup, groupingInfo,\n    }, index) => ({\n      key: index.toString(),\n      startDate, endDate, today, endOfGroup, groupingInfo,\n    }));\n  }\n  let prevDate: Moment;\n  const colSpan = getDayScaleCellColSpan(cellsData);\n  return cellsData[0].reduce((acc, { startDate, endDate, today }, index) => {\n    const currentDate = moment(startDate);\n    if (currentDate.isSame(prevDate)) {\n      return acc;\n    }\n    prevDate = currentDate;\n    return [\n      ...acc, {\n        key: index.toString(),\n        startDate, endDate, today, colSpan,\n        endOfGroup: true,\n      },\n    ];\n  }, [] as ViewCell[]);\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { SchedulerDateTime } from '../../types';\nimport moment from 'moment';\n\nexport const navigateByOneMonth: PureComputed<\n  [SchedulerDateTime, boolean], Date\n> = (currentDate, isBackward) => moment(currentDate as SchedulerDateTime)\n  [isBackward ? 'subtract' : 'add'](1, 'month').toDate();\n","import { AppointmentModel, SchedulerDateTime } from './scheduler-core.types';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { RRULE_REPEAT_TYPES } from '../plugins/appointment-form/constants';\n\n/** @internal */\nexport type Action = ([fieldName]?: any) => void;\n/** @internal */\nexport type StartDate = SchedulerDateTime;\n/** @internal */\nexport type EndDate = SchedulerDateTime;\n/** @internal */\nexport type AppointmentDataPayload = {\n  appointmentData: AppointmentModel;\n};\n/** @internal */\nexport type AddedAppointmentDataPayload = {\n  appointmentData: AppointmentModel | {};\n};\n/** @internal */\nexport type RadioGroupDisplayData = {\n  weekNumber: number;\n  dayNumberTextField: number;\n  dayOfWeek: number;\n  radioGroupValue: string;\n};\n/** An option in the Select editor. */\nexport type SelectOption = {\n  /** The option's text. */\n  text: string;\n  /** The option's id. */\n  id: number | string;\n};\n/** @internal */\nexport type OptionsFormatterFn = PureComputed<\n  [(messageKey: string) => string], Array<SelectOption>\n>;\n/** @internal */\nexport type DateFormatterFn = PureComputed<\n  [(date: Date, formatOptions: object) => string], Array<SelectOption>\n>;\n/** @internal */\nexport enum RecurrenceFrequency {\n  Daily = RRULE_REPEAT_TYPES.DAILY,\n  Weekly = RRULE_REPEAT_TYPES.WEEKLY,\n  Monthly = RRULE_REPEAT_TYPES.MONTHLY,\n  Yearly = RRULE_REPEAT_TYPES.YEARLY,\n}\n"]},"metadata":{},"sourceType":"module"}