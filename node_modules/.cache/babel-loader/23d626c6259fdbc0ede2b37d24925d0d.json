{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-scheduler-core\n * Generated: 2021-06-24\n * Version: 2.7.6\n * License: https://js.devexpress.com/Licensing\n */\nimport moment from 'moment';\nimport { RRuleSet, RRule } from 'rrule';\nimport { slice } from '@devexpress/dx-core';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n/** @deprecated */\n\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nvar computed = function computed(getters, viewName, baseComputed, defaultValue) {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n\n  return baseComputed(getters, viewName);\n};\n\nvar toPercentage = function toPercentage(value, total) {\n  return value * 100 / total;\n};\n\nvar createExcludedInterval = function createExcludedInterval(day, start) {\n  var leftBound = moment(start.day(day));\n  return [leftBound, moment(leftBound).hour(start.hour()).endOf('day')];\n};\n\nvar excludedIntervals = function excludedIntervals(excludedDays, start) {\n  return excludedDays.map(function (day) {\n    return day === 0 ? 7 : day;\n  }).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, day, i, allDays) {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[acc.length - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n\n    return acc;\n  }, []);\n};\n\nvar inInterval = function inInterval(date, interval) {\n  return date.isBetween(interval[0], interval[1], undefined, '[]');\n};\n\nvar viewPredicate = function viewPredicate(appointment, left, right, excludedDays, removeAllDayAppointments) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  if (removeAllDayAppointments === void 0) {\n    removeAllDayAppointments = false;\n  }\n\n  var start = appointment.start,\n      end = appointment.end;\n  var isAppointmentInBoundary = end.isAfter(left) && start.isBefore(right);\n  var isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left)).find(function (interval) {\n    return inInterval(start, interval) && inInterval(end, interval);\n  });\n  var considerAllDayAppointment = removeAllDayAppointments ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay : true;\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nvar calculateFirstDateOfWeek = function calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: {\n      dow: firstDayOfWeek,\n      doy: 1\n    }\n  });\n  var firstDateOfWeek = moment(currentDate).startOf('week');\n\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach(function (day) {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n\n  moment.locale(currentLocale);\n  return firstDateOfWeek.toDate();\n};\n\nvar getAppointmentStyle = function getAppointmentStyle(_a) {\n  var top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n  return {\n    height: height,\n    width: width + \"%\",\n    transform: \"translateY(\" + top + \"px)\",\n    msTransform: \"translateY(\" + top + \"px)\",\n    left: left + \"%\",\n    position: 'absolute'\n  };\n};\n\nvar expandRecurrenceAppointment = function expandRecurrenceAppointment(appointment, leftBound, rightBound) {\n  var rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  var leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  var appointmentStartDate = moment(appointment.start).toDate();\n\n  var options = _assign(_assign({}, RRule.parseString(appointment.rRule)), {\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate()\n  });\n\n  var correctedOptions = options.until ? _assign(_assign({}, options), {\n    until: moment(getUTCDate(options.until)).toDate()\n  }) : options;\n  var rruleSet = getRRuleSetWithExDates(appointment.exDate);\n  rruleSet.rrule(new RRule(correctedOptions)); // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n\n  var datesInBoundaries = rruleSet.between(leftBoundUTC, rightBoundUTC, true).map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n  var appointmentDuration = moment(appointment.end).diff(appointment.start, 'minutes');\n  return datesInBoundaries.map(function (startDate, index) {\n    return _assign(_assign({}, appointment), {\n      dataItem: _assign(_assign({}, appointment.dataItem), {\n        startDate: moment(startDate).toDate(),\n        endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n        parentData: appointment.dataItem\n      }),\n      start: moment(startDate),\n      end: moment(startDate).add(appointmentDuration, 'minutes'),\n      key: appointment.key + \"_rec_\" + index\n    });\n  });\n};\n\nvar filterByViewBoundaries = function filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, removeAllDay) {\n  var appointments = [appointment];\n\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(appointment, leftBound, rightBound);\n  }\n\n  return appointments.filter(function (appt) {\n    return viewPredicate(appt, leftBound, rightBound, excludedDays, removeAllDay);\n  });\n};\n\nvar getUTCDate = function getUTCDate(date) {\n  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());\n};\n\nvar getRRuleSetWithExDates = function getRRuleSetWithExDates(exDate) {\n  var rruleSet = new RRuleSet();\n\n  if (exDate) {\n    exDate.split(',').map(function (date) {\n      var currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n\n  return rruleSet;\n};\n\nvar formatDateToString = function formatDateToString(date) {\n  return moment.utc(date).format('YYYY-MM-DDTHH:mm');\n};\n\nvar addDateToKey = function addDateToKey(prevKey, momentDate) {\n  return prevKey + \"_\" + momentDate.toDate().toString();\n};\n\nvar VERTICAL_TYPE = 'vertical';\nvar HORIZONTAL_TYPE = 'horizontal';\nvar SCROLL_OFFSET = 50;\nvar SCROLL_SPEED_PX = 15;\nvar SECONDS = 'seconds';\nvar MINUTES = 'minutes';\nvar HOURS = 'hours';\nvar RESIZE_TOP = 'resize-start';\nvar RESIZE_BOTTOM = 'resize-end';\nvar POSITION_START = 'start';\nvar POSITION_END = 'end';\nvar AUTO_HEIGHT = 'auto';\nvar DAY_OPTIONS = {\n  day: 'numeric'\n};\nvar WEEK_DAY_OPTIONS = {\n  weekday: 'short'\n};\nvar SHORT_MONTH_OPTIONS = {\n  month: 'short'\n};\nvar HOUR_MINUTE_OPTIONS = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\nvar MONTH_YEAR_OPTIONS = {\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'short'\n};\nvar SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  month: 'short',\n  year: 'numeric'\n};\nvar SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  month: 'short',\n  year: '2-digit'\n};\nvar DAY_LONG_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: '2-digit'\n};\nvar LONG_WEEK_DAY_OPTIONS = {\n  weekday: 'long'\n};\nvar LONG_MONTH_OPTIONS = {\n  month: 'long'\n};\nvar DAY_LONG_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'long'\n};\nvar EMPTY_OPTIONS = {};\nvar RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current'\n};\nvar TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nvar TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\nvar WEEKDAY_INTERVAL = 'weekdayInterval';\nvar VERTICAL_VIEW_LEFT_OFFSET = 80;\nvar HORIZONTAL_VIEW_LEFT_OFFSET = 0;\nvar VERTICAL_GROUP_ORIENTATION = 'Vertical';\nvar HORIZONTAL_GROUP_ORIENTATION = 'Horizontal';\nvar VIEW_TYPES = {\n  MONTH: 'month',\n  WEEK: 'week',\n  DAY: 'day',\n  ALL_DAY_PANEL: 'allDayPanel'\n};\nvar MONTH_TYPE = 'month';\n\nvar getViewType = function getViewType(currentViewType) {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nvar isMidnight = function isMidnight(date) {\n  var momentDate = moment(date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nvar calculateTextByDays = function calculateTextByDays(startViewDate, endViewDate, formatDate, additionalOptions) {\n  var momentStartViewDate = moment(startViewDate);\n  var momentEndViewDate = moment(endViewDate);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), _assign(_assign({}, DAY_LONG_MONTH_LONG_YEAR_OPTIONS), additionalOptions));\n  }\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return formatDate(momentStartViewDate.toDate(), DAY_OPTIONS) + \"-\" + formatDate(momentEndViewDate.toDate(), DAY_OPTIONS) + \" \" + formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS);\n    }\n\n    return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar calculateTextByMonths = function calculateTextByMonths(currentDate, intervalCount, formatDate) {\n  var momentCurrentDate = moment(currentDate);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n\n  var lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS) + \"-\" + formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar viewBoundText = function viewBoundText(startViewDate, endViewDate, type, currentDate, intervalCount, formatDate) {\n  return type !== 'month' ? calculateTextByDays(startViewDate, endViewDate, formatDate, type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS) : calculateTextByMonths(currentDate, intervalCount, formatDate);\n};\n\nvar checkCellGroupingInfo = function checkCellGroupingInfo(cell, appointment) {\n  return cell.groupingInfo ? cell.groupingInfo.every(function (group) {\n    return group.id === appointment[group.fieldName];\n  }) : true;\n};\n\nvar isDateValid = function isDateValid(date) {\n  return moment(date).isValid();\n};\n\nvar convertToMoment = function convertToMoment(date) {\n  return moment(date);\n};\n\nvar areDatesSame = function areDatesSame(firstDate, secondDate) {\n  return moment(firstDate).isSame(secondDate, 'date');\n};\n\nvar getTimeTableHeight = function getTimeTableHeight(timeTableElementsMeta) {\n  var _a;\n\n  return (_a = timeTableElementsMeta.parentRect) === null || _a === void 0 ? void 0 : _a.call(timeTableElementsMeta).height;\n};\n\nvar containsDSTChange = function containsDSTChange(date) {\n  var momentDate = moment(date);\n  momentDate.startOf('day');\n  var isStartDST = momentDate.isDST();\n  momentDate.endOf('day');\n  var isEndDst = momentDate.isDST();\n  return isStartDST && !isEndDst || !isStartDST && isEndDst;\n};\n\nvar subtractSecond = function subtractSecond(date) {\n  return moment(date).subtract(1, 'second').toDate();\n};\n\nvar dayScale = function dayScale(currentDate, firstDayOfWeek, dayCount, excluded) {\n  if (excluded === void 0) {\n    excluded = [];\n  }\n\n  var result = [];\n  var date = firstDayOfWeek !== undefined ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded)) : moment(currentDate);\n\n  for (var index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(function (item) {\n      return item === date.day();\n    }) === -1) {\n      result.push(date.toDate());\n    }\n\n    date.add(1, 'days');\n  }\n\n  return result;\n};\n\nvar timeScale = function timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays) {\n  var result = [];\n  var startDateOfView = firstDayOfWeek !== undefined ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) : currentDate;\n  var isDSTChange = containsDSTChange(startDateOfView);\n  var validDate = moment(startDateOfView);\n\n  if (isDSTChange) {\n    validDate.subtract(1, 'day');\n  }\n\n  var left = moment(validDate).startOf('day').add(startDayHour, 'hour');\n  var right = moment(validDate).startOf('day').add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    var startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({\n      start: startDate,\n      end: left.toDate()\n    });\n  }\n\n  var timeScaleLastIndex = result.length - 1;\n\n  if (isMidnight(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end);\n  }\n\n  return result;\n};\n\nvar availableViews = function availableViews(views, viewName, viewDisplayName) {\n  if (!views) return [{\n    name: viewName,\n    displayName: viewDisplayName\n  }];\n\n  if (views.findIndex(function (view) {\n    return viewName === view.name;\n  }) === -1) {\n    var nextViews = views.slice();\n    nextViews.push({\n      name: viewName,\n      displayName: viewDisplayName\n    });\n    return nextViews;\n  }\n\n  return views;\n};\n\nvar viewCellsData = function viewCellsData(currentDate, firstDayOfWeek, dayCount, excludedDays, startDayHour, endDayHour, cellDuration, currTime) {\n  var days = dayScale(currentDate, firstDayOfWeek, dayCount, excludedDays);\n  var times = timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays);\n  var currentTime = moment(currTime);\n  return times.reduce(function (cellsAcc, time) {\n    var start = moment(time.start);\n    var end = moment(time.end);\n    var rowCells = days.reduce(function (rowAcc, day) {\n      var startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      var endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      var today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({\n        startDate: startDate,\n        endDate: endDate,\n        today: today\n      });\n      return rowAcc;\n    }, []);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, []);\n};\n\nvar timeCellsData = function timeCellsData(cellsData, startDayHour, endDayHour, cellDuration, currentTime) {\n  var firstViewDate = cellsData[0][0].startDate;\n\n  if (!containsDSTChange(firstViewDate)) {\n    return cellsData;\n  }\n\n  var nextDay = moment(firstViewDate).add(1, 'day').toDate();\n  var validCellsData = viewCellsData(nextDay, undefined, 1, [], startDayHour, endDayHour, cellDuration, currentTime);\n  return validCellsData;\n};\n\nvar allDayCells = function allDayCells(viewCells) {\n  return [viewCells[0].map(function (cell) {\n    return {\n      startDate: moment(cell.startDate).startOf('day').toDate(),\n      endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),\n      groupingInfo: cell.groupingInfo,\n      endOfGroup: cell.endOfGroup\n    };\n  })];\n};\n\nvar startViewDate = function startViewDate(viewCells) {\n  return moment(viewCells[0][0].startDate).toDate();\n};\n\nvar endViewDate = function endViewDate(viewCells) {\n  var lastRowIndex = viewCells.length - 1;\n  var lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate);\n};\n\nvar MAX_WIDTH = 1;\nvar INDIRECT_CHILD_LEFT_OFFSET = 0.05;\n\nvar isAllDayElementsMetaActual = function isAllDayElementsMetaActual(viewCellsData, allDayElementsMeta, groupOrientation, groupCount) {\n  var numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;\n  return isElementsMetaActual(viewCellsData, allDayElementsMeta, numberOfRows);\n};\n\nvar isTimeTableElementsMetaActual = function isTimeTableElementsMetaActual(viewCellsData, timeTableElementsMeta) {\n  return isElementsMetaActual(viewCellsData, timeTableElementsMeta, viewCellsData.length);\n};\n\nvar isElementsMetaActual = function isElementsMetaActual(viewCellsData, elementsMeta, numberOfRows) {\n  if (!(elementsMeta === null || elementsMeta === void 0 ? void 0 : elementsMeta.getCellRects)) {\n    return false;\n  }\n\n  var tableSize = numberOfRows * viewCellsData[0].length;\n  return tableSize === elementsMeta.getCellRects.length;\n};\n\nvar appointmentHeightType = function appointmentHeightType(appointment, cellDuration) {\n  var durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nvar horizontalRectCalculator = function horizontalRectCalculator(appointment, viewMetaData, _a) {\n  var getRectByAppointment = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      cellElementsMeta = _b.cellElementsMeta,\n      viewCellsData = _b.viewCellsData;\n\n  var _c = getRectByAppointment(appointment, viewMetaData, {\n    multiline: multiline,\n    cellElementsMeta: cellElementsMeta,\n    viewCellsData: viewCellsData\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  return {\n    resources: appointment.resources,\n    top: top + height / appointment.reduceValue * appointment.offset,\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE,\n    key: appointment.key\n  };\n};\n\nvar verticalRectCalculator = function verticalRectCalculator(appointment, viewMetaData, _a) {\n  var getRectByAppointment = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      viewCellsData = _b.viewCellsData,\n      cellDuration = _b.cellDuration,\n      cellElementsMeta = _b.cellElementsMeta,\n      excludedDays = _b.excludedDays;\n\n  var _c = getRectByAppointment(appointment, viewMetaData, {\n    multiline: multiline,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    excludedDays: excludedDays,\n    cellElementsMeta: cellElementsMeta\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  var offset = appointment.offset,\n      relativeWidth = appointment.width,\n      relativeLeft = appointment.left;\n  var widthMultiplier = relativeWidth * 5 / 3 + relativeLeft <= 1 ? 5 / 3 : 1;\n  var validWidth = widthMultiplier === 5 / 3 ? widthMultiplier * relativeWidth : relativeWidth + 0.02;\n\n  if (validWidth + relativeLeft > 1) {\n    validWidth = 1 - relativeLeft;\n  }\n\n  return {\n    resources: appointment.resources,\n    top: top,\n    height: height,\n    left: toPercentage(left + relativeLeft * width, parentWidth),\n    width: toPercentage(validWidth * width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    offset: offset,\n    key: appointment.key\n  };\n};\n\nvar oldVerticalRectCalculator = function oldVerticalRectCalculator(appointment, viewMetaData, _a) {\n  var getRectByAppointment = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      viewCellsData = _b.viewCellsData,\n      cellDuration = _b.cellDuration,\n      cellElementsMeta = _b.cellElementsMeta,\n      excludedDays = _b.excludedDays,\n      placeAppointmentsNextToEachOther = _b.placeAppointmentsNextToEachOther;\n\n  var _c = getRectByAppointment(appointment, viewMetaData, {\n    multiline: multiline,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    excludedDays: excludedDays,\n    cellElementsMeta: cellElementsMeta,\n    placeAppointmentsNextToEachOther: placeAppointmentsNextToEachOther\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  var widthInPx = width / appointment.reduceValue;\n  return {\n    resources: appointment.resources,\n    top: top,\n    height: height,\n    left: toPercentage(left + widthInPx * appointment.offset, parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    key: appointment.key\n  };\n};\n\nvar compareByDay = function compareByDay(first, second) {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nvar compareByAllDay = function compareByAllDay(first, second) {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nvar compareByTime = function compareByTime(first, second) {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nvar sortAppointments = function sortAppointments(appointments) {\n  return appointments.slice().sort(function (a, b) {\n    return compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b);\n  });\n};\n\nvar byDayPredicate = function byDayPredicate(boundary, date) {\n  return boundary.isSameOrAfter(date, 'day') && !boundary.isSame(boundary.clone().startOf('day'));\n};\n\nvar findOverlappedAppointments = function findOverlappedAppointments(sortedAppointments, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  var appointments = sortedAppointments.slice();\n  var groups = [];\n  var totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    var current = appointments[totalIndex];\n    var currentGroup = groups[groups.length - 1];\n    var next = appointments[totalIndex + 1];\n    var maxBoundary = current.end;\n    currentGroup.push(current);\n    totalIndex += 1;\n\n    while (next && (maxBoundary.isAfter(next.start) || byDay && byDayPredicate(maxBoundary, next.start))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n\n  return groups;\n};\n\nvar isMidnight$1 = function isMidnight$1(date) {\n  return date.isSame(date.clone().startOf('day'));\n};\n\nvar maxBoundaryPredicate = function maxBoundaryPredicate(maxBoundary, startDate) {\n  return maxBoundary.isBefore(startDate, 'day') || isMidnight$1(maxBoundary) && maxBoundary.isSame(startDate, 'day');\n};\n\nvar calculateAppointmentOffsets = function calculateAppointmentOffsets(groups, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  return groups.map(function (items) {\n    var offset = 0;\n    var reduceValue = 1;\n    var appointments = items.map(function (appointment) {\n      return _assign({}, appointment);\n    });\n    var groupLength = appointments.length;\n\n    for (var startIndex = 0; startIndex < groupLength; startIndex += 1) {\n      var appointment = appointments[startIndex];\n\n      if (appointment.offset === undefined) {\n        var maxBoundary = appointment.end;\n        appointment.offset = offset;\n\n        for (var index = startIndex + 1; index < groupLength; index += 1) {\n          if (appointments[index].offset === undefined) {\n            if (!byDay && maxBoundary.isSameOrBefore(appointments[index].start) || byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start)) {\n              maxBoundary = appointments[index].end;\n              appointments[index].offset = offset;\n            }\n          }\n        }\n\n        offset += 1;\n        if (reduceValue < offset) reduceValue = offset;\n      }\n    }\n\n    return {\n      items: appointments,\n      reduceValue: reduceValue\n    };\n  });\n};\n\nvar unwrapAppointmentForest = function unwrapAppointmentForest(appointmentForests) {\n  var forestUnwrapped = appointmentForests.map(function (_a) {\n    var items = _a.items,\n        reduceValue = _a.reduceValue;\n    return {\n      reduceValue: reduceValue,\n      items: items.map(function (_a) {\n        var data = _a.data;\n        return _assign({}, data);\n      })\n    };\n  });\n  return unwrapGroups(forestUnwrapped);\n};\n\nvar unwrapGroups = function unwrapGroups(groups) {\n  return groups.reduce(function (acc, _a) {\n    var items = _a.items,\n        reduceValue = _a.reduceValue;\n    acc.push.apply(acc, __spread(items.map(function (_a) {\n      var start = _a.start,\n          end = _a.end,\n          dataItem = _a.dataItem,\n          offset = _a.offset,\n          resources = _a.resources,\n          key = _a.key,\n          restProps = __rest(_a, [\"start\", \"end\", \"dataItem\", \"offset\", \"resources\", \"key\"]);\n\n      return _assign({\n        start: start,\n        end: end,\n        dataItem: dataItem,\n        offset: offset,\n        reduceValue: reduceValue,\n        resources: resources,\n        fromPrev: moment(start).diff(dataItem.startDate, 'minutes') > 1,\n        toNext: moment(dataItem.endDate).diff(end, 'minutes') > 1,\n        key: key\n      }, restProps);\n    })));\n    return acc;\n  }, []);\n};\n\nvar intervalIncludes = function intervalIncludes(intervalStart, intervalEnd, date) {\n  return date.isBetween(intervalStart, intervalEnd, undefined, '[)');\n};\n\nvar createAppointmentForest = function createAppointmentForest(appointmentGroups, cellDuration) {\n  return appointmentGroups.map(function (appointmentGroup) {\n    var items = appointmentGroup.items;\n    var nextItems;\n    var roots;\n\n    if (items.length === 1) {\n      nextItems = [{\n        data: items[0],\n        children: [],\n        treeDepth: 0,\n        isDirectChild: false,\n        hasDirectChild: false\n      }];\n      roots = [0];\n    } else {\n      var _a = visitRoots(items, cellDuration),\n          appointments = _a.appointments,\n          appointmentTreeRoots = _a.roots;\n\n      nextItems = appointments;\n      roots = appointmentTreeRoots;\n    }\n\n    return _assign(_assign({}, appointmentGroup), {\n      items: nextItems,\n      roots: roots\n    });\n  });\n};\n\nvar visitRoots = function visitRoots(appointmentItems, cellDuration) {\n  var appointmentNodes = appointmentItems.map(function (props) {\n    return {\n      data: props\n    };\n  });\n  var roots = appointmentNodes.reduce(function (acc, appointment, appointmentIndex) {\n    var appointmentOffset = appointment.data.offset;\n\n    if (appointmentOffset === 0) {\n      if (appointmentIndex + 1 === appointmentNodes.length) {\n        appointment.children = [];\n        appointment.hasDirectChild = false;\n        appointment.treeDepth = 0;\n      } else {\n        appointment.treeDepth = visitAllChildren(appointmentNodes, appointmentIndex, cellDuration, 0);\n      }\n\n      appointment.parent = undefined;\n      appointment.isDirectChild = false;\n      return __spread(acc, [appointmentIndex]);\n    }\n\n    return acc;\n  }, []);\n  return {\n    appointments: appointmentNodes,\n    roots: roots\n  };\n};\n\nvar visitChild = function visitChild(appointmentNodes, index, parentAppointmentIndex, cellDuration, isDirectChild, treeDepth) {\n  var appointmentNode = appointmentNodes[index];\n  appointmentNode.isDirectChild = isDirectChild;\n  appointmentNode.parent = parentAppointmentIndex;\n  var nextTreeDepth = treeDepth + 1;\n  var end = appointmentNode.data.end;\n\n  if (index === appointmentNodes.length - 1 || end.isSameOrBefore(appointmentNodes[index + 1].data.start)) {\n    appointmentNode.children = [];\n    appointmentNode.treeDepth = 0;\n    appointmentNode.hasDirectChild = false;\n    return nextTreeDepth;\n  }\n\n  var calculatedTreeDepth = visitAllChildren(appointmentNodes, index, cellDuration, treeDepth);\n  appointmentNode.treeDepth = calculatedTreeDepth;\n  return calculatedTreeDepth + 1;\n};\n\nvar visitAllChildren = function visitAllChildren(appointmentNodes, appointmentIndex, cellDuration, treeDepth) {\n  var appointment = appointmentNodes[appointmentIndex];\n  var _a = appointment.data,\n      end = _a.end,\n      appointmentOffset = _a.offset,\n      start = _a.start;\n  var directChildTimeLimit = moment(start).add(cellDuration, 'minutes');\n  var maxAppointmentTreeDepth = 0;\n  var children = [];\n  var nextChildIndex = appointmentIndex + 1;\n\n  while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n    var nextAppointment = appointmentNodes[nextChildIndex];\n    var _b = nextAppointment.data,\n        nextOffset = _b.offset,\n        nextStart = _b.start;\n\n    if (nextOffset === appointmentOffset + 1) {\n      var isDirectChild = intervalIncludes(start, directChildTimeLimit, nextStart);\n      var nextTreeDepth = visitChild(appointmentNodes, nextChildIndex, appointmentIndex, cellDuration, isDirectChild, treeDepth);\n\n      if (maxAppointmentTreeDepth < nextTreeDepth) {\n        maxAppointmentTreeDepth = nextTreeDepth;\n      }\n\n      children.push(nextChildIndex);\n    }\n\n    nextChildIndex += 1;\n  }\n\n  appointment.hasDirectChild = children.length !== 0 && appointmentNodes[children[0]].isDirectChild;\n  appointment.children = children;\n  return maxAppointmentTreeDepth;\n};\n\nvar isPossibleChild = function isPossibleChild(appointments, possibleChildIndex, parentEnd, parentOffset) {\n  var possibleChild = appointments[possibleChildIndex];\n  return possibleChildIndex < appointments.length && possibleChild.data.offset !== parentOffset && possibleChild.data.start.isBefore(parentEnd);\n};\n\nvar findMaxReduceValue = function findMaxReduceValue(appointmentGroups) {\n  return appointmentGroups.reduce(function (maxReduceValue, group) {\n    var currentReduceValue = group.reduceValue;\n    return maxReduceValue > currentReduceValue ? maxReduceValue : currentReduceValue;\n  }, 1);\n};\n\nvar calculateAppointmentsMetaData = function calculateAppointmentsMetaData(appointmentGroups, indirectChildLeftOffset) {\n  return appointmentGroups.map(function (appointmentForest) {\n    var items = appointmentForest.items,\n        roots = appointmentForest.roots;\n    var firstNode = items[0];\n    return _assign(_assign({}, appointmentForest), {\n      items: items.length === 1 ? [_assign(_assign({}, firstNode), {\n        data: _assign(_assign({}, firstNode.data), {\n          left: 0,\n          width: 1\n        })\n      })] : calculateRootsMetaData(items, roots, indirectChildLeftOffset)\n    });\n  });\n};\n\nvar calculateRootsMetaData = function calculateRootsMetaData(appointmentNodes, roots, indirectChildLeftOffset) {\n  var appointments = appointmentNodes.map(function (props) {\n    return _assign({}, props);\n  });\n  roots.forEach(function (appointmentIndex) {\n    var appointment = appointments[appointmentIndex];\n\n    var _a = calculateAppointmentLeftAndWidth(appointments, undefined, appointment, MAX_WIDTH, indirectChildLeftOffset, undefined),\n        left = _a.left,\n        width = _a.width;\n\n    appointment.data.left = left;\n    appointment.data.width = width;\n    calculateChildrenMetaData(appointments, appointment, MAX_WIDTH, indirectChildLeftOffset);\n  });\n  return appointments;\n};\n\nvar calculateChildMetaData = function calculateChildMetaData(appointmentNodes, appointmentIndex, maxWidth, indirectChildLeftOffset) {\n  var appointment = appointmentNodes[appointmentIndex];\n\n  var _a = calculateAppointmentLeftAndWidth(appointmentNodes, undefined, appointment, maxWidth, indirectChildLeftOffset, undefined),\n      left = _a.left,\n      width = _a.width;\n\n  appointment.data.left = left;\n  appointment.data.width = width;\n  calculateChildrenMetaData(appointmentNodes, appointment, maxWidth, indirectChildLeftOffset);\n};\n\nvar calculateChildrenMetaData = function calculateChildrenMetaData(appointmentNodes, appointmentNode, maxWidth, indirectChildLeftOffset) {\n  appointmentNode.children.forEach(function (childIndex) {\n    calculateChildMetaData(appointmentNodes, childIndex, maxWidth, indirectChildLeftOffset);\n  });\n};\n\nvar calculateAppointmentLeftAndWidth = function calculateAppointmentLeftAndWidth(appointmentNodes, blocks, appointmentNode, maxRight, indirectChildLeftOffset, defaultLeft) {\n  var _a;\n\n  var _b = appointmentNode,\n      hasDirectChild = _b.hasDirectChild,\n      treeDepth = _b.treeDepth,\n      isDirectChild = _b.isDirectChild,\n      parentIndex = _b.parent,\n      children = _b.children,\n      blockIndex = _b.blockIndex;\n  var firstChild = appointmentNodes[children[0]];\n  var firstChildBlockIndex = (_a = firstChild) === null || _a === void 0 ? void 0 : _a.blockIndex;\n  var hasDirectChildAndInSameBlock = hasDirectChild && (firstChildBlockIndex === undefined || blockIndex === firstChildBlockIndex || blocks[firstChildBlockIndex].includedInto === blockIndex || maxRight === 1);\n\n  if (parentIndex === undefined) {\n    return {\n      width: hasDirectChildAndInSameBlock ? maxRight / (treeDepth + 1) : maxRight,\n      left: 0\n    };\n  }\n\n  var parent = appointmentNodes[parentIndex];\n  var _c = parent.data,\n      parentWidth = _c.width,\n      parentLeft = _c.left;\n  var calculatedLeft = isDirectChild ? parentLeft + parentWidth : parentLeft + indirectChildLeftOffset;\n  var left = defaultLeft !== undefined ? Math.max(defaultLeft, calculatedLeft) : calculatedLeft;\n  var unoccupiedSpace = maxRight - left;\n  return {\n    width: hasDirectChildAndInSameBlock ? unoccupiedSpace / (treeDepth + 1) : unoccupiedSpace,\n    left: left\n  };\n};\n\nvar prepareToGroupIntoBlocks = function prepareToGroupIntoBlocks(appointments) {\n  return appointments.map(function (appointmentForest) {\n    var nodes = appointmentForest.items;\n    var appointmentNodes = nodes.map(function (props) {\n      return _assign({}, props);\n    });\n    appointmentNodes.forEach(function (appointmentNode, index) {\n      if (index === 0) {\n        appointmentNode.overlappingSubTreeRoots = [];\n        return;\n      }\n\n      var overlappingSubTreeRoots = [];\n      var _a = appointmentNode.data,\n          appointmentOffset = _a.offset,\n          end = _a.end;\n      var nextChildIndex = index + 1;\n      var currentBlockEnd;\n\n      while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n        var nextAppointment = appointmentNodes[nextChildIndex];\n\n        if (nextAppointment.data.offset < appointmentOffset && nextAppointment.maxOffset === undefined) {\n          nextAppointment.maxOffset = appointmentOffset;\n        }\n\n        var previousSubTreeRoot = overlappingSubTreeRoots.length > 0 ? appointmentNodes[overlappingSubTreeRoots[overlappingSubTreeRoots.length - 1]] : undefined;\n\n        if (isOverlappingSubTreeRoot(appointmentNode, nextAppointment, previousSubTreeRoot, currentBlockEnd)) {\n          overlappingSubTreeRoots.push(nextChildIndex);\n          nextAppointment.overlappingSubTreeRoot = true;\n          var maxChildDate = findChildrenMaxEndDate(appointmentNodes, nextAppointment);\n\n          if (!currentBlockEnd || currentBlockEnd.isBefore(maxChildDate)) {\n            currentBlockEnd = maxChildDate;\n          }\n        }\n\n        nextChildIndex += 1;\n      }\n\n      appointmentNode.overlappingSubTreeRoots = overlappingSubTreeRoots;\n    });\n    return _assign(_assign({}, appointmentForest), {\n      items: appointmentNodes\n    });\n  });\n};\n\nvar isOverlappingSubTreeRoot = function isOverlappingSubTreeRoot(appointmentNode, nextAppointment, previousSubTreeRoot, previousEndDate) {\n  var overlappingSubTreeRoot = nextAppointment.overlappingSubTreeRoot,\n      maxOffset = nextAppointment.maxOffset,\n      nextData = nextAppointment.data;\n  var nextOffset = nextData.offset,\n      nextStart = nextData.start;\n  var offset = appointmentNode.data.offset;\n  return nextOffset < offset && !overlappingSubTreeRoot && (maxOffset === undefined || maxOffset >= offset) && (!previousSubTreeRoot || previousSubTreeRoot.data.offset >= nextOffset && nextStart.isSameOrAfter(previousEndDate));\n};\n\nvar findChildrenMaxEndDate = function findChildrenMaxEndDate(appointmentNodes, appointmentNode) {\n  var children = appointmentNode.children,\n      data = appointmentNode.data;\n  var end = data.end;\n  var maxDate = children.reduce(function (currentMaxDate, childIndex) {\n    var child = appointmentNodes[childIndex];\n    var maxChildrenDate = findChildrenMaxEndDate(appointmentNodes, child);\n\n    if (maxChildrenDate.isAfter(currentMaxDate)) {\n      return maxChildrenDate;\n    }\n\n    return currentMaxDate;\n  }, end);\n  return maxDate;\n};\n\nvar groupAppointmentsIntoBlocks = function groupAppointmentsIntoBlocks(appointmentForests) {\n  return appointmentForests.map(function (appointmentForest) {\n    var items = appointmentForest.items,\n        reduceValue = appointmentForest.reduceValue;\n\n    var _a = items.reduce(function (acc, appointment, index) {\n      var blocks = acc.blocks.slice();\n      var treeDepth = appointment.treeDepth,\n          data = appointment.data,\n          overlappingSubTreeRoots = appointment.overlappingSubTreeRoots,\n          overlappingSubTreeRoot = appointment.overlappingSubTreeRoot;\n      var offset = data.offset,\n          start = data.start,\n          end = data.end;\n\n      if (overlappingSubTreeRoots.length !== 0) {\n        if (!overlappingSubTreeRoot) {\n          blocks.push({\n            start: start,\n            end: end,\n            minOffset: offset,\n            maxOffset: offset + treeDepth,\n            size: treeDepth + 1,\n            items: [],\n            endForChildren: end\n          });\n        }\n\n        overlappingSubTreeRoots.forEach(function (subTreeRootIndex) {\n          var subTreeRoot = items[subTreeRootIndex];\n          var subTreeRootData = subTreeRoot.data;\n          blocks.push({\n            start: subTreeRootData.start,\n            end: end,\n            minOffset: subTreeRootData.offset,\n            maxOffset: offset - 1,\n            size: calculateBlockSizeByEndDate(items, subTreeRoot, end),\n            items: [],\n            endForChildren: subTreeRootData.end\n          });\n        });\n      }\n\n      var blockIndex = findBlockIndexByAppointment(blocks, appointment);\n      blocks[blockIndex].items.push(index);\n\n      var appointmentInBlock = _assign(_assign({}, appointment), {\n        blockIndex: blockIndex\n      });\n\n      return {\n        blocks: blocks,\n        appointments: __spread(acc.appointments, [appointmentInBlock])\n      };\n    }, {\n      blocks: [{\n        start: items[0].data.start,\n        end: items[0].data.end,\n        minOffset: 0,\n        maxOffset: reduceValue - 1,\n        size: reduceValue,\n        items: [],\n        endForChildren: items[0].data.end\n      }],\n      appointments: []\n    }),\n        nextBlocks = _a.blocks,\n        appointments = _a.appointments;\n\n    return {\n      blocks: nextBlocks,\n      appointmentForest: _assign(_assign({}, appointmentForest), {\n        items: appointments\n      })\n    };\n  });\n};\n\nvar calculateBlockSizeByEndDate = function calculateBlockSizeByEndDate(appointmentNodes, subTreeRoot, blockEndDate) {\n  var children = subTreeRoot.children,\n      data = subTreeRoot.data;\n  var start = data.start;\n\n  if (children.length === 0) {\n    if (blockEndDate.isAfter(start)) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  var maxSize = Math.max.apply(Math, __spread(children.map(function (childIndex) {\n    return calculateBlockSizeByEndDate(appointmentNodes, appointmentNodes[childIndex], blockEndDate);\n  })));\n\n  if (blockEndDate.isSameOrBefore(start) && maxSize === 0) {\n    return 0;\n  }\n\n  return maxSize + 1;\n};\n\nvar findBlockIndexByAppointment = function findBlockIndexByAppointment(blocks, appointment) {\n  var _a = appointment.data,\n      start = _a.start,\n      offset = _a.offset;\n  var blockIndex = blocks.length - 1;\n\n  while (blockIndex > 0) {\n    var currentBlock = blocks[blockIndex];\n\n    if (intervalIncludes(currentBlock.start, currentBlock.end, start) && offset >= currentBlock.minOffset && offset <= currentBlock.maxOffset) {\n      break;\n    }\n\n    blockIndex -= 1;\n  }\n\n  return blockIndex;\n};\n\nvar findIncludedBlocks = function findIncludedBlocks(groupedIntoBlocks) {\n  return groupedIntoBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    var nextBlocks = blocks.map(function (props) {\n      return _assign({}, props);\n    });\n    nextBlocks.forEach(function (block, blockIndex) {\n      block.includedBlocks = [];\n\n      for (var currentBlockIndex = blockIndex + 1; currentBlockIndex < nextBlocks.length; currentBlockIndex += 1) {\n        var currentBlock = nextBlocks[currentBlockIndex];\n\n        if (isIncludedBlock(block, currentBlock)) {\n          block.includedBlocks.push(currentBlockIndex);\n          currentBlock.includedInto = blockIndex;\n        }\n      }\n    });\n    return {\n      blocks: nextBlocks,\n      appointmentForest: appointmentForest\n    };\n  });\n};\n\nvar isIncludedBlock = function isIncludedBlock(block, possibleIncludedBlock) {\n  var start = block.start,\n      end = block.end,\n      minOffset = block.minOffset,\n      maxOffset = block.maxOffset;\n  var possibleIncludedStart = possibleIncludedBlock.start,\n      possibleIncludedEnd = possibleIncludedBlock.end,\n      possibleMinOffset = possibleIncludedBlock.minOffset,\n      possibleMaxOffset = possibleIncludedBlock.maxOffset;\n  return intervalIncludes(start, end, possibleIncludedStart) && intervalIncludes(start, end, possibleIncludedEnd) && possibleMaxOffset <= maxOffset && possibleMinOffset >= minOffset;\n};\n\nvar findChildBlocks = function findChildBlocks(groupedIntoBlocks) {\n  return groupedIntoBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    var nextBlocks = blocks.map(function (props) {\n      return _assign({}, props);\n    });\n    nextBlocks.forEach(function (block, index) {\n      block.children = [];\n\n      for (var currentIndex = index + 1; currentIndex < nextBlocks.length; currentIndex += 1) {\n        var nextBlock = nextBlocks[currentIndex];\n\n        if (isChildBlock(block, nextBlock)) {\n          block.children.push(currentIndex);\n          nextBlock.parent = index;\n        }\n      }\n\n      return block;\n    });\n    return {\n      appointmentForest: appointmentForest,\n      blocks: nextBlocks\n    };\n  });\n};\n\nvar isChildBlock = function isChildBlock(block, possibleChildBlock) {\n  var start = block.start,\n      endForChildren = block.endForChildren,\n      minOffset = block.minOffset,\n      includedInto = block.includedInto;\n  var childStart = possibleChildBlock.start,\n      childIncludedInto = possibleChildBlock.includedInto,\n      childMaxOffset = possibleChildBlock.maxOffset;\n  return intervalIncludes(start, endForChildren, childStart) && childMaxOffset + 1 === minOffset && (childIncludedInto === undefined || childIncludedInto === includedInto);\n};\n\nvar adjustByBlocks = function adjustByBlocks(groupedIntoBlocks, indirectChildLeftOffset) {\n  var updatedBlocks = groupedIntoBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    var dimensionsCalculated = calculateBlocksDimensions(blocks, appointmentForest.items);\n    return {\n      blocks: alignBlocksWithPrevious(dimensionsCalculated, appointmentForest.items),\n      appointmentForest: appointmentForest\n    };\n  });\n  var adjustedByBlocks = updatedBlocks.map(function (_a) {\n    var blocks = _a.blocks,\n        appointmentForest = _a.appointmentForest;\n    return _assign(_assign({}, appointmentForest), {\n      items: adjustAppointmentsByBlocks(appointmentForest.items, blocks, indirectChildLeftOffset)\n    });\n  });\n  return adjustedByBlocks;\n};\n\nvar calculateBlocksDimensions = function calculateBlocksDimensions(blocks, appointments) {\n  return updateBlocksProportions(calculateBlocksLeftLimit(calculateBlocksTotalSize(blocks), appointments));\n};\n\nvar alignBlocksWithPrevious = function alignBlocksWithPrevious(blocks, appointments) {\n  var nextBlocks = blocks.map(function (_a) {\n    var right = _a.right,\n        restProps = __rest(_a, [\"right\"]);\n\n    return _assign({}, restProps);\n  });\n  var leftLimitCalculated = calculateBlocksLeftLimit(updateBlocksLeft(nextBlocks, appointments), appointments);\n  return updateBlocksProportions(leftLimitCalculated);\n};\n\nvar adjustAppointmentsByBlocks = function adjustAppointmentsByBlocks(appointments, blocks, indirectChildLeftOffset) {\n  var nextAppointments = appointments.map(function (props) {\n    return _assign({}, props);\n  });\n  var nextBlocks = blocks.map(function (props) {\n    return _assign({}, props);\n  });\n  nextBlocks.forEach(function (block, index) {\n    if (index !== 0) {\n      var items = block.items,\n          blockLeft = block.left,\n          right = block.right,\n          children_1 = block.children;\n      var maxRight_1 = calculateIncludedBlockMaxRight(nextBlocks, block);\n      var finalMaxRight_1 = maxRight_1 * right;\n      var defaultLeft_1 = blockLeft * maxRight_1;\n      items.forEach(function (appointmentIndex, itemIndex) {\n        var appointment = nextAppointments[appointmentIndex];\n\n        if (itemIndex === 0) {\n          var _a = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, defaultLeft_1),\n              left_1 = _a.left,\n              width = _a.width;\n\n          appointment.data.left = left_1;\n          appointment.data.width = width;\n\n          if (defaultLeft_1 !== left_1) {\n            children_1.forEach(function (childIndex) {\n              redistributeChildBlocks(nextBlocks, childIndex, left_1 / maxRight_1);\n            });\n          }\n        } else {\n          var _b = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, undefined),\n              left = _b.left,\n              width = _b.width;\n\n          appointment.data.left = left;\n          appointment.data.width = width;\n        }\n      });\n    }\n  });\n  blocks[0].items.forEach(function (appointmentIndex) {\n    var appointment = nextAppointments[appointmentIndex];\n\n    var _a = calculateAppointmentLeftAndWidth(nextAppointments, blocks, appointment, 1, indirectChildLeftOffset, undefined),\n        left = _a.left,\n        width = _a.width;\n\n    appointment.data.left = left;\n    appointment.data.width = width;\n  });\n  return nextAppointments;\n};\n\nvar redistributeChildBlocks = function redistributeChildBlocks(blocks, blockIndex, right) {\n  var block = blocks[blockIndex];\n  var leftOffset = block.leftOffset,\n      size = block.size,\n      leftLimit = block.leftLimit,\n      children = block.children;\n  block.right = right;\n  var width = size + leftOffset;\n  var relativeWidth = right - leftLimit;\n  var left = right - relativeWidth * size / width;\n  block.left = left;\n  children.forEach(function (childIndex) {\n    redistributeChildBlocks(blocks, childIndex, left);\n  });\n};\n\nvar calculateIncludedBlockMaxRight = function calculateIncludedBlockMaxRight(blocks, includedBlock) {\n  var includedIntoIndex = includedBlock.includedInto;\n\n  if (includedIntoIndex === undefined) {\n    return 1;\n  }\n\n  var includedInto = blocks[includedIntoIndex];\n  var currentMaxRight = includedInto.right;\n  return currentMaxRight * calculateIncludedBlockMaxRight(blocks, includedInto);\n};\n\nvar calculateBlocksTotalSize = function calculateBlocksTotalSize(blocks) {\n  var result = blocks.map(function (block) {\n    var totalSize = calculateSingleBlockTotalSize(blocks, block);\n    return _assign(_assign({}, block), {\n      totalSize: totalSize,\n      leftOffset: totalSize - block.size\n    });\n  });\n  return result;\n};\n\nvar calculateSingleBlockTotalSize = function calculateSingleBlockTotalSize(blocks, block) {\n  var children = block.children,\n      size = block.size;\n\n  if (children.length === 0) {\n    return size;\n  }\n\n  return Math.max.apply(Math, __spread(children.map(function (childIndex) {\n    return calculateSingleBlockTotalSize(blocks, blocks[childIndex]);\n  }))) + size;\n};\n\nvar calculateBlocksLeftLimit = function calculateBlocksLeftLimit(blocks, appointments) {\n  return blocks.map(function (block) {\n    var leftLimit = calculateSingleBlockLeftLimit(blocks, appointments, block);\n    return _assign(_assign({}, block), {\n      leftLimit: leftLimit\n    });\n  });\n};\n\nvar calculateSingleBlockLeftLimit = function calculateSingleBlockLeftLimit(blocks, appointments, block) {\n  var _a = block,\n      children = _a.children,\n      items = _a.items,\n      left = _a.left;\n\n  if (children.length === 0) {\n    return left !== undefined ? Math.min(left, appointments[items[0]].data.left) : appointments[items[0]].data.left;\n  }\n\n  return Math.min.apply(Math, __spread(children.map(function (childIndex) {\n    return calculateSingleBlockLeftLimit(blocks, appointments, blocks[childIndex]);\n  })));\n};\n\nvar updateBlocksProportions = function updateBlocksProportions(blocks) {\n  var nextBlocks = blocks.map(function (props) {\n    return _assign({}, props);\n  });\n  nextBlocks.forEach(function (block) {\n    var parentIndex = block.parent,\n        leftLimit = block.leftLimit,\n        leftOffset = block.leftOffset,\n        totalSize = block.totalSize;\n\n    if (parentIndex === undefined) {\n      block.right = 1;\n      block.left = (1 - leftLimit) * leftOffset / totalSize + leftLimit;\n      return;\n    }\n\n    var parent = nextBlocks[parentIndex];\n    var _a = parent,\n        parentLeft = _a.left,\n        parentTotalSize = _a.totalSize;\n    block.totalSize = parentTotalSize;\n    block.right = parentLeft;\n    block.left = (1 - leftLimit) * leftOffset / parentTotalSize + leftLimit;\n  });\n  return nextBlocks;\n};\n\nvar updateBlocksLeft = function updateBlocksLeft(blocks, appointments) {\n  return blocks.map(function (block) {\n    var items = block.items,\n        left = block.left;\n    var firstItem = appointments[items[0]];\n    var firstItemParentIndex = firstItem.parent;\n\n    if (firstItemParentIndex === undefined) {\n      return block;\n    }\n\n    var firstItemParent = appointments[firstItemParentIndex];\n    var parentBlock = blocks[firstItemParent.blockIndex];\n    return _assign(_assign({}, block), {\n      left: parentBlock.parent === undefined ? left : blocks[parentBlock.parent].left\n    });\n  });\n};\n\nvar createAndAdjustAppointmentForest = function createAndAdjustAppointmentForest(appointmentGroups, cellDuration) {\n  var appointmentForest = createAppointmentForest(appointmentGroups, cellDuration);\n  var indirectChildLeftOffset = Math.min(1 / findMaxReduceValue(appointmentForest), INDIRECT_CHILD_LEFT_OFFSET);\n  var baseCalculated = calculateAppointmentsMetaData(appointmentForest, indirectChildLeftOffset);\n  var preparedToGroupIntoBlocks = prepareToGroupIntoBlocks(baseCalculated);\n  var groupedIntoBlocks = groupAppointmentsIntoBlocks(preparedToGroupIntoBlocks);\n  var blocksWithIncluded = findIncludedBlocks(groupedIntoBlocks);\n  var blocksWithParents = findChildBlocks(blocksWithIncluded);\n  return adjustByBlocks(blocksWithParents, indirectChildLeftOffset);\n};\n\nvar calculateRectByDateAndGroupIntervals = function calculateRectByDateAndGroupIntervals(type, intervals, rectByDates, rectByDatesMeta, viewMetaData) {\n  var growDirection = type.growDirection,\n      multiline = type.multiline;\n  var isHorizontal = growDirection === HORIZONTAL_TYPE;\n  var sorted = intervals.map(sortAppointments);\n  var grouped = sorted.reduce(function (acc, sortedGroup) {\n    return __spread(acc, findOverlappedAppointments(sortedGroup, isHorizontal));\n  }, []);\n  var cellDuration = rectByDatesMeta.cellDuration,\n      placeAppointmentsNextToEachOther = rectByDatesMeta.placeAppointmentsNextToEachOther;\n  var rectCalculator = isHorizontal ? horizontalRectCalculator : placeAppointmentsNextToEachOther ? oldVerticalRectCalculator : verticalRectCalculator;\n  var groupsCalculated = calculateAppointmentOffsets(grouped, isHorizontal);\n  var isAppointmentForestNeeded = !isHorizontal && !placeAppointmentsNextToEachOther;\n  var appointmentForest;\n\n  if (isAppointmentForestNeeded) {\n    appointmentForest = createAndAdjustAppointmentForest(groupsCalculated, cellDuration);\n  }\n\n  var unwrappedAppointments = isAppointmentForestNeeded ? unwrapAppointmentForest(appointmentForest) : unwrapGroups(groupsCalculated);\n  var rects = unwrappedAppointments.map(function (appointment) {\n    return rectCalculator(appointment, viewMetaData, {\n      rectByDates: rectByDates,\n      multiline: multiline,\n      rectByDatesMeta: rectByDatesMeta\n    });\n  });\n  return rects.sort(function (first, second) {\n    return first.offset >= second.offset ? 1 : -1;\n  });\n};\n\nvar sliceAppointmentByDay = function sliceAppointmentByDay(appointment, cellDuration) {\n  var start = appointment.start,\n      end = appointment.end,\n      dataItem = appointment.dataItem,\n      key = appointment.key;\n  if (start.isSame(end, 'day')) return [appointment];\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  var isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n  var firstAppointmentKey = addDateToKey(key, start);\n  var secondAppointmentKey = addDateToKey(key, end);\n  return [isShortOnFirstDay ? {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n    dataItem: dataItem,\n    key: firstAppointmentKey\n  } : {\n    start: start,\n    end: start.clone().endOf('day'),\n    dataItem: dataItem,\n    key: firstAppointmentKey\n  }, isShortOnSecondDay ? {\n    start: end.clone().startOf('day'),\n    end: end.clone().startOf('day').add(minDuration, 'minutes'),\n    dataItem: dataItem,\n    key: secondAppointmentKey\n  } : {\n    start: end.clone().startOf('day'),\n    end: end,\n    dataItem: dataItem,\n    key: secondAppointmentKey\n  }];\n};\n\nvar dayBoundaryPredicate = function dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes());\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(function (day) {\n    return day === moment(appointment.start).day();\n  }) !== -1) return false;\n  return appointment.end.isAfter(startDayTime) && appointment.start.isBefore(endDayTime);\n};\n\nvar reduceAppointmentByDayBounds = function reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration) {\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes()).seconds(dayStart.seconds());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes()).seconds(dayEnd.seconds());\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  var isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return _assign(_assign({}, appointment), {\n      start: endDayTime.clone().add(-minDuration, 'minutes'),\n      end: endDayTime\n    });\n  }\n\n  if (isShortOnSecondDay) {\n    return _assign(_assign({}, appointment), {\n      start: startDayTime,\n      end: startDayTime.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return _assign(_assign(_assign({}, appointment), appointment.start.isSameOrBefore(startDayTime) ? {\n    start: startDayTime\n  } : null), appointment.end.isSameOrAfter(endDayTime) ? {\n    end: endDayTime\n  } : null);\n};\n\nvar normalizeAppointmentDuration = function normalizeAppointmentDuration(appointment, cellDuration) {\n  var minDuration = cellDuration / 2;\n  var start = moment(appointment.start);\n  var end = moment(appointment.end);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return _assign(_assign({}, appointment), {\n      start: start,\n      end: end\n    });\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return _assign(_assign({}, appointment), {\n      start: start,\n      end: start.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return _assign(_assign({}, appointment), {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day')\n  });\n};\n\nvar getWeekVerticallyGroupedColumnIndex = function getWeekVerticallyGroupedColumnIndex(viewCellsData, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return moment(date).isSame(timeCell.startDate, 'date');\n  });\n};\n\nvar getWeekHorizontallyGroupedColumnIndex = function getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    var isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);\n    return moment(date).isSame(timeCell.startDate, 'date') && isCorrectGroup;\n  });\n};\n\nvar getWeekVerticallyGroupedRowIndex = function getWeekVerticallyGroupedRowIndex(viewCellsData, appointment, date, columnIndex, takePrev, groupCount) {\n  var timeTableHeight = viewCellsData.length / groupCount;\n  var timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n  if (!viewCellsData[0][0].groupingInfo) return timeTableRowIndex;\n  var isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);\n\n  while (isWrongCell) {\n    timeTableRowIndex += timeTableHeight;\n    isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);\n  }\n\n  return timeTableRowIndex;\n};\n\nvar getWeekHorizontallyGroupedRowIndex = function getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev) {\n  return viewCellsData.findIndex(function (timeCell) {\n    return moment(date).isBetween(timeCell[columnIndex].startDate, timeCell[columnIndex].endDate, 'seconds', takePrev ? '(]' : '[)');\n  });\n};\n\nvar calculateWeekDateIntervals = function calculateWeekDateIntervals(appointments, leftBound, rightBound, // startViewDate, endViewDate\nexcludedDays, cellDuration) {\n  return [appointments.map(function (appointment) {\n    return normalizeAppointmentDuration(appointment, cellDuration);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByDay(appointment, cellDuration));\n  }, []).filter(function (appointment) {\n    return dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays);\n  }).map(function (appointment) {\n    return reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration);\n  })];\n};\n\nvar CELL_GAP_PX = 10;\nvar CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nvar CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nvar getVerticalCellIndexByAppointmentData = function getVerticalCellIndexByAppointmentData(appointment, viewCellsData, viewMetaData, date, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupCount = viewMetaData.groupCount;\n  var columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedColumnIndex(viewCellsData, date) : getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date);\n  var rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedRowIndex(viewCellsData, appointment, date, columnIndex, takePrev, groupCount) : getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n  var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return {\n    index: cellIndex,\n    startDate: viewCellsData[rowIndex][columnIndex].startDate\n  };\n};\n\nvar getCellRect = function getCellRect(date, appointment, viewCellsData, cellDuration, cellElementsMeta, takePrev, viewMetaData) {\n  var _a = getVerticalCellIndexByAppointmentData(appointment, viewCellsData, viewMetaData, date, takePrev),\n      cellIndex = _a.index,\n      cellStartDate = _a.startDate;\n\n  var _b = cellElementsMeta.getCellRects[cellIndex](),\n      top = _b.top,\n      left = _b.left,\n      width = _b.width,\n      cellHeight = _b.height;\n\n  var timeOffset = moment(date).diff(cellStartDate, 'minutes');\n  var topOffset = cellHeight * (timeOffset / cellDuration);\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    topOffset: topOffset,\n    parentRect: parentRect\n  };\n};\n\nvar getVerticalRectByAppointmentData = function getVerticalRectByAppointmentData(appointment, viewMetaData, _a) {\n  var viewCellsData = _a.viewCellsData,\n      cellDuration = _a.cellDuration,\n      cellElementsMeta = _a.cellElementsMeta,\n      placeAppointmentsNextToEachOther = _a.placeAppointmentsNextToEachOther;\n  var firstCellRect = getCellRect(appointment.start.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, false, viewMetaData);\n  var lastCellRect = getCellRect(appointment.end.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, true, viewMetaData);\n  var top = firstCellRect.top + firstCellRect.topOffset;\n  var height = lastCellRect.top + lastCellRect.topOffset - top;\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: placeAppointmentsNextToEachOther ? height - CELL_BOUND_VERTICAL_OFFSET_PX : height\n  };\n};\n\nvar allDayPredicate = function allDayPredicate(appointment) {\n  return appointment.end.diff(appointment.start, 'hours') > 23 || !!appointment.allDay;\n};\n\nvar getAllDayCellIndexByAppointmentData = function getAllDayCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) {\n  var currentDate = moment(date);\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupCount = viewMetaData.groupCount;\n  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData, currentDate, appointment) : getAllDayVerticallyGroupedColumnIndex(viewCellsData, currentDate);\n  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount);\n  var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n\n  return cellIndex;\n};\n\nvar getAllDayVerticallyGroupedColumnIndex = function getAllDayVerticallyGroupedColumnIndex(viewCellsData, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return date.isSame(timeCell.startDate, 'date');\n  });\n};\n\nvar getAllDayHorizontallyGroupedColumnIndex = function getAllDayHorizontallyGroupedColumnIndex(viewCellsData, date, appointment) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return date.isSame(timeCell.startDate, 'date') && checkCellGroupingInfo(timeCell, appointment);\n  });\n};\n\nvar getAllDayVerticallyGroupedRowIndex = function getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount) {\n  var index = viewCellsData.findIndex(function (viewCellsDataRow) {\n    return checkCellGroupingInfo(viewCellsDataRow[0], appointment);\n  });\n  return index * groupCount / viewCellsData.length;\n};\n\nvar sliceAppointmentsByBoundaries = function sliceAppointmentsByBoundaries(appointment, left, right, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start.clone();\n  var endDate = appointment.end.clone();\n  var nextStart = startDate.clone();\n  var nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left)) {\n    nextStart = moment(left);\n    nextStart.startOf('day');\n  }\n\n  if (endDate.isAfter(right)) {\n    nextEnd = moment(right);\n    nextEnd.endOf('day');\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === startDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) !== -1 && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === endDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextEnd.day();\n    }) !== -1 && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n\n  return [_assign(_assign({}, appointment), {\n    start: nextStart,\n    end: nextEnd\n  })];\n};\n\nvar sliceAppointmentsByDays = function sliceAppointmentsByDays(appointment, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start;\n  var endDate = appointment.end;\n  var nextStart = startDate.clone();\n  var appointments = [];\n\n  while (nextStart.isBefore(endDate)) {\n    if (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) === -1) {\n      appointments.push(_assign(_assign({}, appointment), {\n        start: nextStart,\n        end: moment(nextStart).endOf('day')\n      }));\n    }\n\n    nextStart = moment(nextStart).add(1, 'day');\n  }\n\n  return appointments;\n};\n\nvar DEFAULT_RULE_OBJECT = {\n  interval: 1\n};\nvar DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6\n};\nvar RRULE_DAYS_OF_WEEK = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR, RRule.SA, RRule.SU];\nvar DAYS_IN_WEEK = 7;\nvar DAYS_OF_WEEK_ARRAY = [DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY, DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY];\nvar MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12\n};\nvar RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY,\n  MONTHLY: RRule.MONTHLY,\n  WEEKLY: RRule.WEEKLY,\n  DAILY: RRule.DAILY,\n  HOURLY: RRule.HOURLY,\n  MINUTELY: RRule.MINUTELY\n};\nvar REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never'\n};\nvar REPEAT_TYPES_ARRAY = [REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY];\nvar WEEK_NUMBER_LABELS = ['firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel'];\nvar END_REPEAT_RADIO_GROUP = 'endRepeat';\nvar MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nvar YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\nvar TITLE_TEXT_EDITOR = 'titleTextEditor';\nvar MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nvar ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nvar NUMBER_EDITOR = 'numberEditor';\nvar TITLE = 'title';\nvar ORDINARY_LABEL = 'ordinaryLabel';\nvar SAVE_BUTTON = 'saveButton';\nvar DELETE_BUTTON = 'deleteButton';\nvar CANCEL_BUTTON = 'cancelButton';\nvar OUTLINED_SELECT = 'outlinedSelect';\nvar STANDARD_SELECT = 'standardSelect';\nvar SUNDAY_DATE = new Date(2019, 7, 11);\nvar MONDAY_DATE = new Date(2019, 7, 12);\nvar TUESDAY_DATE = new Date(2019, 7, 13);\nvar WEDNESDAY_DATE = new Date(2019, 7, 14);\nvar THURSDAY_DATE = new Date(2019, 7, 15);\nvar FRIDAY_DATE = new Date(2019, 7, 16);\nvar SATURDAY_DATE = new Date(2019, 7, 17);\nvar DAYS_OF_WEEK_DATES = [SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE, THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE];\nvar JANUARY_DATE = new Date(2019, 0, 1);\nvar FEBRUARY_DATE = new Date(2019, 1, 1);\nvar MARCH_DATE = new Date(2019, 2, 1);\nvar APRIL_DATE = new Date(2019, 3, 1);\nvar MAY_DATE = new Date(2019, 4, 1);\nvar JUNE_DATE = new Date(2019, 5, 1);\nvar JULY_DATE = new Date(2019, 6, 1);\nvar AUGUST_DATE = new Date(2019, 7, 1);\nvar SEPTEMBER_DATE = new Date(2019, 8, 1);\nvar OCTOBER_DATE = new Date(2019, 9, 1);\nvar NOVEMBER_DATE = new Date(2019, 10, 1);\nvar DECEMBER_DATE = new Date(2019, 11, 1);\nvar MONTHS_DATES = [JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE, JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE];\nvar FIRST_WEEK = 0;\nvar SECOND_WEEK = 1;\nvar THIRD_WEEK = 2;\nvar FOURTH_WEEK = 3;\nvar LAST_WEEK = 4;\nvar BASIC_YEALY_COUNT = 5;\nvar BASIC_MONTHLY_COUNT = 12;\nvar BASIC_WEEKLY_COUNT = 13;\nvar BASIC_DAILY_COUNT = 30;\n\nvar sliceAppointmentByWeek = function sliceAppointmentByWeek(timeBounds, appointment, step) {\n  var left = timeBounds.left,\n      right = timeBounds.right;\n  var pieces = [];\n\n  var start = appointment.start,\n      end = appointment.end,\n      key = appointment.key,\n      restFields = __rest(appointment, [\"start\", \"end\", \"key\"]);\n\n  var apptStart = start;\n  var apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  var pieceFrom = apptStart.clone();\n  var pieceTo = apptStart.clone();\n  var i = 0;\n\n  while (pieceTo.isBefore(apptEnd)) {\n    var currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push(_assign({\n          start: pieceFrom,\n          end: pieceTo,\n          key: addDateToKey(key, pieceFrom)\n        }, restFields));\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n\n    i += 1;\n  }\n\n  return pieces;\n};\n\nvar getMonthCellIndexByAppointmentData = function getMonthCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupedByDate = viewMetaData.groupedByDate,\n      groupCount = viewMetaData.groupCount;\n  var startViewDate = moment(viewCellsData[0][0].startDate);\n  var currentDate = moment(date);\n  var dayNumber = currentDate.diff(startViewDate, 'days');\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    dayNumber -= 1;\n  }\n\n  var weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);\n  var dayOfWeek = dayNumber % DAYS_IN_WEEK;\n  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getMonthHorizontallyGroupedColumnIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate) : dayOfWeek;\n  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? weekNumber : getMonthVerticallyGroupedRowIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount);\n  var totalCellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return totalCellIndex;\n};\n\nvar getMonthHorizontallyGroupedColumnIndex = function getMonthHorizontallyGroupedColumnIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) {\n  var columnIndex = -1;\n  var currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;\n  var cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;\n\n  while (columnIndex === -1) {\n    var isCorrectCell = checkCellGroupingInfo(viewCellsData[weekNumber][currentColumnIndex], appointment);\n\n    if (isCorrectCell) {\n      columnIndex = currentColumnIndex;\n    }\n\n    currentColumnIndex += cellsInGroupRow;\n  }\n\n  return columnIndex;\n};\n\nvar getMonthVerticallyGroupedRowIndex = function getMonthVerticallyGroupedRowIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount) {\n  var rowsInOneGroup = viewCellsData.length / groupCount;\n  var rowIndex = -1;\n  var currentRowIndex = weekNumber;\n\n  while (rowIndex === -1) {\n    var isCorrectCell = checkCellGroupingInfo(viewCellsData[currentRowIndex][dayOfWeek], appointment);\n\n    if (isCorrectCell) {\n      rowIndex = currentRowIndex;\n    }\n\n    currentRowIndex += rowsInOneGroup;\n  }\n\n  return rowIndex;\n};\n\nvar TOP_CELL_OFFSET = 0.32;\nvar CELL_BOUND_OFFSET_PX = 1;\n\nvar getCellRect$1 = function getCellRect$1(date, appointment, viewCellsData, viewMetaData, cellElementsMeta, takePrev, multiline) {\n  var cellIndex = multiline ? getMonthCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) : getAllDayCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev);\n\n  var _a = cellElementsMeta.getCellRects[cellIndex](),\n      top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    height: height,\n    parentRect: parentRect\n  };\n};\n\nvar getHorizontalRectByAppointmentData = function getHorizontalRectByAppointmentData(appointment, viewMetaData, _a) {\n  var multiline = _a.multiline,\n      viewCellsData = _a.viewCellsData,\n      cellElementsMeta = _a.cellElementsMeta;\n  var firstCellRect = getCellRect$1(appointment.start.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, false, multiline);\n  var lastCellRect = getCellRect$1(appointment.end.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, true, multiline);\n  var top = firstCellRect.top + firstCellRect.height * TOP_CELL_OFFSET;\n  var height = firstCellRect.height - firstCellRect.height * TOP_CELL_OFFSET;\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_OFFSET_PX,\n    width: lastCellRect.left - firstCellRect.left + firstCellRect.width - CELL_BOUND_OFFSET_PX,\n    height: height,\n    parentWidth: firstCellRect.parentRect.width\n  };\n};\n\nvar DAY_COUNT = 7;\nvar MONTH_LENGTH = 31;\n\nvar monthCellsData = function monthCellsData(currentDate, firstDayOfWeek, intervalCount, today) {\n  if (intervalCount === void 0) {\n    intervalCount = 1;\n  }\n\n  var targetDate = moment(currentDate);\n  var currentMonths = [targetDate.month()];\n\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n\n  var firstMonthDate = moment(currentDate).date(1);\n  var firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  var prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  var prevMonth = moment(currentDate).subtract(1, 'months');\n  var prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  var from = moment().year(prevMonth.year()).month(prevMonth.month()).date(prevMonthStartDay).startOf('day');\n  var result = [];\n\n  while (result.length < Math.trunc(MONTH_LENGTH * intervalCount / DAY_COUNT) + 2) {\n    var week = [];\n\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(function (month) {\n          return month === from.month();\n        }) === -1,\n        today: today ? moment(today).isSame(from, 'date') : false\n      });\n      from.add(1, 'day');\n    }\n\n    result.push(week);\n  }\n\n  return result;\n};\n\nvar calculateMonthDateIntervals = function calculateMonthDateIntervals(appointments, leftBound, rightBound) {\n  return [appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return _assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, [], false));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByWeek({\n      left: moment(leftBound),\n      right: moment(rightBound)\n    }, appointment, DAY_COUNT));\n  }, [])];\n};\n\nvar calculateAllDayDateIntervals = function calculateAllDayDateIntervals(appointments, leftBound, rightBound, excludedDays) {\n  return [appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return _assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false));\n  }, []).filter(function (appointment) {\n    return allDayPredicate(appointment);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays));\n  }, [])];\n};\n\nvar getGroupFromResourceInstance = function getGroupFromResourceInstance(resourceInstance) {\n  return {\n    id: resourceInstance.id,\n    fieldName: resourceInstance.fieldName,\n    text: resourceInstance.text\n  };\n};\n\nvar addGroupInfoToCells = function addGroupInfoToCells(currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation) {\n  return viewCellRow.map(function (viewCell, cellIndex) {\n    var groupedCell = addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation);\n    return cellIndex === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? _assign(_assign({}, groupedCell), {\n      endOfGroup: true\n    }) : groupedCell;\n  });\n};\n\nvar addGroupInfoToCell = function addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) {\n  var previousIndex = index;\n  var groupingInfo = groups.reduceRight(function (acc, group, currentIndex) {\n    if (currentIndex === groups.length - 1) return acc;\n    var previousResourceLength = sortedResources[currentIndex + 1].instances.length;\n    var currentGroupingInstance = group[Math.floor(previousIndex / previousResourceLength)];\n    previousIndex = currentIndex;\n    return __spread(acc, [currentGroupingInstance]);\n  }, [currentGroup]);\n  return _assign(_assign({}, viewCell), {\n    groupingInfo: groupingInfo,\n    endOfGroup: endOfGroup,\n    groupOrientation: groupOrientation\n  });\n};\n\nvar getCurrentGroup = function getCurrentGroup(groups, resources, index, group) {\n  var currentIndex = index;\n  return groups.reduceRight(function (groupAcc, groupsRow, rowIndex) {\n    if (rowIndex === groups.length - 1) {\n      return groupAcc;\n    }\n\n    currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);\n    var currentInstance = groupsRow[currentIndex];\n    return __spread(groupAcc, [currentInstance]);\n  }, [group]);\n};\n\nvar groupAppointments = function groupAppointments(appointments, resources, groups) {\n  if (!resources || !groups) return [appointments.slice()];\n  var mainResource = resources.find(function (resource) {\n    return resource.isMain;\n  });\n  return groups[groups.length - 1].map(function (group, index) {\n    var currentGroup = getCurrentGroup(groups, resources, index, group);\n    return appointments.reduce(function (acc, appointment) {\n      var _a;\n\n      var belongsToGroup = currentGroup.reduce(function (isBelonging, groupItem) {\n        return isBelonging && groupItem.id === appointment[groupItem.fieldName];\n      }, true);\n      if (!belongsToGroup) return acc;\n      var currentMainResourceId = currentGroup.find(function (groupItem) {\n        return groupItem.fieldName === mainResource.fieldName;\n      }).id;\n\n      var updatedAppointment = _assign(_assign({}, appointment), {\n        dataItem: _assign(_assign({}, appointment.dataItem), (_a = {}, _a[mainResource.fieldName] = rearrangeResourceIds(mainResource, appointment, currentMainResourceId), _a)),\n        resources: appointment.resources && rearrangeResources(mainResource, appointment, currentMainResourceId)\n      });\n\n      return __spread(acc, [updatedAppointment]);\n    }, []);\n  });\n};\n\nvar rearrangeResourceIds = function rearrangeResourceIds(mainResource, appointment, mainResourceId) {\n  if (!mainResource.allowMultiple) {\n    return mainResourceId;\n  }\n\n  return __spread([mainResourceId], appointment.dataItem[mainResource.fieldName].filter(function (id) {\n    return id !== mainResourceId;\n  }));\n};\n\nvar rearrangeResources = function rearrangeResources(mainResource, appointment, currentResourceInstanceId) {\n  var _a;\n\n  if (!mainResource.allowMultiple) {\n    return appointment.resources;\n  }\n\n  var resources = appointment.resources.slice();\n  var firstMainResource = resources.findIndex(function (el) {\n    return el.isMain;\n  });\n  var currentResourceIndex = resources.findIndex(function (el) {\n    return el.isMain && el.id === currentResourceInstanceId;\n  });\n  _a = __read([resources[currentResourceIndex], resources[firstMainResource]], 2), resources[firstMainResource] = _a[0], resources[currentResourceIndex] = _a[1];\n  return resources;\n};\n\nvar expandGroupedAppointment = function expandGroupedAppointment(appointment, grouping, resources) {\n  if (!resources || !grouping) {\n    return [appointment];\n  }\n\n  return resources.reduce(function (acc, resource) {\n    var isGroupedByResource = grouping.find(function (group) {\n      return group.resourceName === resource.fieldName;\n    }) !== undefined;\n    if (!isGroupedByResource) return acc;\n    var resourceField = resource.fieldName;\n\n    if (!resource.allowMultiple) {\n      return acc.reduce(function (accumulatedAppointments, currentAppointment) {\n        var _a;\n\n        return __spread(accumulatedAppointments, [_assign(_assign({}, currentAppointment), (_a = {}, _a[resourceField] = currentAppointment.dataItem[resourceField], _a))]);\n      }, []);\n    }\n\n    return acc.reduce(function (accumulatedAppointments, currentAppointment) {\n      return __spread(accumulatedAppointments, currentAppointment.dataItem[resourceField].map(function (resourceValue) {\n        var _a;\n\n        return _assign(_assign({}, currentAppointment), (_a = {}, _a[resourceField] = resourceValue, _a.key = generateMultipleResourceKey(currentAppointment.key, resourceValue), _a));\n      }));\n    }, []);\n  }, [appointment]);\n};\n\nvar generateMultipleResourceKey = function generateMultipleResourceKey(previousKey, resourceValue) {\n  return previousKey + \"_\" + resourceValue;\n};\n\nvar getGroupingInfoFromGroups = function getGroupingInfoFromGroups(groups, groupIndex) {\n  var previousIndex = groupIndex;\n  return groups.reduceRight(function (acc, currentGroups, currentIndex) {\n    if (currentIndex === groups.length - 1) return acc;\n    var previousResourceLength = groups[currentIndex + 1].length / currentGroups.length;\n    var currentGroupingInstance = currentGroups[Math.floor(previousIndex / previousResourceLength)];\n    previousIndex = currentIndex;\n    return __spread(acc, [currentGroupingInstance]);\n  }, [getGroupsLastRow(groups)[groupIndex]]);\n};\n\nvar getGroupsLastRow = function getGroupsLastRow(groups) {\n  return groups[groups.length - 1];\n};\n\nvar filterResourcesByGrouping = function filterResourcesByGrouping(resources, grouping) {\n  return resources.filter(function (resource) {\n    return grouping.find(function (resourceId) {\n      return resource.fieldName === resourceId.resourceName;\n    });\n  });\n};\n\nvar sortFilteredResources = function sortFilteredResources(resources, grouping) {\n  return grouping.map(function (_a) {\n    var resourceName = _a.resourceName;\n    return resources.find(function (resource) {\n      return resource.fieldName === resourceName;\n    });\n  });\n};\n\nvar getGroupsFromResources = function getGroupsFromResources(sortedAndFilteredResources) {\n  return sortedAndFilteredResources.reduce(function (acc, resource, index) {\n    if (index === 0) {\n      return [resource.instances.map(function (instance) {\n        return getGroupFromResourceInstance(instance);\n      })];\n    }\n\n    return __spread(acc, [acc[index - 1].reduce(function (currentResourceNames) {\n      return __spread(currentResourceNames, resource.instances.map(function (instance) {\n        return getGroupFromResourceInstance(instance);\n      }));\n    }, [])]);\n  }, []);\n};\n\nvar expandViewCellsDataWithGroups = function expandViewCellsDataWithGroups(viewCellsData, groups, sortedResources, groupByDate, groupOrientation) {\n  if (groups.length === 0) return viewCellsData;\n\n  if (groupByDate) {\n    return expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources);\n  }\n\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources);\n  }\n\n  return expandVerticallyGroupedCells(viewCellsData, groups, sortedResources);\n};\n\nvar expandCellsWithGroupedByDateData = function expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources) {\n  return viewCellsData.map(function (cellsRow) {\n    return cellsRow.reduce(function (acc, viewCell) {\n      var groupedCells = getGroupsLastRow(groups).map(function (group, index) {\n        return addGroupInfoToCell(group, groups, sortedResources, viewCell, index, false, HORIZONTAL_GROUP_ORIENTATION);\n      });\n      groupedCells[groupedCells.length - 1] = _assign(_assign({}, groupedCells[groupedCells.length - 1]), {\n        endOfGroup: true\n      });\n      return __spread(acc, groupedCells);\n    }, []);\n  });\n};\n\nvar expandHorizontallyGroupedCells = function expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources) {\n  return getGroupsLastRow(groups).reduce(function (acc, group, index) {\n    if (index === 0) {\n      return viewCellsData.map(function (viewCellsRow) {\n        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, false, HORIZONTAL_GROUP_ORIENTATION);\n      });\n    }\n\n    return acc.map(function (item, id) {\n      return __spread(item, addGroupInfoToCells(group, groups, sortedResources, viewCellsData[id], index, false, HORIZONTAL_GROUP_ORIENTATION));\n    });\n  }, [[]]);\n};\n\nvar expandVerticallyGroupedCells = function expandVerticallyGroupedCells(viewCellsData, groups, sortedResources) {\n  return getGroupsLastRow(groups).reduce(function (acc, group, index) {\n    if (index === 0) {\n      return viewCellsData.map(function (viewCellsRow, viewRowIndex) {\n        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);\n      });\n    }\n\n    return __spread(acc, viewCellsData.map(function (viewCellsRow, viewRowIndex) {\n      return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);\n    }));\n  }, [[]]);\n};\n\nvar updateGroupingWithMainResource = function updateGroupingWithMainResource(grouping, resources) {\n  return grouping || [{\n    resourceName: resources.find(function (resource) {\n      return resource.isMain;\n    }).fieldName\n  }];\n};\n\nvar expandGroups = function expandGroups(appointments, grouping, resources, groups, excludedDays, sliceByDay) {\n  if (sliceByDay === void 0) {\n    sliceByDay = false;\n  }\n\n  var slicedAppointments = sliceByDay ? appointments[0].reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByDays(appointment, excludedDays));\n  }, []) : appointments[0];\n  var expandedAppointments = slicedAppointments.reduce(function (acc, appointment) {\n    return __spread(acc, expandGroupedAppointment(appointment, grouping, resources));\n  }, []);\n  return groupAppointments(expandedAppointments, resources, groups);\n};\n\nvar updateTimeTableCellElementsMeta = function updateTimeTableCellElementsMeta(timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView) {\n  if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {\n    return timeTableElementsMeta;\n  }\n\n  var _a = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups),\n      groupCount = _a.groupCount,\n      timeTableWidth = _a.timeTableWidth,\n      groupSize = _a.groupSize,\n      validGetCellRects = _a.validGetCellRects;\n\n  var allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(allDayPanelsLeft * (timeTableWidth + groupSize), timeTableWidth);\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects\n  };\n};\n\nvar updateAllDayCellElementsMeta = function updateAllDayCellElementsMeta(allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView) {\n  if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {\n    return allDayElementsMeta;\n  }\n\n  var _a = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups),\n      groupCount = _a.groupCount,\n      timeTableWidth = _a.timeTableWidth,\n      groupSize = _a.groupSize,\n      validGetCellRects = _a.validGetCellRects;\n\n  var allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(groupSize * allDayPanelsLeft + timeTableWidth * (allDayPanelsLeft + 1), groupSize);\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects\n  };\n};\n\nvar checkCellElementsMeta = function checkCellElementsMeta(cellElementsMeta, groupOrientation, currentView, allDayPanelExists) {\n  return groupOrientation(currentView.name) === HORIZONTAL_GROUP_ORIENTATION || !allDayPanelExists || !cellElementsMeta.getCellRects;\n};\n\nvar initializeCellElementsData = function initializeCellElementsData(cellElementsMeta, viewCellsData, groups) {\n  var timeTableWidth = viewCellsData[0].length;\n  var groupCount = getGroupsLastRow(groups).length;\n  var groupHeight = viewCellsData.length / groupCount;\n  return {\n    groupCount: groupCount,\n    timeTableWidth: timeTableWidth,\n    groupSize: timeTableWidth * groupHeight,\n    validGetCellRects: cellElementsMeta.getCellRects.slice()\n  };\n};\n\nvar updateTimeCellsData = function updateTimeCellsData(viewCellsData, timeCellsData, groups, sortedResources, groupOrientation) {\n  var firstViewDate = viewCellsData[0][0].startDate;\n\n  if (!containsDSTChange(firstViewDate)) {\n    return viewCellsData;\n  }\n\n  if (groupOrientation !== VERTICAL_GROUP_ORIENTATION) {\n    return timeCellsData;\n  }\n\n  return expandVerticallyGroupedCells(timeCellsData, groups, sortedResources);\n};\n\nvar allDayRects = function allDayRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {\n  var intervals = calculateAllDayDateIntervals(appointments, startViewDate, endViewDate, excludedDays);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, sliceAppointments);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: false\n  }, groupedIntervals, getHorizontalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta,\n    excludedDays: excludedDays\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: sliceAppointments,\n    groupCount: groups ? getGroupsLastRow(groups).length : 1\n  });\n};\n\nvar verticalTimeTableRects = function verticalTimeTableRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration, cellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate) {\n  var intervals = calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, false);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: VERTICAL_TYPE,\n    multiline: false\n  }, groupedIntervals, getVerticalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    cellElementsMeta: cellElementsMeta\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: groupByDate,\n    groupCount: groups ? getGroupsLastRow(groups).length : 1\n  });\n};\n\nvar horizontalTimeTableRects = function horizontalTimeTableRects(appointments, startViewDate, endViewDate, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {\n  var intervals = calculateMonthDateIntervals(appointments, startViewDate, endViewDate);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, [], sliceAppointments);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: true\n  }, groupedIntervals, getHorizontalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: sliceAppointments,\n    groupCount: groups ? getGroupsLastRow(groups).length : 1\n  });\n};\n\nvar dateTimeFormatInstance = function dateTimeFormatInstance(locale, formatOptions) {\n  return new Intl.DateTimeFormat(locale, formatOptions);\n};\n\nvar appointments = function appointments(data) {\n  return data.map(function (appointment, index) {\n    return _assign(_assign(_assign(_assign(_assign({\n      dataItem: appointment,\n      start: appointment.startDate\n    }, appointment.endDate !== undefined ? {\n      end: appointment.endDate\n    } : {\n      end: appointment.startDate,\n      dataItem: _assign(_assign({}, appointment), {\n        endDate: appointment.startDate\n      })\n    }), appointment.allDay !== undefined && {\n      allDay: appointment.allDay\n    }), appointment.rRule !== undefined && {\n      rRule: appointment.rRule\n    }), appointment.exDate !== undefined && {\n      exDate: appointment.exDate\n    }), {\n      key: appointment.id || index\n    });\n  });\n};\n\nvar formatDateTimeGetter = function formatDateTimeGetter(locale) {\n  var cache = new Map(); // any -> type\n\n  var formatter = function formatter(nextDate, nextOptions) {\n    if (nextDate === undefined) return '';\n    var date = convertToMoment(nextDate).toDate();\n    var formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n\n  return formatter;\n};\n\nvar getCellKey = function getCellKey(groups, groupIndex, rowNumber) {\n  var currentIndex = groupIndex;\n  return groups.reduceRight(function (acc, groupRow, rowIndex) {\n    if (rowNumber < rowIndex) return acc;\n    var currentKey = groupRow[currentIndex].id;\n\n    if (rowIndex > 0) {\n      var currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;\n      currentIndex = Math.floor(currentIndex / currentRowLength);\n    }\n\n    return acc + currentKey;\n  }, '');\n};\n\nvar getRowFromGroups = function getRowFromGroups(width, groupRow, cellStyle, groups, rowIndex) {\n  var row = [];\n  var currentRowLength = groupRow.length;\n  var standardWidth = width / getGroupsLastRow(groups).length;\n  var colSpan = getGroupsLastRow(groups).length / currentRowLength;\n\n  var _loop_1 = function _loop_1(i) {\n    row = __spread(row, groupRow.reduce(function (acc, group, index) {\n      return __spread(acc, [{\n        group: group,\n        colSpan: colSpan,\n        key: getCellKey(groups, index, rowIndex) + i,\n        left: cellStyle.left,\n        endOfGroup: index === currentRowLength - 1\n      }]);\n    }, []));\n  };\n\n  for (var i = 0; i < standardWidth; i += 1) {\n    _loop_1(i);\n  }\n\n  return row;\n};\n\nvar getVerticalRowFromGroups = function getVerticalRowFromGroups(groups, groupIndex, groupingPanelRowSpan, timeTableCellHeight, addAllDayHeight, allDayCellHeight) {\n  return groups.reduce(function (acc, groupColumn, columnIndex) {\n    var groupSpan = getGroupsLastRow(groups).length / groupColumn.length;\n    var cellIndex = groupIndex / groupSpan;\n    var baseHeight = groupingPanelRowSpan * groupSpan * timeTableCellHeight / getGroupsLastRow(groups).length;\n    var allDayHeight = groupSpan * allDayCellHeight;\n    return groupIndex % groupSpan !== 0 ? acc : __spread(acc, [{\n      group: groupColumn[cellIndex],\n      rowSpan: groupSpan,\n      height: addAllDayHeight ? baseHeight + allDayHeight : baseHeight,\n      key: getCellKey(groups, cellIndex, columnIndex)\n    }]);\n  }, []);\n};\n\nvar getLabelsForSingleGroup = function getLabelsForSingleGroup(groups, cellsData, groupIndex, groupHeight) {\n  var currentGroupIndex = groupIndex * groupHeight;\n  var nextGroupIndex = currentGroupIndex + groupHeight;\n  return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce(function (acc, days) {\n    return __spread(acc, [{\n      startDate: days[0].startDate,\n      endDate: days[0].endDate,\n      key: days[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),\n      groupingInfo: days[0].groupingInfo\n    }]);\n  }, []);\n};\n\nvar getLabelsForAllGroups = function getLabelsForAllGroups(cellsData, groups, groupOrientation) {\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return [cellsData.map(function (cellsRow) {\n      return {\n        startDate: cellsRow[0].startDate,\n        endDate: cellsRow[0].endDate,\n        groupingInfo: cellsRow[0].groupingInfo,\n        key: cellsRow[0].endDate\n      };\n    })];\n  }\n\n  var groupCount = getGroupsLastRow(groups).length;\n  var singleGroupHeight = cellsData.length / groupCount;\n  return getGroupsLastRow(groups).reduce(function (acc, group, groupIndex) {\n    return __spread(acc, [getLabelsForSingleGroup(groups, cellsData, groupIndex, singleGroupHeight)]);\n  }, []);\n};\n\nvar prepareVerticalViewCellsData = function prepareVerticalViewCellsData(cellsData, allDayCellsData) {\n  var groupCount = (allDayCellsData === null || allDayCellsData === void 0 ? void 0 : allDayCellsData.length) || 1;\n  var validCellsData = [];\n  var groupHeight = cellsData.length / groupCount;\n\n  for (var i = 0; i < groupCount; i += 1) {\n    validCellsData.push(cellsData.slice(i * groupHeight, (i + 1) * groupHeight));\n  }\n\n  return validCellsData;\n};\n\nvar changeCurrentDate = function changeCurrentDate(currentDate, _a) {\n  var nextDate = _a.nextDate,\n      step = _a.step,\n      amount = _a.amount,\n      direction = _a.direction;\n  return nextDate || moment(currentDate)[direction === 'back' ? 'subtract' : 'add'](amount, step).toDate() || moment().subtract(amount, step);\n};\n\nvar setCurrentViewName = function setCurrentViewName(currentViewName, nextViewName) {\n  return nextViewName;\n};\n\nvar setAppointmentMeta = function setAppointmentMeta(prevAppointmentMeta, _a) {\n  var target = _a.target,\n      data = _a.data;\n  return {\n    target: target,\n    data: data\n  };\n};\n\nvar OPEN_COMMAND_BUTTON = 'open';\nvar CLOSE_COMMAND_BUTTON = 'close';\nvar DELETE_COMMAND_BUTTON = 'delete';\nvar CANCEL_COMMAND_BUTTON = 'cancel';\nvar COMMIT_COMMAND_BUTTON = 'commit';\n\nvar setAppointmentData = function setAppointmentData(prevAppointmentData, _a) {\n  var appointmentData = _a.appointmentData;\n  return appointmentData;\n};\n\nvar getWeekNumberLabels = function getWeekNumberLabels(getMessage) {\n  return WEEK_NUMBER_LABELS.map(function (weekNumberLabel, index) {\n    return {\n      text: getMessage(weekNumberLabel),\n      id: index\n    };\n  });\n};\n\nvar getDaysOfWeek = function getDaysOfWeek(formatDate, firstDayOfWeek) {\n  var daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  var daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(function (day, index) {\n    return {\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0]\n    };\n  });\n};\n\nvar getMonths = function getMonths(formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonth(month, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthsWithOf = function getMonthsWithOf(getMessage, formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonthWithOf(month, getMessage, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthWithOf = function getMonthWithOf(date, getMessage, formatDate) {\n  return getMessage('ofLabel') + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n};\n\nvar getMonth = function getMonth(date, formatDate) {\n  return formatDate(date, LONG_MONTH_OPTIONS);\n};\n\nvar getDayOfWeek = function getDayOfWeek(date, formatDate) {\n  return formatDate(date, LONG_WEEK_DAY_OPTIONS);\n};\n\nvar getMonthId = function getMonthId(index) {\n  return index + 1;\n};\n\nvar getAvailableRecurrenceOptions = function getAvailableRecurrenceOptions(getMessage) {\n  return REPEAT_TYPES_ARRAY.map(function (type) {\n    return {\n      text: getMessage(type),\n      id: type\n    };\n  });\n};\n\nvar getCountDependingOnRecurrenceType = function getCountDependingOnRecurrenceType(frequency) {\n  var count;\n\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n\n  return count;\n};\n\nvar checkIsNaturalNumber = function checkIsNaturalNumber(number) {\n  return number > 0 && number <= Number.MAX_SAFE_INTEGER;\n};\n\nvar callActionIfExists = function callActionIfExists(action, payload) {\n  if (action) {\n    action(payload);\n  }\n};\n\nvar isAllDayCell = function isAllDayCell(startDate, endDate) {\n  return moment(endDate).diff(moment(startDate), 'days') >= 1;\n};\n\nvar changeRecurrenceFrequency = function changeRecurrenceFrequency(rule, freq, startDate) {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n      freq: freq,\n      count: getCountDependingOnRecurrenceType(freq)\n    })).toString();\n  }\n\n  var options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n\n  options.byweekday = undefined;\n  var nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nvar getRecurrenceOptions = function getRecurrenceOptions(rule) {\n  return !rule ? null : RRule.parseString(rule);\n};\n\nvar changeRecurrenceOptions = function changeRecurrenceOptions(options) {\n  return options ? new RRule(_assign({}, options)).toString() : undefined;\n};\n\nvar handleStartDateChange = function handleStartDateChange(nextStartDay, options) {\n  if (nextStartDay <= 31) {\n    var nextOptions = _assign(_assign({}, options), {\n      bymonthday: nextStartDay\n    });\n\n    return changeRecurrenceOptions(nextOptions);\n  }\n\n  return changeRecurrenceOptions(options);\n};\n\nvar handleToDayOfWeekChange = function handleToDayOfWeekChange(weekNumber, dayOfWeek, options) {\n  var validDayOfWeek = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  var validWeekNumber = weekNumber === 4 ? -1 : weekNumber + 1;\n  var rruleDayOfWeek = RRULE_DAYS_OF_WEEK[validDayOfWeek];\n\n  var nextOptions = _assign(_assign({}, options), {\n    byweekday: [rruleDayOfWeek.nth(validWeekNumber)],\n    bymonthday: undefined\n  });\n\n  return changeRecurrenceOptions(nextOptions);\n};\n\nvar getRRuleFrequency = function getRRuleFrequency(repeatType) {\n  return RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n};\n\nvar getFrequencyString = function getFrequencyString(rRuleFrequency) {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nvar getRadioGroupDisplayData = function getRadioGroupDisplayData(recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption) {\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: recurrenceOptions.bymonthday,\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption\n    };\n  }\n\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber\n    };\n  }\n\n  var dayOfWeek = recurrenceOptions.byweekday[0].weekday < 6 ? recurrenceOptions.byweekday[0].weekday + 1 : 0;\n  var weekNumber = recurrenceOptions.byweekday[0].n === -1 ? LAST_WEEK : recurrenceOptions.byweekday[0].n - 1;\n  return {\n    dayOfWeek: dayOfWeek,\n    weekNumber: weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber\n  };\n};\n\nvar handleChangeFrequency = function handleChangeFrequency(repeatType, rRule, startDate, action) {\n  var rruleRepeatType = getRRuleFrequency(repeatType);\n  var nextRRule;\n\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(rRule, rruleRepeatType, startDate);\n  }\n\n  action({\n    rRule: nextRRule\n  });\n};\n\nvar handleWeekDaysChange = function handleWeekDaysChange(options, currentWeekDay) {\n  var byWeekDay = options.byweekday || [];\n  var index = byWeekDay.findIndex(function (_a) {\n    var weekday = _a.weekday;\n    return weekday === currentWeekDay;\n  });\n  var isAdded = index === -1;\n\n  if (isAdded) {\n    byWeekDay.push(RRULE_DAYS_OF_WEEK[currentWeekDay]);\n  } else if (index > -1) {\n    byWeekDay.splice(index, 1);\n  }\n\n  if (byWeekDay === 0) return _assign(_assign({}, options), {\n    byweekday: undefined\n  });\n  return _assign(_assign({}, options), {\n    byweekday: byWeekDay\n  });\n};\n\nvar getDaysOfWeekArray = function getDaysOfWeekArray(firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1;\n  });\n  var secondPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1;\n  });\n  return firstDayOfWeek !== 0 ? __spread(firstPart, secondPart) : __spread(secondPart, firstPart);\n};\n\nvar getDaysOfWeekDates = function getDaysOfWeekDates(firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  var secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return __spread(firstPart, secondPart);\n};\n\nvar checkMultipleResourceFields = function checkMultipleResourceFields(resourceFields, resources) {\n  return resources.reduce(function (acc, resource) {\n    var _a;\n\n    if (!resource.allowMultiple) {\n      return acc;\n    }\n\n    var fieldName = resource.fieldName;\n    var field = resourceFields[fieldName];\n    return _assign(_assign({}, acc), (_a = {}, _a[fieldName] = Array.isArray(field) ? field : [field], _a));\n  }, resourceFields);\n};\n\nvar addAppointment = function addAppointment(addedAppointmentData, _a) {\n  var _b = _a === void 0 ? {\n    appointmentData: {}\n  } : _a,\n      appointmentData = _b.appointmentData;\n\n  return appointmentData;\n};\n\nvar cancelAddedAppointment = function cancelAddedAppointment() {\n  return {};\n};\n\nvar startEditAppointment = function startEditAppointment(prevEditingAppointment, appointmentData) {\n  return appointmentData;\n};\n\nvar stopEditAppointment = function stopEditAppointment() {\n  return undefined;\n};\n\nvar changeAppointment = function changeAppointment(appointment, _a) {\n  var change = _a.change;\n  return _assign(_assign({}, appointment), change);\n};\n\nvar cancelChanges = function cancelChanges() {\n  return {};\n};\n\nvar changedAppointmentById = function changedAppointmentById(changes, appointmentId) {\n  var _a;\n\n  return _a = {}, _a[appointmentId] = changes, _a;\n};\n\nvar mergeNewChanges = function mergeNewChanges(appointmentData, changes) {\n  var appointment = _assign({}, appointmentData);\n\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return _assign(_assign({}, appointment), changes);\n};\n\nvar reduceExDate = function reduceExDate(prevExDate, boundDate) {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce(function (acc, date) {\n      var momentDate = moment.utc(date);\n\n      if (momentDate.isBefore(boundDate)) {\n        return __spread(acc, [date]);\n      }\n\n      return acc;\n    }, []).join(',');\n  }\n\n  return undefined;\n};\n\nvar configureExDate = function configureExDate(exDate, date) {\n  var currentExDate = moment.utc(date).format('YYYYMMDDTHHmmss') + \"Z\";\n  return exDate ? exDate + \",\" + currentExDate : currentExDate;\n};\n\nvar configureDateSequence = function configureDateSequence(rRule, exDate, prevStartDate, nextStartDate) {\n  var rruleSet = getRRuleSetWithExDates(exDate);\n  var currentOptions = RRule.parseString(rRule);\n  var correctedOptions = currentOptions.until ? _assign(_assign({}, currentOptions), {\n    until: moment(getUTCDate(currentOptions.until)).toDate()\n  }) : currentOptions;\n  var prevStartDateUTC = moment(getUTCDate(prevStartDate)).toDate();\n  rruleSet.rrule(new RRule(_assign(_assign({}, correctedOptions), {\n    dtstart: prevStartDateUTC\n  })));\n\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all() // we shouldn't use `new Date(string)` because this function has different results in Safari\n    .map(function (nextDate) {\n      return moment(formatDateToString(nextDate)).toDate();\n    });\n  }\n\n  var leftBound = prevStartDateUTC;\n  var rightBound = moment(getUTCDate(nextStartDate)).toDate();\n  return rruleSet.between(leftBound, rightBound, true).map(function (nextDate) {\n    return moment(formatDateToString(nextDate)).toDate();\n  });\n};\n\nvar configureICalendarRules = function configureICalendarRules(rRule, options) {\n  var rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule(_assign(_assign({}, RRule.parseString(rRule)), options)));\n  return rruleSet.valueOf();\n};\n\nvar changeCurrentAndFollowing = function changeCurrentAndFollowing(appointmentData, changes, changeAllAction) {\n  var _a;\n\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      parentData = appointmentData.parentData,\n      _b = appointmentData.exDate,\n      prevExDate = _b === void 0 ? '' : _b,\n      id = appointmentData.id;\n\n  var _c = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _c.initialSequence,\n      currentChildIndex = _c.currentChildIndex;\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n  var changedRules = configureICalendarRules(rRule, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null\n  });\n  var nextExDate = reduceExDate(prevExDate, startDate);\n  return {\n    changed: (_a = {}, _a[id] = _assign({\n      rRule: changedRules[1].slice(6)\n    }, nextExDate && prevExDate !== nextExDate ? {\n      exDate: nextExDate\n    } : {}), _a)\n  };\n};\n\nvar getAppointmentSequenceData = function getAppointmentSequenceData(prevStartDate, startDate, exDate, rRule) {\n  var initialSequence = configureDateSequence(rRule, exDate, moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate());\n  var currentChildIndex = initialSequence.findIndex(function (date) {\n    return moment(date).isSame(startDate);\n  });\n  return {\n    initialSequence: initialSequence,\n    currentChildIndex: currentChildIndex\n  };\n};\n\nvar deleteCurrent = function deleteCurrent(appointmentData) {\n  var _a;\n\n  var currentSequence = configureDateSequence(appointmentData.rRule, appointmentData.exDate, moment.utc(appointmentData.parentData.startDate).toDate(), moment.utc(appointmentData.startDate).toDate());\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  var nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate);\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: nextExDate\n    }, _a)\n  };\n};\n\nvar deleteAll = function deleteAll(appointmentData) {\n  return {\n    deleted: appointmentData.id\n  };\n};\n\nvar deleteCurrentAndFollowing = function deleteCurrentAndFollowing(appointmentData) {\n  return changeCurrentAndFollowing(appointmentData, {}, deleteAll);\n};\n\nvar editAll = function editAll(appointmentData, changes) {\n  var _a, _b;\n\n  var rRule = appointmentData.rRule,\n      id = appointmentData.id;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  if (changes.startDate && moment.utc(changes.startDate).isAfter(initialRule.options.until)) {\n    return {\n      changed: (_a = {}, _a[id] = _assign(_assign({}, changes), {\n        rRule: 'FREQ=DAILY;COUNT=1',\n        exDate: ''\n      }), _a)\n    };\n  }\n\n  return {\n    changed: (_b = {}, _b[appointmentData.id] = changes, _b)\n  };\n};\n\nvar editCurrent = function editCurrent(appointmentData, changes) {\n  var _a;\n\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate)\n    }, _a),\n    added: mergeNewChanges(appointmentData, changes)\n  };\n};\n\nvar editCurrentAndFollowing = function editCurrentAndFollowing(appointmentData, changes) {\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      _a = appointmentData.exDate,\n      prevExDate = _a === void 0 ? '' : _a,\n      parentData = appointmentData.parentData;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  var _b = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _b.initialSequence,\n      currentChildIndex = _b.currentChildIndex;\n\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n  var addedOptions = initialRule.options.count || initialRule.options.until ? {\n    count: initialSequence.length - currentChildIndex\n  } : {};\n  var addedRules = configureICalendarRules(appointmentData.rRule, _assign({\n    dtstart: moment.utc(startDate).toDate()\n  }, addedOptions));\n  var addedAppointment = moment.utc(changes.startDate).isAfter(initialRule.options.until) ? {\n    rRule: 'FREQ=DAILY;COUNT=1',\n    exDate: ''\n  } : {\n    rRule: addedRules[1].slice(6)\n  };\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: _assign(_assign({}, addedAppointment), mergeNewChanges(appointmentData, changes))\n  };\n};\n\nvar preCommitChanges = function preCommitChanges(changes, appointmentData, editType) {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return deleteAll(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return deleteCurrent(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return deleteCurrentAndFollowing(appointmentData);\n        }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return editAll(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return editCurrent(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return editCurrentAndFollowing(appointmentData, changes);\n        }\n    }\n  }\n\n  return {};\n};\n\nvar clamp = function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar calculateInsideOffset = function calculateInsideOffset(targetType, insidePart, cellDurationMinutes) {\n  return targetType === VERTICAL_TYPE ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n};\n\nvar cellType = function cellType(data) {\n  return moment(data.startDate).isSame(data.endDate, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n};\n\nvar intervalDuration = function intervalDuration(data, type) {\n  return moment(data.endDate).diff(data.startDate, type);\n};\n\nvar cellIndex = function cellIndex(getCellRects, clientOffset) {\n  return getCellRects.findIndex(function (getCellRect) {\n    var _a = getCellRect(),\n        left = _a.left,\n        top = _a.top,\n        right = _a.right,\n        bottom = _a.bottom;\n\n    var isOver = clientOffset && clamp(clientOffset.x, left, right) === clientOffset.x && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n    return isOver;\n  });\n};\n\nvar cellData = function cellData(timeTableIndex, allDayIndex, viewCellsData, allDayCellsData) {\n  var cellsData = allDayIndex !== -1 ? allDayCellsData : viewCellsData;\n  var currentIndex = allDayIndex !== -1 ? allDayIndex : timeTableIndex;\n  var tableWidth = cellsData[0].length;\n  var rowIndex = Math.floor(currentIndex / tableWidth);\n  var columnIndex = currentIndex % tableWidth;\n  return cellsData[rowIndex][columnIndex];\n};\n\nvar autoScroll = function autoScroll(clientOffset, scrollingStrategy, scrollSpeed) {\n  scroll(clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary, scrollingStrategy.changeVerticalScroll, scrollSpeed);\n  scroll(clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary, scrollingStrategy.changeHorizontalScroll, scrollSpeed);\n};\n\nvar scroll = function scroll(offset, firstBoundary, secondBoundary, changeScroll, scrollSpeed) {\n  if (offset < firstBoundary + SCROLL_OFFSET && offset > firstBoundary) {\n    changeScroll(-scrollSpeed);\n  }\n\n  if (secondBoundary - SCROLL_OFFSET < offset) {\n    changeScroll(+scrollSpeed);\n  }\n};\n\nvar timeBoundariesByResize = function timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart) {\n  if (targetType !== payload.appointmentType) {\n    return {\n      appointmentStartTime: undefined,\n      appointmentEndTime: undefined\n    };\n  }\n\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    var insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate).add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  if (sourceType === RESIZE_BOTTOM) {\n    var insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate).add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate).toDate();\n  } // keep origin appointment duration if coordinates are wrong\n\n\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime\n  };\n};\n\nvar timeBoundariesByDrag = function timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  if (targetType === HORIZONTAL_TYPE && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate,\n      appointmentEndTime: targetData.endDate,\n      offsetTimeTop: 0\n    };\n  }\n\n  var offsetTimeTop;\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  var start = moment(targetData.startDate).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate).diff(payload.startDate, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    var appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add(offsetTimeTop * -1, SECONDS).toDate();\n    appointmentEndTime = moment(start).add(appointmentDurationSeconds - offsetTimeTop, SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate).add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate).add(insideOffset, SECONDS).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime,\n    offsetTimeTop: offsetTimeTop\n  };\n};\n\nvar calculateAppointmentTimeBoundaries = function calculateAppointmentTimeBoundaries(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  var isDragging = payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE;\n  return isDragging ? timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) : timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart);\n};\n\nvar calculateInsidePart = function calculateInsidePart(top, timeTableCellsRects, timeTableIndex) {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    var cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n\n  return 0;\n};\n\nvar calculateDraftAppointments = function calculateDraftAppointments(allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, targetType, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate) {\n  if (allDayIndex !== -1 || targetType === VERTICAL_TYPE && getAllDayCellsElementRects.getCellRects.length && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23) {\n    var allDayDrafts = draftAppointments.map(function (draftAppt) {\n      return _assign(_assign({}, draftAppt), {\n        allDay: true\n      });\n    });\n    return {\n      allDayDraftAppointments: allDayRects(allDayDrafts, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, grouping, resources, groups, groupOrientation, groupedByDate),\n      timeTableDraftAppointments: []\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)\n    };\n  }\n\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(draftAppointments, startViewDate, endViewDate, viewCellsData, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)\n  };\n};\n\nvar calculateAppointmentGroups = function calculateAppointmentGroups(cellGroupingInfo, resources, appointmentData) {\n  if (!cellGroupingInfo) return {};\n  return cellGroupingInfo.reduce(function (acc, group) {\n    var _a;\n\n    var isMultipleResource = resources.find(function (resource) {\n      return resource.fieldName === group.fieldName;\n    }).allowMultiple;\n    return _assign(_assign({}, acc), (_a = {}, _a[group.fieldName] = isMultipleResource ? updateMultipleResourceInfo(group, appointmentData) : group.id, _a));\n  }, {});\n};\n\nvar updateMultipleResourceInfo = function updateMultipleResourceInfo(cellResource, appointmentData) {\n  var appointmentGroupItems = appointmentData[cellResource.fieldName];\n\n  if (appointmentGroupItems.findIndex(function (groupItem) {\n    return groupItem === cellResource.id;\n  }) !== -1) {\n    return appointmentGroupItems;\n  }\n\n  return [cellResource.id];\n};\n\nvar appointmentDragged = function appointmentDragged(start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) {\n  if (moment(start).isSame(startPrev) && moment(end).isSame(endPrev) && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar groupingInfoNotChanged = function groupingInfoNotChanged(groupingInfo, groupingInfoPrev) {\n  var fields = Object.getOwnPropertyNames(groupingInfo);\n  return fields.every(function (field) {\n    if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {\n      return groupingInfo[field].every(function (item, index) {\n        return item === groupingInfoPrev[field][index];\n      });\n    }\n\n    return groupingInfo[field] === groupingInfoPrev[field];\n  });\n};\n\nvar isMonthCell = function isMonthCell(otherMonth) {\n  return otherMonth !== undefined;\n};\n\nvar isShadedAppointment = function isShadedAppointment(_a, currentTime, shadePreviousAppointments) {\n  var appointmentData = _a.data;\n  var momentCurrentDate = moment(currentTime);\n\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate, 'day') && shadePreviousAppointments;\n  }\n\n  if (momentCurrentDate.isAfter(appointmentData.endDate)) {\n    return shadePreviousAppointments;\n  }\n\n  return false;\n};\n\nvar getCurrentTimeIndicatorTop = function getCurrentTimeIndicatorTop(cellData, currentTime) {\n  var top = (currentTime - cellData.startDate.getTime()) * 100 / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return top < 0 || top > 100 ? undefined : top + \"%\";\n};\n\nvar isCellShaded = function isCellShaded(_a, currentTime, shadePreviousCells) {\n  var startDate = _a.startDate,\n      endDate = _a.endDate,\n      otherMonth = _a.otherMonth;\n  var monthCell = isMonthCell(otherMonth);\n  return (startDate.getTime() < currentTime && !monthCell || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n\nvar getAppointmentResources = function getAppointmentResources(appointment, resources, plainResources) {\n  if (!resources || resources.length === 0 || !plainResources || plainResources.length === 0) return [];\n  return resources.reduce(function (acc, resource) {\n    var appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId) || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return __spread(acc, appointmentResourceId.reduce(function (prevResources, itemId) {\n        return addResourceToAppointmentResources(plainResources, prevResources, resource, itemId);\n      }, []));\n    }\n\n    return addResourceToAppointmentResources(plainResources, acc, resource, appointmentResourceId);\n  }, []);\n};\n\nvar addResourceToAppointmentResources = function addResourceToAppointmentResources(plainResources, appointmentResources, resource, resourceId) {\n  var currentResource = plainResources.find(function (plainItem) {\n    return resource.fieldName === plainItem.fieldName && plainItem.id === resourceId;\n  });\n  return currentResource ? __spread(appointmentResources, [currentResource]) : appointmentResources;\n};\n\nvar convertResourcesToPlain = function convertResourcesToPlain(validResources) {\n  return validResources.reduce(function (acc, resource) {\n    return __spread(acc, resource.instances.map(function (item) {\n      return item;\n    }));\n  }, []);\n};\n\nvar validateResources = function validateResources(resources, mainResourceName, palette) {\n  var isMainResourceDefined = !!mainResourceName;\n  var currentPaletteIndex = 0;\n  return resources.map(function (resource, groupIndex) {\n    var fieldName = resource.fieldName;\n    var isMain = isMainResourceDefined && mainResourceName === fieldName || groupIndex === 0 && !isMainResourceDefined;\n    var title = resource.title || fieldName;\n    var allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName: fieldName,\n      isMain: isMain,\n      title: title,\n      allowMultiple: allowMultiple,\n      instances: resource.instances.map(function (resourceItem) {\n        var color = resourceItem.color || palette[currentPaletteIndex % palette.length];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n        return {\n          id: resourceItem.id,\n          color: color,\n          fieldName: fieldName,\n          text: resourceItem.text || title || fieldName,\n          title: title,\n          allowMultiple: allowMultiple,\n          isMain: isMain\n        };\n      })\n    };\n  });\n};\n\nvar addResourcesToAppointments = function addResourcesToAppointments(appointments, resources, plainResources) {\n  return [appointments.map(function (appointment) {\n    return _assign(_assign({}, appointment), {\n      resources: getAppointmentResources(appointment.dataItem, resources, plainResources)\n    });\n  })];\n};\n\nvar toggleExpandedGroups = function toggleExpandedGroups(state, _a) {\n  var groupKey = _a.groupKey;\n  var expandedGroups = slice(state.expandedGroups);\n  var groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups: expandedGroups\n  };\n};\n\nvar getDayScaleCellColSpan = function getDayScaleCellColSpan(cellsData) {\n  var firstDate = cellsData[0][0].startDate;\n  var count = 1;\n\n  while (cellsData[0][count] && moment(cellsData[0][count].startDate).isSame(firstDate, 'day')) {\n    count += 1;\n  }\n\n  return count;\n};\n\nvar getDayScaleCells = function getDayScaleCells(cellsData, groupedByDate) {\n  if (!groupedByDate) {\n    return cellsData[0].map(function (_a, index) {\n      var startDate = _a.startDate,\n          endDate = _a.endDate,\n          today = _a.today,\n          endOfGroup = _a.endOfGroup,\n          groupingInfo = _a.groupingInfo;\n      return {\n        key: index.toString(),\n        startDate: startDate,\n        endDate: endDate,\n        today: today,\n        endOfGroup: endOfGroup,\n        groupingInfo: groupingInfo\n      };\n    });\n  }\n\n  var prevDate;\n  var colSpan = getDayScaleCellColSpan(cellsData);\n  return cellsData[0].reduce(function (acc, _a, index) {\n    var startDate = _a.startDate,\n        endDate = _a.endDate,\n        today = _a.today;\n    var currentDate = moment(startDate);\n\n    if (currentDate.isSame(prevDate)) {\n      return acc;\n    }\n\n    prevDate = currentDate;\n    return __spread(acc, [{\n      key: index.toString(),\n      startDate: startDate,\n      endDate: endDate,\n      today: today,\n      colSpan: colSpan,\n      endOfGroup: true\n    }]);\n  }, []);\n};\n\nvar navigateByOneMonth = function navigateByOneMonth(currentDate, isBackward) {\n  return moment(currentDate)[isBackward ? 'subtract' : 'add'](1, 'month').toDate();\n};\n/** @internal */\n\n\nvar RecurrenceFrequency;\n\n(function (RecurrenceFrequency) {\n  RecurrenceFrequency[RecurrenceFrequency[\"Daily\"] = RRULE_REPEAT_TYPES.DAILY] = \"Daily\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Weekly\"] = RRULE_REPEAT_TYPES.WEEKLY] = \"Weekly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Monthly\"] = RRULE_REPEAT_TYPES.MONTHLY] = \"Monthly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Yearly\"] = RRULE_REPEAT_TYPES.YEARLY] = \"Yearly\";\n})(RecurrenceFrequency || (RecurrenceFrequency = {}));\n\nexport { APRIL_DATE, AUGUST_DATE, AUTO_HEIGHT, BASIC_DAILY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_YEALY_COUNT, CANCEL_BUTTON, CANCEL_COMMAND_BUTTON, CLOSE_COMMAND_BUTTON, COMMIT_COMMAND_BUTTON, DAYS_IN_WEEK, DAYS_OF_WEEK, DAYS_OF_WEEK_ARRAY, DAYS_OF_WEEK_DATES, DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_LONG_MONTH_OPTIONS, DAY_OPTIONS, DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS, DECEMBER_DATE, DEFAULT_RULE_OBJECT, DELETE_BUTTON, DELETE_COMMAND_BUTTON, EMPTY_OPTIONS, END_REPEAT_RADIO_GROUP, FEBRUARY_DATE, FIRST_WEEK, FOURTH_WEEK, FRIDAY_DATE, HORIZONTAL_GROUP_ORIENTATION, HORIZONTAL_TYPE, HORIZONTAL_VIEW_LEFT_OFFSET, HOURS, HOUR_MINUTE_OPTIONS, JANUARY_DATE, JULY_DATE, JUNE_DATE, LAST_WEEK, LONG_MONTH_OPTIONS, LONG_WEEK_DAY_OPTIONS, MARCH_DATE, MAY_DATE, MINUTES, MONDAY_DATE, MONTHLY_RADIO_GROUP, MONTHS, MONTHS_DATES, MONTH_YEAR_OPTIONS, MULTILINE_TEXT_EDITOR, NOVEMBER_DATE, NUMBER_EDITOR, OCTOBER_DATE, OPEN_COMMAND_BUTTON, ORDINARY_LABEL, ORDINARY_TEXT_EDITOR, OUTLINED_SELECT, POSITION_END, POSITION_START, RECURRENCE_EDIT_SCOPE, REPEAT_TYPES, REPEAT_TYPES_ARRAY, RESIZE_BOTTOM, RESIZE_TOP, RRULE_DAYS_OF_WEEK, RRULE_REPEAT_TYPES, RecurrenceFrequency, SATURDAY_DATE, SAVE_BUTTON, SCROLL_OFFSET, SCROLL_SPEED_PX, SECONDS, SECOND_WEEK, SEPTEMBER_DATE, SHORT_MONTH_LONG_YEAR_OPTIONS, SHORT_MONTH_OPTIONS, SHORT_MONTH_SHORT_YEAR_OPTIONS, STANDARD_SELECT, SUNDAY_DATE, THIRD_WEEK, THURSDAY_DATE, TITLE, TITLE_TEXT_EDITOR, TOGGLE_APPOINTMENT_FORM_VISIBILITY, TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY, TUESDAY_DATE, VERTICAL_GROUP_ORIENTATION, VERTICAL_TYPE, VERTICAL_VIEW_LEFT_OFFSET, VIEW_TYPES, WEDNESDAY_DATE, WEEKDAY_INTERVAL, WEEK_DAY_OPTIONS, WEEK_NUMBER_LABELS, YEARLY_RADIO_GROUP, addAppointment, addDateToKey, addGroupInfoToCell, addGroupInfoToCells, addResourcesToAppointments, adjustByBlocks, allDayCells, allDayPredicate, allDayRects, appointmentDragged, appointments, areDatesSame, autoScroll, availableViews, calculateAllDayDateIntervals, calculateAppointmentGroups, calculateAppointmentLeftAndWidth, calculateAppointmentOffsets, calculateAppointmentTimeBoundaries, calculateAppointmentsMetaData, calculateBlocksLeftLimit, calculateBlocksTotalSize, calculateDraftAppointments, calculateFirstDateOfWeek, calculateIncludedBlockMaxRight, calculateInsidePart, calculateMonthDateIntervals, calculateRectByDateAndGroupIntervals, calculateWeekDateIntervals, callActionIfExists, cancelAddedAppointment, cancelChanges, cellData, cellIndex, cellType, changeAppointment, changeCurrentDate, changeRecurrenceFrequency, changeRecurrenceOptions, changedAppointmentById, checkCellGroupingInfo, checkIsNaturalNumber, checkMultipleResourceFields, computed, containsDSTChange, convertResourcesToPlain, convertToMoment, createAppointmentForest, dayBoundaryPredicate, dayScale, deleteAll, deleteCurrent, deleteCurrentAndFollowing, editAll, editCurrent, editCurrentAndFollowing, endViewDate, excludedIntervals, expandGroupedAppointment, expandGroups, expandViewCellsDataWithGroups, filterByViewBoundaries, filterResourcesByGrouping, findBlockIndexByAppointment, findChildBlocks, findChildrenMaxEndDate, findIncludedBlocks, findMaxReduceValue, findOverlappedAppointments, formatDateTimeGetter, formatDateToString, getAllDayCellIndexByAppointmentData, getAllDayHorizontallyGroupedColumnIndex, getAllDayVerticallyGroupedColumnIndex, getAllDayVerticallyGroupedRowIndex, getAppointmentResources, getAppointmentStyle, getAvailableRecurrenceOptions, getCellKey, getCountDependingOnRecurrenceType, getCurrentTimeIndicatorTop, getDayScaleCellColSpan, getDayScaleCells, getDaysOfWeek, getDaysOfWeekArray, getDaysOfWeekDates, getFrequencyString, getGroupFromResourceInstance, getGroupingInfoFromGroups, getGroupsFromResources, getGroupsLastRow, getHorizontalRectByAppointmentData, getLabelsForAllGroups, getMonthCellIndexByAppointmentData, getMonthHorizontallyGroupedColumnIndex, getMonthVerticallyGroupedRowIndex, getMonths, getMonthsWithOf, getRRuleFrequency, getRRuleSetWithExDates, getRadioGroupDisplayData, getRecurrenceOptions, getRowFromGroups, getTimeTableHeight, getUTCDate, getVerticalCellIndexByAppointmentData, getVerticalRectByAppointmentData, getVerticalRowFromGroups, getViewType, getWeekHorizontallyGroupedColumnIndex, getWeekHorizontallyGroupedRowIndex, getWeekNumberLabels, getWeekVerticallyGroupedColumnIndex, getWeekVerticallyGroupedRowIndex, groupAppointments, groupAppointmentsIntoBlocks, handleChangeFrequency, handleStartDateChange, handleToDayOfWeekChange, handleWeekDaysChange, horizontalTimeTableRects, intervalDuration, intervalIncludes, isAllDayCell, isAllDayElementsMetaActual, isCellShaded, isDateValid, isMidnight, isMonthCell, isOverlappingSubTreeRoot, isPossibleChild, isShadedAppointment, isTimeTableElementsMetaActual, monthCellsData, navigateByOneMonth, normalizeAppointmentDuration, preCommitChanges, prepareToGroupIntoBlocks, prepareVerticalViewCellsData, rearrangeResources, reduceAppointmentByDayBounds, setAppointmentData, setAppointmentMeta, setCurrentViewName, sliceAppointmentByDay, sliceAppointmentByWeek, sliceAppointmentsByBoundaries, sliceAppointmentsByDays, sortAppointments, sortFilteredResources, startEditAppointment, startViewDate, stopEditAppointment, timeBoundariesByDrag, timeBoundariesByResize, timeCellsData, timeScale, toPercentage, toggleExpandedGroups, unwrapGroups, updateAllDayCellElementsMeta, updateBlocksLeft, updateBlocksProportions, updateGroupingWithMainResource, updateTimeCellsData, updateTimeTableCellElementsMeta, validateResources, verticalTimeTableRects, viewBoundText, viewCellsData, viewPredicate };","map":{"version":3,"sources":["../src/utils.ts","../src/constants.ts","../src/plugins/common/helpers.ts","../src/plugins/common/computeds.ts","../src/plugins/appointments/helpers.ts","../src/plugins/week-view/helpers.ts","../src/plugins/week-view/computeds.ts","../src/plugins/vertical-rect/helpers.ts","../src/plugins/all-day-panel/helpers.ts","../src/plugins/appointment-form/constants.ts","../src/plugins/month-view/helpers.ts","../src/plugins/horizontal-rect/helpers.ts","../src/plugins/month-view/computeds.ts","../src/plugins/all-day-panel/computeds.ts","../src/plugins/integrated-grouping/helpers.ts","../src/plugins/integrated-grouping/computeds.ts","../src/plugins/common/calculate-rects.ts","../src/plugins/scheduler-core/helpers.ts","../src/plugins/scheduler-core/computeds.ts","../src/plugins/grouping-panel/utils.ts","../src/plugins/week-view/utils.ts","../src/plugins/view-state/reducers.ts","../src/plugins/appointment-tooltip/reducers.ts","../src/plugins/appointment-tooltip/constants.ts","../src/plugins/appointment-form/reducers.ts","../src/plugins/appointment-form/utils.ts","../src/plugins/appointment-form/helpers.ts","../src/plugins/editing-state/reducers.ts","../src/plugins/editing-state/computeds.ts","../src/plugins/editing-state/helpers.ts","../src/plugins/drag-drop-provider/helpers.ts","../src/plugins/current-time-indicator/helpers.tsx","../src/plugins/resources/helpers.ts","../src/plugins/resources/computeds.ts","../src/plugins/grouping-state/reducers.ts","../src/plugins/common/utils.ts","../src/plugins/date-navigator/helpers.ts","../src/types/appointment-form.types.ts"],"names":["isMidnight","getCellRect"],"mappings":"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","sourcesContent":["import moment from 'moment';\nimport { CustomFunction, PureComputed } from '@devexpress/dx-core';\nimport { RRule, RRuleSet } from 'rrule';\nimport {\n  ComputedHelperFn, ViewPredicateFn,\n  CalculateFirstDateOfWeekFn, AppointmentMoment,\n  Interval, Rect, AppointmentKey,\n} from './types';\n\nexport const computed: ComputedHelperFn = (getters, viewName, baseComputed, defaultValue) => {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n  return baseComputed(getters, viewName);\n};\n\nexport const toPercentage: PureComputed<\n  [number, number]\n> = (value, total) => (value * 100) / total;\n\nconst createExcludedInterval: CustomFunction<\n  [number, moment.Moment], Interval\n> = (day, start) => {\n  const leftBound = moment(start.day(day));\n  return [\n    leftBound,\n    moment(leftBound).hour(start.hour()).endOf('day'),\n  ];\n};\n\nexport const excludedIntervals: PureComputed<\n  [number[], moment.Moment], Interval[]\n> = (excludedDays, start) => excludedDays\n  .map(day => (day === 0 ? 7 : day))\n  .sort((a, b) => a - b)\n  .reduce((acc, day, i, allDays) => {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[acc.length - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n    return acc;\n  }, [] as Interval[]);\n\nconst inInterval = (\n  date: moment.Moment, interval: Interval,\n) => date.isBetween(interval[0], interval[1], undefined, '[]');\n\nexport const viewPredicate: ViewPredicateFn = (\n  appointment, left, right,\n  excludedDays = [],\n  removeAllDayAppointments = false,\n) => {\n  const { start, end } = appointment;\n  const isAppointmentInBoundary = end.isAfter(left as Date)\n    && start.isBefore(right as Date);\n\n  const isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left as Date))\n    .find(interval => (inInterval(start, interval) && inInterval(end, interval)));\n  const considerAllDayAppointment = removeAllDayAppointments\n    ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay\n    : true;\n\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nexport const calculateFirstDateOfWeek: CalculateFirstDateOfWeekFn = (\n  currentDate, firstDayOfWeek, excludedDays = [],\n) => {\n  const currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: { dow: firstDayOfWeek, doy: 1 }, // `doy` is required for TS using\n  });\n  const firstDateOfWeek = moment(currentDate as Date).startOf('week');\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach((day) => {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n  moment.locale(currentLocale);\n\n  return firstDateOfWeek.toDate();\n};\n\nexport const getAppointmentStyle: PureComputed<\n  [Rect], React.CSSProperties\n> = ({\n  top, left,\n  width, height,\n}) => ({\n  height,\n  width: `${width}%`,\n  transform: `translateY(${top}px)`,\n  msTransform: `translateY(${top}px)`,\n  left: `${left}%`,\n  position: 'absolute',\n});\n\nconst expandRecurrenceAppointment = (\n  appointment: AppointmentMoment, leftBound: Date, rightBound: Date,\n) => {\n  const rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  const leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  const appointmentStartDate = moment(appointment.start).toDate();\n  const options = {\n    ...RRule.parseString(appointment.rRule),\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate(),\n  };\n  const correctedOptions = options.until\n    ? { ...options, until: moment(getUTCDate(options.until)).toDate() }\n    : options;\n\n  const rruleSet = getRRuleSetWithExDates(appointment.exDate);\n\n  rruleSet.rrule(new RRule(correctedOptions));\n\n  // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n  const datesInBoundaries = rruleSet.between(leftBoundUTC as Date, rightBoundUTC as Date, true)\n    .map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n\n  const appointmentDuration = moment(appointment.end)\n    .diff(appointment.start, 'minutes');\n\n  return datesInBoundaries.map((startDate, index) => ({\n    ...appointment,\n    dataItem: {\n      ...appointment.dataItem,\n      startDate: moment(startDate).toDate(),\n      endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n      parentData: appointment.dataItem,\n    },\n    start: moment(startDate),\n    end: moment(startDate).add(appointmentDuration, 'minutes'),\n    key: `${appointment.key}_rec_${index}`,\n  }));\n};\n\nexport const filterByViewBoundaries: PureComputed<\n  [AppointmentMoment, Date, Date, number[], boolean], AppointmentMoment[]\n> = (appointment, leftBound, rightBound, excludedDays, removeAllDay) => {\n  let appointments = [appointment];\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(\n      appointment as AppointmentMoment, leftBound as Date, rightBound as Date,\n    );\n  }\n  return appointments.filter(appt => viewPredicate(\n    appt, leftBound, rightBound, excludedDays, removeAllDay,\n  ));\n};\n\nexport const getUTCDate: PureComputed<[Date], number> = date =>\n  Date.UTC(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n);\n\nexport const getRRuleSetWithExDates: PureComputed<\n  [string | undefined], RRuleSet\n> = (exDate) => {\n  const rruleSet = new RRuleSet();\n  if (exDate) {\n    exDate.split(',').map((date: string) => {\n      const currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n  return rruleSet;\n};\n\nexport const formatDateToString = (date: Date | string | number) => moment.utc(date).format('YYYY-MM-DDTHH:mm');\n\nexport const addDateToKey: PureComputed<\n  [AppointmentKey, moment.Moment], AppointmentKey\n> = (prevKey, momentDate) => `${prevKey}_${momentDate.toDate().toString()}`;\n","import { GroupOrientation } from './types';\n\nexport const VERTICAL_TYPE = 'vertical';\nexport const HORIZONTAL_TYPE = 'horizontal';\n\nexport const SCROLL_OFFSET = 50;\nexport const SCROLL_SPEED_PX = 15;\n\nexport const SECONDS = 'seconds';\nexport const MINUTES = 'minutes';\nexport const HOURS = 'hours';\n\nexport const RESIZE_TOP = 'resize-start';\nexport const RESIZE_BOTTOM = 'resize-end';\n\nexport const POSITION_START = 'start';\nexport const POSITION_END = 'end';\n\nexport const AUTO_HEIGHT = 'auto';\n\nexport const DAY_OPTIONS = { day: 'numeric' };\nexport const WEEK_DAY_OPTIONS = { weekday: 'short' };\nexport const SHORT_MONTH_OPTIONS = { month: 'short' };\nexport const HOUR_MINUTE_OPTIONS = { hour: 'numeric', minute: 'numeric' };\nexport const MONTH_YEAR_OPTIONS = { month: 'long', year: 'numeric' };\nexport const DAY_SHORT_MONTH_OPTIONS = { day: 'numeric', month: 'short' };\nexport const SHORT_MONTH_LONG_YEAR_OPTIONS = { month: 'short', year: 'numeric' };\nexport const SHORT_MONTH_SHORT_YEAR_OPTIONS = { month: 'short', year: '2-digit' };\nexport const DAY_LONG_MONTH_LONG_YEAR_OPTIONS = { day: 'numeric', month: 'long', year: 'numeric' };\nexport const DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric', month: 'short', year: 'numeric',\n};\nexport const DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric', month: 'short', year: '2-digit',\n};\nexport const LONG_WEEK_DAY_OPTIONS = { weekday: 'long' };\nexport const LONG_MONTH_OPTIONS = { month: 'long' };\nexport const DAY_LONG_MONTH_OPTIONS = { day: 'numeric', month: 'long' };\nexport const EMPTY_OPTIONS = {};\n\nexport const RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current',\n};\n\nexport const TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nexport const TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\n\nexport const WEEKDAY_INTERVAL = 'weekdayInterval';\n\nexport const VERTICAL_VIEW_LEFT_OFFSET = 80;\nexport const HORIZONTAL_VIEW_LEFT_OFFSET = 0;\n\nexport const VERTICAL_GROUP_ORIENTATION = 'Vertical' as GroupOrientation;\nexport const HORIZONTAL_GROUP_ORIENTATION = 'Horizontal' as GroupOrientation;\n\nexport const VIEW_TYPES = {\n  MONTH: 'month',\n  WEEK: 'week',\n  DAY: 'day',\n  ALL_DAY_PANEL: 'allDayPanel',\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE, DAY_OPTIONS, SHORT_MONTH_OPTIONS,\n  DAY_SHORT_MONTH_OPTIONS, SHORT_MONTH_LONG_YEAR_OPTIONS,\n  SHORT_MONTH_SHORT_YEAR_OPTIONS, MONTH_YEAR_OPTIONS,\n  DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS,\n  DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, LONG_WEEK_DAY_OPTIONS, EMPTY_OPTIONS,\n  WEEKDAY_INTERVAL,\n} from '../../constants';\nimport {\n  ViewBoundTextFn, FormatterFn, ViewCell,\n  AppointmentMoment, Group, SchedulerDateTime, CellElementsMeta,\n} from '../../types';\n\nconst MONTH_TYPE = 'month';\n\nexport const getViewType: PureComputed<[string], string> = (currentViewType) => {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nexport const isMidnight: PureComputed<\n  [Date], boolean\n> = (date) => {\n  const momentDate = moment(date as Date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nconst calculateTextByDays: PureComputed<\n  [Date, Date, FormatterFn, object], string\n> = (startViewDate, endViewDate, formatDate, additionalOptions) => {\n  const momentStartViewDate = moment(startViewDate as Date);\n  const momentEndViewDate = moment(endViewDate as Date);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), {\n      ...DAY_LONG_MONTH_LONG_YEAR_OPTIONS, ...additionalOptions,\n    });\n  }\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return `${\n        formatDate(momentStartViewDate.toDate(), DAY_OPTIONS)\n      }-${\n        formatDate(momentEndViewDate.toDate(), DAY_OPTIONS)\n      } ${\n        formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS)\n      }`;\n    }\n    return `${\n      formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS)\n    } - ${\n      formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS)\n    }`;\n  }\n  return `${\n    formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  } - ${\n    formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  }`;\n};\n\nconst calculateTextByMonths: PureComputed<\n  [Date, number, FormatterFn], string\n> = (currentDate, intervalCount, formatDate) => {\n  const momentCurrentDate = moment(currentDate as Date);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n  const lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return `${\n      formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS)\n    }-${\n      formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS)\n    }`;\n  }\n  return `${\n    formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  } - ${\n    formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  }`;\n};\n\nexport const viewBoundText: ViewBoundTextFn = (\n  startViewDate, endViewDate, type, currentDate, intervalCount, formatDate,\n) => (type !== 'month'\n  ? calculateTextByDays(\n    startViewDate, endViewDate, formatDate,\n    type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS,\n  )\n  : calculateTextByMonths(currentDate, intervalCount, formatDate)\n);\n\nexport const checkCellGroupingInfo: PureComputed<\n  [ViewCell, AppointmentMoment], boolean\n> = (cell, appointment) => cell.groupingInfo\n  ? cell.groupingInfo.every((group: Group) => (\n    group.id === appointment[group.fieldName]\n  ))\n  : true;\n\nexport const isDateValid: PureComputed<\n  [Date], boolean\n> = date => moment(date as Date).isValid();\n\nexport const convertToMoment: PureComputed<\n  [SchedulerDateTime], moment.Moment\n> = date => moment(date as SchedulerDateTime);\n\nexport const areDatesSame: PureComputed<\n  [SchedulerDateTime, SchedulerDateTime], boolean\n> = (firstDate, secondDate) => moment(firstDate as SchedulerDateTime)\n  .isSame(secondDate as SchedulerDateTime, 'date');\n\nexport const getTimeTableHeight: PureComputed<\n  [CellElementsMeta], number | undefined\n> = timeTableElementsMeta => timeTableElementsMeta.parentRect?.().height;\n\nexport const containsDSTChange = (date: SchedulerDateTime) => {\n  const momentDate = moment(date);\n  momentDate.startOf('day');\n  const isStartDST = momentDate.isDST();\n\n  momentDate.endOf('day');\n  const isEndDst = momentDate.isDST();\n\n  return (isStartDST && !isEndDst) || (!isStartDST && isEndDst);\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TimeScale, SchedulerDateTime, ViewCell,\n  DayScaleFn, TimeScaleFn, ViewCellsDataFn, AllDayCell,\n  SchedulerView,\n} from '../../types';\nimport { calculateFirstDateOfWeek } from '../../utils';\nimport {\n  isMidnight,\n  containsDSTChange,\n} from './helpers';\n\nconst subtractSecond: PureComputed<\n  [Date]\n> = date => moment(date as Date).subtract(1, 'second').toDate();\n\nexport const dayScale: DayScaleFn = (\n  currentDate,\n  firstDayOfWeek,\n  dayCount,\n  excluded = [],\n) => {\n  const result: Date[] = [];\n  const date = firstDayOfWeek !== undefined\n    ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded) as Date)\n    : moment(currentDate as Date);\n  for (let index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(item => item === date.day()) === -1) {\n      result.push(date.toDate());\n    }\n    date.add(1, 'days');\n  }\n  return result;\n};\n\nexport const timeScale: TimeScaleFn = (\n  currentDate,\n  firstDayOfWeek,\n  startDayHour,\n  endDayHour,\n  cellDuration,\n  excludedDays,\n) => {\n  const result: TimeScale[] = [];\n  const startDateOfView = firstDayOfWeek !== undefined\n    ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays)\n    : currentDate;\n\n  const isDSTChange = containsDSTChange(startDateOfView as Date);\n  const validDate = moment(startDateOfView as Date);\n  if (isDSTChange) {\n    validDate.subtract(1, 'day');\n  }\n\n  const left = moment(validDate)\n    .startOf('day')\n    .add(startDayHour, 'hour');\n  const right = moment(validDate)\n    .startOf('day')\n    .add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    const startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({ start: startDate, end: left.toDate() });\n  }\n\n  const timeScaleLastIndex = result.length - 1;\n  if (isMidnight(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end) as Date;\n  }\n  return result;\n};\n\nexport const availableViews: PureComputed<\n  [SchedulerView[], string, string], SchedulerView[]\n> = (views, viewName, viewDisplayName) => {\n  if (!views) return [{ name: viewName, displayName: viewDisplayName }];\n  if (views.findIndex(view => viewName === view.name) === -1) {\n    const nextViews = views.slice();\n    nextViews.push({ name: viewName, displayName: viewDisplayName });\n    return nextViews;\n  }\n  return views;\n};\n\nexport const viewCellsData: ViewCellsDataFn = (\n  currentDate, firstDayOfWeek,\n  dayCount, excludedDays,\n  startDayHour, endDayHour,\n  cellDuration, currTime,\n) => {\n  const days = dayScale(currentDate, firstDayOfWeek!, dayCount!, excludedDays);\n  const times = timeScale(\n    currentDate, firstDayOfWeek!, startDayHour, endDayHour, cellDuration, excludedDays,\n  );\n  const currentTime = moment(currTime as SchedulerDateTime);\n  return times.reduce((cellsAcc, time) => {\n    const start = moment(time.start);\n    const end = moment(time.end);\n    const rowCells = days.reduce((rowAcc, day) => {\n      const startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      const endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      const today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({ startDate, endDate, today });\n      return rowAcc;\n    }, [] as ViewCell[]);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, [] as ViewCell[][]);\n};\n\nexport const timeCellsData: PureComputed<\n  [ViewCell[][], number, number, number, number], ViewCell[][]\n> = (\n  cellsData, startDayHour, endDayHour, cellDuration, currentTime,\n) => {\n  const { startDate: firstViewDate } = cellsData[0][0];\n  if (!containsDSTChange(firstViewDate)) {\n    return cellsData;\n  }\n\n  const nextDay = moment(firstViewDate)\n    .add(1, 'day')\n    .toDate();\n  const validCellsData = viewCellsData(\n    nextDay, undefined, 1, [], startDayHour, endDayHour, cellDuration, currentTime,\n  );\n\n  return validCellsData;\n};\n\nexport const allDayCells: PureComputed<\n  [ViewCell[][]], AllDayCell[][]\n> = viewCells => [viewCells[0].map(cell => ({\n  startDate: moment(cell.startDate).startOf('day').toDate(),\n  endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),\n  groupingInfo: cell.groupingInfo,\n  endOfGroup: cell.endOfGroup,\n}))];\n\nexport const startViewDate: PureComputed<\n  [ViewCell[][]], Date\n> = viewCells => moment(viewCells[0][0].startDate).toDate();\n\nexport const endViewDate: PureComputed<\n  [ViewCell[][]], Date\n> = (viewCells) => {\n  const lastRowIndex = viewCells.length - 1;\n  const lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate!);\n};\n","import { PureComputed, CustomFunction } from '@devexpress/dx-core';\nimport {\n  ViewCell, CellElementsMeta, GroupOrientation, AppointmentMoment,\n  AppointmentUnwrappedGroup, ViewMetaData, ElementRect, AppointmentGroup,\n  AppointmentForestRoots, CalculatedTreeNode, TreeNodeWithOverlappingSubTreeRoots,\n  TreeNodeInBlock, AppointmentBlock, IncludedBlock, BlockWithChildren, CalculatedBlock,\n  GroupedIntoBlocksForest, AppointmentIndex,\n\n  VisitRootsFn, CalculateRectByDateAndGroupIntervalsFn, CreateAppointmentForestFn,\n  VisitChildFn, VisitAllChildrenFn, IsPossibleChildFn, FindMaxReduceValueFn,\n  CalculateAppointmentsMetaDataFn, CalulateRootsMetaDataFn, CalculateChildMetaDataFn,\n  CalculateChildrenMetaDataFn, CalculateAppointmentLeftAndWidthFn, PrepareToGroupIntoBlocksFn,\n  IsOverlappingSubTreeRootFn, FindChildrenMaxEndDateFn, GroupAppointmentsIntoBlocksFn,\n  CalculateBlockSizeBEndDateFn, FindBlockIndexByAppointmentFn, FindIncludedBlocksFn,\n  IsIncludedBlockFn, FindChildBlocksFn, IsChildBlockFn, AdjustByBlocksFn,\n  CalculateBlockDimensionsFn, AlignBlocksWithPreviousFn, AdjustAppointemntsByBlocksFn,\n  RedistributeBlocksFn, CalculateIncludedBlockMaxRightFn, CalculateBlocksTotalSizeFn,\n  CalculateSingleBlockTotalSizeFn, CalculateBlocksLeftLimitFn, CalculateSingleBlockLeftLimitFn,\n  UpdateBlocksProportionsFn, UpdateBlocksLeftFn, CreateAndAdjustAppointmentForestFn,\n} from '../../types';\nimport { HORIZONTAL_GROUP_ORIENTATION, HORIZONTAL_TYPE, VERTICAL_TYPE } from '../../constants';\nimport { toPercentage } from '../../utils';\nimport moment from 'moment';\n\nconst MAX_WIDTH = 1;\nconst INDIRECT_CHILD_LEFT_OFFSET = 0.05;\n\nexport const isAllDayElementsMetaActual: PureComputed<\n  [ViewCell[][], CellElementsMeta, GroupOrientation, number], boolean\n> = (viewCellsData, allDayElementsMeta, groupOrientation, groupCount) => {\n  const numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;\n  return isElementsMetaActual(viewCellsData, allDayElementsMeta, numberOfRows);\n};\n\nexport const isTimeTableElementsMetaActual: PureComputed<\n  [ViewCell[][], CellElementsMeta], boolean\n> = (viewCellsData, timeTableElementsMeta) => isElementsMetaActual(\n  viewCellsData, timeTableElementsMeta, viewCellsData.length,\n);\n\nconst isElementsMetaActual: PureComputed<\n  [ViewCell[][], CellElementsMeta, number], boolean\n> = (viewCellsData, elementsMeta, numberOfRows) => {\n  if (!elementsMeta?.getCellRects) {\n    return false;\n  }\n\n  const tableSize = numberOfRows * viewCellsData[0].length;\n  return tableSize === elementsMeta.getCellRects.length;\n};\n\nconst appointmentHeightType = (appointment: AppointmentMoment, cellDuration: number) => {\n  const durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nconst horizontalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, ViewMetaData, any], ElementRect\n> = (\n  appointment,\n  viewMetaData,\n  {\n    rectByDates: getRectByAppointment,\n    multiline,\n    rectByDatesMeta: {\n      cellElementsMeta,\n      viewCellsData,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = getRectByAppointment(\n    appointment,\n    viewMetaData,\n    {\n      multiline,\n      cellElementsMeta,\n      viewCellsData,\n    },\n  );\n\n  return {\n    resources: appointment.resources,\n    top: top + ((height / appointment.reduceValue) * appointment.offset),\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE,\n    key: appointment.key,\n  };\n};\n\nconst verticalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, ViewMetaData, any], ElementRect\n> = (\n  appointment,\n  viewMetaData,\n  {\n    rectByDates: getRectByAppointment,\n    multiline,\n    rectByDatesMeta: {\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n      excludedDays,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = getRectByAppointment(\n    appointment,\n    viewMetaData,\n    {\n      multiline,\n      viewCellsData,\n      cellDuration,\n      excludedDays,\n      cellElementsMeta,\n    },\n  );\n\n  const { offset, width: relativeWidth, left: relativeLeft  } = appointment;\n  const widthMultiplier = (relativeWidth! * 5 / 3 + relativeLeft!) <= 1 ? 5 / 3 : 1;\n  let validWidth = widthMultiplier === 5 / 3\n    ? widthMultiplier * relativeWidth! : relativeWidth! + 0.02;\n  if (validWidth + relativeLeft! > 1) {\n    validWidth = 1 - relativeLeft!;\n  }\n\n  return {\n    resources: appointment.resources,\n    top,\n    height,\n    left: toPercentage(left + relativeLeft! * width, parentWidth),\n    width: toPercentage(validWidth! * width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    offset,\n    key: appointment.key,\n  };\n};\n\nconst oldVerticalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, ViewMetaData, any], ElementRect\n> = (\n  appointment,\n  viewMetaData,\n  {\n    rectByDates: getRectByAppointment,\n    multiline,\n    rectByDatesMeta: {\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n      excludedDays,\n      placeAppointmentsNextToEachOther,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = getRectByAppointment(\n    appointment,\n    viewMetaData,\n    {\n      multiline,\n      viewCellsData,\n      cellDuration,\n      excludedDays,\n      cellElementsMeta,\n      placeAppointmentsNextToEachOther,\n    },\n  );\n\n  const widthInPx = width / appointment.reduceValue;\n\n  return {\n    resources: appointment.resources,\n    top,\n    height,\n    left: toPercentage(left + (widthInPx * appointment.offset), parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n    key: appointment.key,\n  };\n};\n\nconst compareByDay: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nconst compareByAllDay: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nconst compareByTime: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nexport const sortAppointments: PureComputed<\n  [AppointmentMoment[]], AppointmentMoment[]\n> = appointments => appointments\n  .slice().sort((a, b) => compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b));\n\nconst byDayPredicate: PureComputed<\n  [moment.Moment, moment.Moment], boolean\n> = (boundary, date) => (\n  boundary.isSameOrAfter(date, 'day')\n  && !boundary.isSame(boundary.clone().startOf('day'))\n);\n\nexport const findOverlappedAppointments: CustomFunction<\n  [AppointmentMoment[], boolean], any[]\n> = (sortedAppointments, byDay = false) => {\n  const appointments = sortedAppointments.slice();\n  const groups: AppointmentMoment[][] = [];\n  let totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    const current = appointments[totalIndex];\n    const currentGroup = groups[groups.length - 1];\n    let next = appointments[totalIndex + 1];\n    let maxBoundary = current.end;\n\n    currentGroup.push(current);\n    totalIndex += 1;\n    while (next && (maxBoundary.isAfter(next.start)\n      || (byDay && byDayPredicate(maxBoundary, next.start)))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n  return groups;\n};\n\nconst isMidnight: PureComputed<\n  [moment.Moment], boolean\n> = date => date.isSame(date.clone().startOf('day'));\n\nconst maxBoundaryPredicate: PureComputed<\n  [moment.Moment, Date], boolean\n> = (maxBoundary, startDate) => ((maxBoundary.isBefore(startDate as Date, 'day'))\n  || (isMidnight(maxBoundary) && maxBoundary.isSame(startDate as Date, 'day')));\n\nexport const calculateAppointmentOffsets: CustomFunction<\n  [any[], boolean], AppointmentGroup[]\n> = (groups, byDay = false) => groups.map((items) => {\n  let offset = 0;\n  let reduceValue = 1;\n  const appointments = items.map((appointment: any) => ({ ...appointment }));\n  const groupLength = appointments.length;\n  for (let startIndex = 0; startIndex < groupLength; startIndex += 1) {\n    const appointment = appointments[startIndex];\n    if (appointment.offset === undefined) {\n      let maxBoundary = appointment.end;\n      appointment.offset = offset;\n      for (let index = startIndex + 1; index < groupLength; index += 1) {\n        if (appointments[index].offset === undefined) {\n          if ((!byDay && maxBoundary.isSameOrBefore(appointments[index].start))\n            || (byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start))) {\n            maxBoundary = appointments[index].end;\n            appointments[index].offset = offset;\n          }\n        }\n      }\n\n      offset += 1;\n      if (reduceValue < offset) reduceValue = offset;\n    }\n  }\n  return { items: appointments, reduceValue };\n});\n\nconst unwrapAppointmentForest: PureComputed<\n  [GroupedIntoBlocksForest[]], AppointmentUnwrappedGroup[]\n> = (appointmentForests) => {\n  const forestUnwrapped = appointmentForests.map(({ items, reduceValue }) => ({\n    reduceValue,\n    items: items.map(({ data }) => ({ ...data })),\n  }));\n  return unwrapGroups(forestUnwrapped);\n};\n\nexport const unwrapGroups: PureComputed<\n  [AppointmentGroup[]], AppointmentUnwrappedGroup[]\n> = groups => groups.reduce((acc, { items, reduceValue }) => {\n  acc.push(...items.map(({ start, end, dataItem, offset, resources, key, ...restProps }) => ({\n    start, end, dataItem, offset, reduceValue, resources,\n    fromPrev: moment(start).diff(dataItem.startDate, 'minutes') > 1,\n    toNext: moment(dataItem.endDate).diff(end, 'minutes') > 1,\n    key,\n    ...restProps,\n  })));\n  return acc;\n}, [] as AppointmentUnwrappedGroup[]);\n\nexport const intervalIncludes: PureComputed<\n  [moment.Moment, moment.Moment, moment.Moment], boolean\n> = (intervalStart, intervalEnd, date) => date\n  .isBetween(intervalStart, intervalEnd, undefined, '[)');\n\nexport const createAppointmentForest: CreateAppointmentForestFn = (\n  appointmentGroups, cellDuration,\n) => appointmentGroups.map((appointmentGroup) => {\n  const { items } = appointmentGroup;\n  let nextItems;\n  let roots;\n  if (items.length === 1) {\n    nextItems = [{\n      data: items[0], children: [], treeDepth: 0, isDirectChild: false, hasDirectChild: false,\n    }];\n    roots = [0];\n  } else {\n    const {\n      appointments, roots: appointmentTreeRoots,\n    } = visitRoots(items, cellDuration) as AppointmentForestRoots;\n    nextItems = appointments;\n    roots = appointmentTreeRoots;\n  }\n  return {\n    ...appointmentGroup,\n    items: nextItems,\n    roots,\n  };\n});\n\nconst visitRoots: VisitRootsFn = (appointmentItems, cellDuration) => {\n  const appointmentNodes: any[] = appointmentItems.map(props => ({\n    data: props,\n  }));\n\n  const roots = appointmentNodes.reduce((acc, appointment, appointmentIndex) => {\n    const { offset: appointmentOffset } = appointment.data;\n\n    if (appointmentOffset === 0) {\n      if (appointmentIndex + 1 === appointmentNodes.length) {\n        appointment.children = [];\n        appointment.hasDirectChild = false;\n        appointment.treeDepth = 0;\n      } else {\n        appointment.treeDepth = visitAllChildren(\n          appointmentNodes, appointmentIndex, cellDuration, 0,\n        );\n      }\n\n      appointment.parent = undefined;\n      appointment.isDirectChild = false;\n      return [...acc, appointmentIndex];\n    }\n    return acc;\n  }, []);\n  return { appointments: appointmentNodes, roots };\n};\n\nconst visitChild: VisitChildFn = (\n  appointmentNodes, index, parentAppointmentIndex, cellDuration, isDirectChild, treeDepth,\n) => {\n  const appointmentNode = appointmentNodes[index];\n  appointmentNode.isDirectChild = isDirectChild;\n  appointmentNode.parent = parentAppointmentIndex;\n  const nextTreeDepth = treeDepth + 1;\n  const { end } = appointmentNode.data;\n\n  if (index === appointmentNodes.length - 1\n    || end.isSameOrBefore(appointmentNodes[index + 1].data.start)) {\n    appointmentNode.children = [];\n    appointmentNode.treeDepth = 0;\n    appointmentNode.hasDirectChild = false;\n    return nextTreeDepth;\n  }\n\n  const calculatedTreeDepth = visitAllChildren(\n    appointmentNodes, index, cellDuration, treeDepth,\n  );\n\n  appointmentNode.treeDepth = calculatedTreeDepth;\n  return calculatedTreeDepth + 1;\n};\n\nconst visitAllChildren: VisitAllChildrenFn = (\n  appointmentNodes, appointmentIndex, cellDuration, treeDepth,\n) => {\n  const appointment = appointmentNodes[appointmentIndex];\n  const { end, offset: appointmentOffset, start } = appointment.data;\n  const directChildTimeLimit = moment(start).add(cellDuration, 'minutes');\n  let maxAppointmentTreeDepth = 0;\n  const children = [] as AppointmentIndex[];\n\n  let nextChildIndex = appointmentIndex + 1;\n  while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n    const nextAppointment = appointmentNodes[nextChildIndex];\n    const { offset: nextOffset, start: nextStart } = nextAppointment.data;\n\n    if (nextOffset === appointmentOffset + 1) {\n      const isDirectChild = intervalIncludes(start, directChildTimeLimit, nextStart);\n      const nextTreeDepth = visitChild(\n        appointmentNodes, nextChildIndex, appointmentIndex, cellDuration, isDirectChild, treeDepth,\n      );\n\n      if (maxAppointmentTreeDepth < nextTreeDepth) {\n        maxAppointmentTreeDepth = nextTreeDepth;\n      }\n      children.push(nextChildIndex);\n    }\n    nextChildIndex += 1;\n  }\n  appointment.hasDirectChild = children.length !== 0 && appointmentNodes[children[0]].isDirectChild;\n  appointment.children = children;\n\n  return maxAppointmentTreeDepth;\n};\n\nexport const isPossibleChild: IsPossibleChildFn = (\n  appointments, possibleChildIndex, parentEnd, parentOffset,\n) => {\n  const possibleChild = appointments[possibleChildIndex];\n  return (\n    possibleChildIndex < appointments.length\n    && possibleChild.data.offset !== parentOffset\n    && possibleChild.data.start.isBefore(parentEnd)\n  );\n};\n\nexport const findMaxReduceValue: FindMaxReduceValueFn =\n  appointmentGroups => appointmentGroups.reduce((maxReduceValue, group) => {\n    const currentReduceValue = group.reduceValue;\n    return maxReduceValue > currentReduceValue ? maxReduceValue : currentReduceValue;\n  }, 1);\n\nexport const calculateAppointmentsMetaData: CalculateAppointmentsMetaDataFn = (\n  appointmentGroups, indirectChildLeftOffset,\n) => appointmentGroups.map((appointmentForest) => {\n  const { items, roots } = appointmentForest;\n  const firstNode = items[0];\n  return {\n    ...appointmentForest,\n    items: items.length === 1\n      ? [{\n        ...firstNode,\n        data: {\n          ...firstNode.data,\n          left: 0,\n          width: 1,\n        },\n      }]\n      : calculateRootsMetaData(items, roots, indirectChildLeftOffset) as CalculatedTreeNode[],\n  };\n});\n\nconst calculateRootsMetaData: CalulateRootsMetaDataFn = (\n  appointmentNodes, roots, indirectChildLeftOffset,\n) => {\n  const appointments = appointmentNodes.map(props => ({ ...props })) as CalculatedTreeNode[];\n\n  roots.forEach((appointmentIndex) => {\n    const appointment = appointments[appointmentIndex];\n    const { left, width } = calculateAppointmentLeftAndWidth(\n      appointments, undefined, appointment, MAX_WIDTH, indirectChildLeftOffset, undefined,\n    );\n    appointment.data.left = left;\n    appointment.data.width = width;\n    calculateChildrenMetaData(appointments, appointment, MAX_WIDTH, indirectChildLeftOffset);\n  });\n  return appointments;\n};\n\nconst calculateChildMetaData: CalculateChildMetaDataFn = (\n  appointmentNodes, appointmentIndex, maxWidth, indirectChildLeftOffset,\n) => {\n  const appointment = appointmentNodes[appointmentIndex];\n  const { left, width } = calculateAppointmentLeftAndWidth(\n    appointmentNodes, undefined, appointment, maxWidth, indirectChildLeftOffset, undefined,\n  );\n  appointment.data.left = left;\n  appointment.data.width = width;\n\n  calculateChildrenMetaData(\n    appointmentNodes, appointment, maxWidth, indirectChildLeftOffset,\n  );\n};\n\nconst calculateChildrenMetaData: CalculateChildrenMetaDataFn = (\n  appointmentNodes, appointmentNode, maxWidth, indirectChildLeftOffset,\n) => {\n  appointmentNode.children.forEach((childIndex) => {\n    calculateChildMetaData(appointmentNodes, childIndex, maxWidth, indirectChildLeftOffset);\n  });\n};\n\nexport const calculateAppointmentLeftAndWidth: CalculateAppointmentLeftAndWidthFn = (\n  appointmentNodes, blocks, appointmentNode, maxRight, indirectChildLeftOffset, defaultLeft,\n) => {\n  const {\n    hasDirectChild, treeDepth, isDirectChild, parent: parentIndex, children, blockIndex,\n  } = appointmentNode as TreeNodeInBlock;\n  const firstChild = appointmentNodes[children[0]];\n  const firstChildBlockIndex = (firstChild as TreeNodeInBlock)?.blockIndex;\n\n  const hasDirectChildAndInSameBlock = hasDirectChild\n    && (firstChildBlockIndex === undefined || (blockIndex === firstChildBlockIndex\n      || blocks![firstChildBlockIndex].includedInto === blockIndex\n      || maxRight === 1));\n\n  if (parentIndex === undefined) {\n    return ({\n      width: hasDirectChildAndInSameBlock ? maxRight / (treeDepth + 1) : maxRight,\n      left: 0,\n    });\n  }\n\n  const parent = appointmentNodes[parentIndex];\n  const {\n    width: parentWidth,\n    left: parentLeft,\n  } = parent.data;\n  const calculatedLeft = isDirectChild\n    ? parentLeft + parentWidth : parentLeft + indirectChildLeftOffset;\n  const left = defaultLeft !== undefined ? Math.max(defaultLeft, calculatedLeft) : calculatedLeft;\n  const unoccupiedSpace = maxRight - left;\n\n  return ({\n    width: hasDirectChildAndInSameBlock ? unoccupiedSpace / (treeDepth + 1) : unoccupiedSpace,\n    left,\n  });\n};\n\nexport const prepareToGroupIntoBlocks: PrepareToGroupIntoBlocksFn =\n  appointments => appointments.map((appointmentForest) => {\n    const { items: nodes } = appointmentForest;\n    const appointmentNodes = nodes.map(props => ({\n      ...props,\n    })) as TreeNodeWithOverlappingSubTreeRoots[];\n\n    appointmentNodes.forEach((appointmentNode, index) => {\n      if (index === 0) {\n        appointmentNode.overlappingSubTreeRoots = [];\n        return;\n      }\n      const overlappingSubTreeRoots = [] as any[];\n      const { offset: appointmentOffset, end } = appointmentNode.data;\n\n      let nextChildIndex = index + 1;\n      let currentBlockEnd;\n      while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {\n        const nextAppointment = appointmentNodes[nextChildIndex];\n        if (nextAppointment.data.offset < appointmentOffset\n          && nextAppointment.maxOffset === undefined) {\n          nextAppointment.maxOffset = appointmentOffset;\n        }\n\n        const previousSubTreeRoot = overlappingSubTreeRoots.length > 0\n          ? appointmentNodes[overlappingSubTreeRoots[overlappingSubTreeRoots.length - 1]]\n          : undefined;\n        if (isOverlappingSubTreeRoot(\n          appointmentNode, nextAppointment, previousSubTreeRoot, currentBlockEnd,\n        )) {\n          overlappingSubTreeRoots.push(nextChildIndex);\n          nextAppointment.overlappingSubTreeRoot = true;\n          const maxChildDate = findChildrenMaxEndDate(appointmentNodes, nextAppointment);\n          if (!currentBlockEnd || currentBlockEnd.isBefore(maxChildDate)) {\n            currentBlockEnd = maxChildDate;\n          }\n        }\n        nextChildIndex += 1;\n      }\n      appointmentNode.overlappingSubTreeRoots = overlappingSubTreeRoots;\n    });\n    return {\n      ...appointmentForest,\n      items: appointmentNodes,\n    };\n  });\n\nexport const isOverlappingSubTreeRoot: IsOverlappingSubTreeRootFn = (\n  appointmentNode, nextAppointment, previousSubTreeRoot, previousEndDate,\n) => {\n  const {\n    overlappingSubTreeRoot, maxOffset, data: nextData,\n  } = nextAppointment;\n  const { offset: nextOffset, start: nextStart } = nextData;\n  const { offset } = appointmentNode.data;\n\n  return (\n    nextOffset < offset\n      && !overlappingSubTreeRoot\n      && (maxOffset === undefined || maxOffset >= offset)\n      && (!previousSubTreeRoot\n        || (previousSubTreeRoot.data.offset >= nextOffset\n        && nextStart.isSameOrAfter(previousEndDate)))\n  );\n};\n\nexport const findChildrenMaxEndDate: FindChildrenMaxEndDateFn = (\n  appointmentNodes, appointmentNode,\n) => {\n  const { children, data } = appointmentNode;\n  const { end } = data;\n\n  const maxDate = children.reduce((currentMaxDate, childIndex) => {\n    const child = appointmentNodes[childIndex];\n    const maxChildrenDate = findChildrenMaxEndDate(appointmentNodes, child);\n    if (maxChildrenDate.isAfter(currentMaxDate)) {\n      return maxChildrenDate;\n    }\n    return currentMaxDate;\n  }, end);\n  return maxDate;\n};\n\nexport const groupAppointmentsIntoBlocks: GroupAppointmentsIntoBlocksFn =\n  appointmentForests => appointmentForests.map((appointmentForest) => {\n    const { items, reduceValue } = appointmentForest;\n    const { blocks: nextBlocks, appointments } = items.reduce((acc, appointment, index) => {\n      const blocks = acc.blocks.slice();\n      const {\n        treeDepth, data, overlappingSubTreeRoots, overlappingSubTreeRoot,\n      } = appointment;\n      const { offset, start, end } = data;\n\n      if (overlappingSubTreeRoots.length !== 0) {\n        if (!overlappingSubTreeRoot) {\n          blocks.push({\n            start, end, minOffset: offset, maxOffset: offset + treeDepth,\n            size: treeDepth + 1, items: [], endForChildren: end,\n          });\n        }\n        overlappingSubTreeRoots.forEach((subTreeRootIndex) => {\n          const subTreeRoot = items[subTreeRootIndex];\n          const { data: subTreeRootData } = subTreeRoot;\n          blocks.push({\n            start: subTreeRootData.start, end,\n            minOffset: subTreeRootData.offset, maxOffset: offset - 1,\n            size: calculateBlockSizeByEndDate(items, subTreeRoot, end), items: [],\n            endForChildren: subTreeRootData.end,\n          });\n        });\n      }\n\n      const blockIndex = findBlockIndexByAppointment(blocks, appointment);\n      blocks[blockIndex].items.push(index);\n      const appointmentInBlock = { ...appointment, blockIndex };\n\n      return {\n        blocks,\n        appointments: [...acc.appointments, appointmentInBlock],\n      };\n    }, {\n      blocks: [{\n        start: items[0].data.start,\n        end: items[0].data.end,\n        minOffset: 0,\n        maxOffset: reduceValue - 1,\n        size: reduceValue,\n        items: [],\n        endForChildren: items[0].data.end,\n      }] as AppointmentBlock[],\n      appointments: [] as TreeNodeInBlock[],\n    });\n    return {\n      blocks: nextBlocks,\n      appointmentForest: {\n        ...appointmentForest,\n        items: appointments,\n      },\n    };\n  });\n\nconst calculateBlockSizeByEndDate: CalculateBlockSizeBEndDateFn = (\n  appointmentNodes, subTreeRoot, blockEndDate,\n) => {\n  const { children, data } = subTreeRoot;\n  const { start } = data;\n\n  if (children.length === 0) {\n    if (blockEndDate.isAfter(start)) {\n      return 1;\n    }\n    return 0;\n  }\n  const maxSize = Math.max(\n    ...children.map(childIndex => calculateBlockSizeByEndDate(\n      appointmentNodes, appointmentNodes[childIndex], blockEndDate),\n    ),\n  );\n\n  if (blockEndDate.isSameOrBefore(start) && maxSize === 0) {\n    return 0;\n  }\n  return maxSize + 1;\n};\n\nexport const findBlockIndexByAppointment: FindBlockIndexByAppointmentFn = (\n  blocks, appointment,\n) => {\n  const { start, offset } = appointment.data;\n\n  let blockIndex = blocks.length - 1;\n  while (blockIndex > 0) {\n    const currentBlock = blocks[blockIndex];\n    if (intervalIncludes(currentBlock.start, currentBlock.end, start)\n      && offset >= currentBlock.minOffset && offset <= currentBlock.maxOffset\n    ) {\n      break;\n    }\n    blockIndex -= 1;\n  }\n\n  return blockIndex;\n};\n\nexport const findIncludedBlocks: FindIncludedBlocksFn = (groupedIntoBlocks) => {\n  return groupedIntoBlocks.map(({ blocks, appointmentForest }) => {\n    const nextBlocks = blocks.map(props => ({ ...props })) as IncludedBlock[];\n\n    nextBlocks.forEach((block, blockIndex) => {\n      block.includedBlocks = [];\n      for (\n        let currentBlockIndex = blockIndex + 1;\n        currentBlockIndex < nextBlocks.length;\n        currentBlockIndex += 1\n      ) {\n        const currentBlock = nextBlocks[currentBlockIndex];\n        if (isIncludedBlock(block, currentBlock)) {\n          block.includedBlocks.push(currentBlockIndex);\n          currentBlock.includedInto = blockIndex;\n        }\n      }\n    });\n    return {\n      blocks: nextBlocks, appointmentForest,\n    };\n  });\n};\n\nconst isIncludedBlock: IsIncludedBlockFn = (block, possibleIncludedBlock) => {\n  const { start, end, minOffset, maxOffset } = block;\n  const {\n    start: possibleIncludedStart, end: possibleIncludedEnd,\n    minOffset: possibleMinOffset, maxOffset: possibleMaxOffset,\n  } = possibleIncludedBlock;\n  return intervalIncludes(start, end, possibleIncludedStart)\n    && intervalIncludes(start, end, possibleIncludedEnd)\n    && possibleMaxOffset <= maxOffset && possibleMinOffset >= minOffset;\n};\n\nexport const findChildBlocks: FindChildBlocksFn = (groupedIntoBlocks) => {\n  return groupedIntoBlocks.map(({ blocks, appointmentForest }) => {\n    const nextBlocks = blocks.map(props => ({ ...props })) as BlockWithChildren[];\n\n    nextBlocks.forEach((block, index) => {\n      block.children = [];\n      for (let currentIndex = index + 1; currentIndex < nextBlocks.length; currentIndex += 1) {\n        const nextBlock = nextBlocks[currentIndex];\n\n        if (isChildBlock(block, nextBlock)) {\n          block.children.push(currentIndex);\n          nextBlock.parent = index;\n        }\n      }\n      return block;\n    });\n    return {\n      appointmentForest, blocks: nextBlocks,\n    };\n  });\n};\n\nconst isChildBlock: IsChildBlockFn = (block, possibleChildBlock) => {\n  const { start, endForChildren, minOffset, includedInto } = block;\n  const {\n    start: childStart, includedInto: childIncludedInto, maxOffset: childMaxOffset,\n  } = possibleChildBlock;\n  return intervalIncludes(start, endForChildren, childStart)\n    && childMaxOffset + 1 === minOffset\n    && (\n      childIncludedInto === undefined\n      || childIncludedInto === includedInto\n    );\n};\n\nexport const adjustByBlocks: AdjustByBlocksFn = (\n  groupedIntoBlocks, indirectChildLeftOffset,\n) => {\n  const updatedBlocks = groupedIntoBlocks.map(({ blocks, appointmentForest }) => {\n    const dimensionsCalculated = calculateBlocksDimensions(blocks, appointmentForest.items);\n\n    return {\n      blocks: alignBlocksWithPrevious(dimensionsCalculated, appointmentForest.items),\n      appointmentForest,\n    };\n  });\n  const adjustedByBlocks = updatedBlocks.map(({ blocks, appointmentForest }) => {\n    return {\n      ...appointmentForest,\n      items: adjustAppointmentsByBlocks(\n        appointmentForest.items, blocks, indirectChildLeftOffset,\n        ) as TreeNodeInBlock[],\n    };\n  });\n  return adjustedByBlocks;\n};\n\nconst calculateBlocksDimensions: CalculateBlockDimensionsFn = (\n  blocks, appointments,\n) => updateBlocksProportions(calculateBlocksLeftLimit(\n  calculateBlocksTotalSize(blocks), appointments,\n));\n\nconst alignBlocksWithPrevious: AlignBlocksWithPreviousFn = (blocks, appointments) => {\n  const nextBlocks = blocks.map(({ right, ...restProps }) => ({ ...restProps }));\n\n  const leftLimitCalculated = calculateBlocksLeftLimit(\n    updateBlocksLeft(nextBlocks as CalculatedBlock[], appointments), appointments,\n  );\n  return updateBlocksProportions(leftLimitCalculated);\n};\n\nconst adjustAppointmentsByBlocks: AdjustAppointemntsByBlocksFn = (\n  appointments, blocks, indirectChildLeftOffset,\n) => {\n  const nextAppointments = appointments.map(props => ({ ...props }));\n  const nextBlocks = blocks.map(props => ({ ...props }));\n\n  nextBlocks.forEach((block, index) => {\n    if (index !== 0) {\n      const { items, left: blockLeft, right, children } = block;\n      const maxRight = calculateIncludedBlockMaxRight(nextBlocks, block);\n      const finalMaxRight = maxRight * right;\n      const defaultLeft = blockLeft! * maxRight;\n\n      items.forEach((appointmentIndex, itemIndex) => {\n        const appointment = nextAppointments[appointmentIndex];\n        if (itemIndex === 0) {\n          const { left, width } = calculateAppointmentLeftAndWidth(\n            nextAppointments, nextBlocks, appointment,\n            finalMaxRight, indirectChildLeftOffset, defaultLeft,\n          );\n          appointment.data.left = left;\n          appointment.data.width = width;\n          if (defaultLeft !== left) {\n            children.forEach((childIndex) => {\n              redistributeChildBlocks(nextBlocks, childIndex, left / maxRight);\n            });\n          }\n        } else {\n          const {\n            left, width,\n          } = calculateAppointmentLeftAndWidth(\n            nextAppointments, nextBlocks, appointment,\n            finalMaxRight, indirectChildLeftOffset, undefined,\n          );\n          appointment.data.left = left;\n          appointment.data.width = width;\n        }\n      });\n    }\n  });\n  blocks[0].items.forEach((appointmentIndex) => {\n    const appointment = nextAppointments[appointmentIndex];\n    const {\n      left, width,\n    } = calculateAppointmentLeftAndWidth(\n      nextAppointments, blocks, appointment, 1, indirectChildLeftOffset, undefined,\n    );\n    appointment.data.left = left;\n    appointment.data.width = width;\n  });\n  return nextAppointments;\n};\n\nconst redistributeChildBlocks: RedistributeBlocksFn = (blocks, blockIndex, right) => {\n  const block = blocks[blockIndex];\n  const { leftOffset, size, leftLimit, children } = block;\n  block.right = right;\n  const width = size + leftOffset;\n  const relativeWidth = right - leftLimit;\n  const left = right - relativeWidth * size / width;\n  block.left = left;\n  children.forEach((childIndex) => {\n    redistributeChildBlocks(blocks, childIndex, left);\n  });\n};\n\nexport const calculateIncludedBlockMaxRight: CalculateIncludedBlockMaxRightFn = (\n  blocks, includedBlock,\n) => {\n  const { includedInto: includedIntoIndex } = includedBlock;\n  if (includedIntoIndex === undefined) {\n    return 1;\n  }\n\n  const includedInto = blocks[includedIntoIndex];\n  const currentMaxRight = includedInto.right;\n  return currentMaxRight * calculateIncludedBlockMaxRight(blocks, includedInto);\n\n};\n\nexport const calculateBlocksTotalSize: CalculateBlocksTotalSizeFn = (blocks) => {\n  const result = blocks.map((block) => {\n    const totalSize = calculateSingleBlockTotalSize(blocks, block);\n    return {\n      ...block,\n      totalSize,\n      leftOffset: totalSize - block.size,\n    };\n  });\n  return result;\n};\n\nconst calculateSingleBlockTotalSize: CalculateSingleBlockTotalSizeFn = (\n  blocks, block,\n) => {\n  const { children, size } = block;\n  if (children.length === 0) {\n    return size;\n  }\n  return Math.max(\n    ...children.map(childIndex => calculateSingleBlockTotalSize(blocks, blocks[childIndex])),\n  ) + size;\n};\n\nexport const calculateBlocksLeftLimit: CalculateBlocksLeftLimitFn = (\n  blocks, appointments,\n) => (blocks as CalculatedBlock[]).map((block) => {\n  const leftLimit = calculateSingleBlockLeftLimit(blocks, appointments, block);\n  return {\n    ...block,\n    leftLimit,\n  };\n});\n\nconst calculateSingleBlockLeftLimit: CalculateSingleBlockLeftLimitFn = (\n  blocks, appointments, block,\n) => {\n  const { children, items, left } = block as CalculatedBlock;\n  if (children.length === 0) {\n    return left !== undefined\n      ? Math.min(left, appointments[items[0]].data.left)\n      : appointments[items[0]].data.left;\n  }\n  return Math.min(\n    ...children.map(childIndex => calculateSingleBlockLeftLimit(\n      blocks, appointments, blocks[childIndex],\n    )),\n  );\n};\n\nexport const updateBlocksProportions: UpdateBlocksProportionsFn = (blocks) => {\n  const nextBlocks = (blocks as CalculatedBlock[]).map(props => ({ ...props }));\n\n  nextBlocks.forEach((block) => {\n    const { parent: parentIndex, leftLimit, leftOffset, totalSize } = block;\n    if (parentIndex === undefined) {\n      block.right = 1;\n      block.left = (1 - leftLimit) * leftOffset / totalSize + leftLimit;\n      return;\n    }\n\n    const parent = nextBlocks[parentIndex];\n    const { left: parentLeft, totalSize: parentTotalSize } = parent as CalculatedBlock;\n    block.totalSize = parentTotalSize;\n    block.right = parentLeft as number;\n    block.left = (1 - leftLimit) * leftOffset / parentTotalSize + leftLimit;\n  });\n\n  return nextBlocks;\n};\n\nexport const updateBlocksLeft: UpdateBlocksLeftFn = (\n  blocks, appointments,\n) => blocks.map((block) => {\n  const { items, left } = block;\n  const firstItem = appointments[items[0]];\n  const { parent: firstItemParentIndex } = firstItem;\n  if (firstItemParentIndex === undefined) {\n    return block;\n  }\n\n  const firstItemParent = appointments[firstItemParentIndex];\n  const parentBlock = blocks[firstItemParent.blockIndex];\n\n  return {\n    ...block,\n    left: parentBlock.parent === undefined ? left : blocks[parentBlock.parent].left,\n  };\n});\n\nconst createAndAdjustAppointmentForest: CreateAndAdjustAppointmentForestFn = (\n  appointmentGroups, cellDuration,\n) => {\n  const appointmentForest = createAppointmentForest(appointmentGroups, cellDuration);\n  const indirectChildLeftOffset = Math.min(\n    1 / findMaxReduceValue(appointmentForest),\n    INDIRECT_CHILD_LEFT_OFFSET,\n  );\n  const baseCalculated = calculateAppointmentsMetaData(\n    appointmentForest, indirectChildLeftOffset,\n  );\n\n  const preparedToGroupIntoBlocks = prepareToGroupIntoBlocks(baseCalculated);\n  const groupedIntoBlocks = groupAppointmentsIntoBlocks(preparedToGroupIntoBlocks);\n  const blocksWithIncluded = findIncludedBlocks(groupedIntoBlocks);\n  const blocksWithParents = findChildBlocks(blocksWithIncluded);\n  return adjustByBlocks(blocksWithParents, indirectChildLeftOffset);\n};\n\nexport const calculateRectByDateAndGroupIntervals: CalculateRectByDateAndGroupIntervalsFn = (\n  type, intervals, rectByDates, rectByDatesMeta, viewMetaData,\n) => {\n  const { growDirection, multiline } = type;\n  const isHorizontal = growDirection === HORIZONTAL_TYPE;\n\n  const sorted = intervals.map(sortAppointments);\n  const grouped = sorted.reduce(((acc, sortedGroup) => [\n    ...acc,\n    ...findOverlappedAppointments(sortedGroup as AppointmentMoment[], isHorizontal),\n  ]), [] as AppointmentMoment[]);\n\n  const { cellDuration, placeAppointmentsNextToEachOther } = rectByDatesMeta;\n  const rectCalculator = isHorizontal\n    ? horizontalRectCalculator\n    : placeAppointmentsNextToEachOther ? oldVerticalRectCalculator : verticalRectCalculator;\n\n  const groupsCalculated = calculateAppointmentOffsets(\n    grouped as any[], isHorizontal,\n  );\n  const isAppointmentForestNeeded = !isHorizontal && !placeAppointmentsNextToEachOther;\n  let appointmentForest: GroupedIntoBlocksForest[];\n\n  if (isAppointmentForestNeeded) {\n    appointmentForest = createAndAdjustAppointmentForest(\n      groupsCalculated as AppointmentGroup[], cellDuration,\n    ) as GroupedIntoBlocksForest[];\n  }\n\n  const unwrappedAppointments = isAppointmentForestNeeded\n    ? unwrapAppointmentForest(appointmentForest!)\n    : unwrapGroups(groupsCalculated);\n  const rects = unwrappedAppointments.map(appointment => rectCalculator(\n    appointment, viewMetaData,\n    { rectByDates, multiline, rectByDatesMeta },\n  ));\n  return rects.sort((first, second) => first.offset! >= second.offset! ? 1 : -1);\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  AppointmentMoment, DayBoundaryPredicateFn,\n  ReduceAppointmentByDayBoundsFn, NormalizeAppointmentDurationFn, ViewCell, SchedulerDateTime,\n} from '../../types';\nimport { checkCellGroupingInfo } from '../common/helpers';\nimport { addDateToKey } from '../../utils';\n\nexport const sliceAppointmentByDay: PureComputed<\n  [AppointmentMoment, number], AppointmentMoment[]\n> = (appointment, cellDuration) => {\n  const { start, end, dataItem, key } = appointment;\n  if (start.isSame(end, 'day')) return [appointment];\n\n  const minDuration = cellDuration / 2;\n  const isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  const isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n  const firstAppointmentKey = addDateToKey(key, start);\n  const secondAppointmentKey = addDateToKey(key, end);\n\n  return [\n    isShortOnFirstDay ? {\n      start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n      end: start.clone().endOf('day'),\n      dataItem,\n      key: firstAppointmentKey,\n    } : {\n      start, end: start.clone().endOf('day'), dataItem,\n      key: firstAppointmentKey,\n    },\n    isShortOnSecondDay ? {\n      start: end.clone().startOf('day'),\n      end: end.clone().startOf('day').add(minDuration, 'minutes'),\n      dataItem,\n      key: secondAppointmentKey,\n    } : {\n      start: end.clone().startOf('day'), end, dataItem,\n      key: secondAppointmentKey,\n    },\n  ];\n};\n\nexport const dayBoundaryPredicate: DayBoundaryPredicateFn = (\n  appointment,\n  leftBound, rightBound,\n  excludedDays = [],\n) => {\n  const dayStart = moment(leftBound as Date);\n  const dayEnd = moment(rightBound as Date);\n  const startDayTime = moment(appointment.start)\n    .hour(dayStart.hour())\n    .minutes(dayStart.minutes());\n  const endDayTime = moment(appointment.start)\n    .hour(dayEnd.hour())\n    .minutes(dayEnd.minutes());\n\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(day => day === moment(appointment.start).day()) !== -1) return false;\n  return (appointment.end.isAfter(startDayTime)\n    && appointment.start.isBefore(endDayTime));\n};\n\nexport const reduceAppointmentByDayBounds: ReduceAppointmentByDayBoundsFn = (\n  appointment, leftBound, rightBound, cellDuration,\n) => {\n  const dayStart = moment(leftBound as Date);\n  const dayEnd = moment(rightBound as Date);\n  const startDayTime = moment(appointment.start)\n    .hour(dayStart.hour())\n    .minutes(dayStart.minutes())\n    .seconds(dayStart.seconds());\n  const endDayTime = moment(appointment.start)\n    .hour(dayEnd.hour())\n    .minutes(dayEnd.minutes())\n    .seconds(dayEnd.seconds());\n\n  const minDuration = cellDuration / 2;\n  const isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  const isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return {\n      ...appointment, start: endDayTime.clone().add(-minDuration, 'minutes'), end: endDayTime,\n    };\n  }\n\n  if (isShortOnSecondDay) {\n    return {\n      ...appointment, start: startDayTime, end: startDayTime.clone().add(minDuration, 'minutes'),\n    };\n  }\n\n  return {\n    ...appointment,\n    ...(appointment.start.isSameOrBefore(startDayTime) ? { start: startDayTime } : null),\n    ...(appointment.end.isSameOrAfter(endDayTime) ? { end: endDayTime } : null),\n  };\n};\n\nexport const normalizeAppointmentDuration: NormalizeAppointmentDurationFn = (\n  appointment, cellDuration,\n) => {\n  const minDuration = cellDuration / 2;\n  const start = moment(appointment.start as Date);\n  const end = moment(appointment.end as Date);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return { ...appointment, start, end };\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return { ...appointment, start, end: start.clone().add(minDuration, 'minutes') };\n  }\n\n  return {\n    ...appointment,\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n  };\n};\n\nexport const getWeekVerticallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], SchedulerDateTime], number\n> = (viewCellsData, date) =>  viewCellsData[0].findIndex((\n  timeCell: ViewCell,\n) => moment(date as SchedulerDateTime).isSame(timeCell.startDate, 'date'));\n\nexport const getWeekHorizontallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, SchedulerDateTime], number\n> = (viewCellsData, appointment, date) => viewCellsData[0].findIndex((timeCell: ViewCell) => {\n  const isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);\n  return moment(date as SchedulerDateTime).isSame(timeCell.startDate, 'date') && isCorrectGroup;\n});\n\nexport const getWeekVerticallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, SchedulerDateTime, number, boolean, number], number\n> = (viewCellsData, appointment, date, columnIndex, takePrev, groupCount) => {\n  const timeTableHeight = viewCellsData.length / groupCount;\n  let timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(\n    viewCellsData, date, columnIndex, takePrev,\n  );\n\n  if (!viewCellsData[0][0].groupingInfo) return timeTableRowIndex;\n\n  let isWrongCell = !checkCellGroupingInfo(\n    viewCellsData[timeTableRowIndex][columnIndex], appointment,\n  );\n  while (isWrongCell) {\n    timeTableRowIndex += timeTableHeight;\n    isWrongCell = !checkCellGroupingInfo(\n      viewCellsData[timeTableRowIndex][columnIndex], appointment,\n    );\n  }\n  return timeTableRowIndex;\n};\n\nexport const getWeekHorizontallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], SchedulerDateTime, number, boolean], number\n> = (viewCellsData, date, columnIndex, takePrev) => viewCellsData.findIndex(\n  timeCell => moment(date as SchedulerDateTime)\n    .isBetween(\n      timeCell[columnIndex].startDate,\n      timeCell[columnIndex].endDate,\n      'seconds',\n      takePrev ? '(]' : '[)'),\n    );\n","import { CalculateWeekDateIntervalsFn, AppointmentMoment } from '../../types';\nimport {\n  sliceAppointmentByDay, dayBoundaryPredicate, reduceAppointmentByDayBounds,\n  normalizeAppointmentDuration,\n} from './helpers';\nimport { filterByViewBoundaries } from '../../utils';\n\nexport const calculateWeekDateIntervals: CalculateWeekDateIntervalsFn = (\n  appointments,\n  leftBound, rightBound, // startViewDate, endViewDate\n  excludedDays,\n  cellDuration,\n) => [\n  appointments\n    .map(appointment => normalizeAppointmentDuration(appointment, cellDuration))\n    .reduce((acc, appointment) =>\n      [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true)],\n      [] as AppointmentMoment[],\n    )\n    .reduce((acc, appointment) => (\n      [...acc, ...sliceAppointmentByDay(appointment, cellDuration)]), [] as AppointmentMoment[],\n    )\n    .filter(appointment => dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays))\n    .map(appointment => reduceAppointmentByDayBounds(\n      appointment, leftBound, rightBound, cellDuration,\n    )),\n];\n","import moment from 'moment';\nimport {\n  GetCellByAppointmentDataFn, GetVerticalRectByAppointmentDataFn,\n  GetCellRectVerticalFn, SchedulerDateTime,\n} from '../../types';\nimport { VERTICAL_GROUP_ORIENTATION } from '../../constants';\nimport {\n  getWeekHorizontallyGroupedRowIndex, getWeekVerticallyGroupedRowIndex,\n  getWeekHorizontallyGroupedColumnIndex, getWeekVerticallyGroupedColumnIndex,\n} from '../week-view/helpers';\n\nconst CELL_GAP_PX = 10;\nconst CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nconst CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nexport const getVerticalCellIndexByAppointmentData: GetCellByAppointmentDataFn = (\n  appointment, viewCellsData, viewMetaData, date, takePrev = false,\n) => {\n  const { groupOrientation, groupCount } = viewMetaData;\n\n  const columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION\n    ? getWeekVerticallyGroupedColumnIndex(viewCellsData, date)\n    : getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date);\n  const rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION\n    ? getWeekVerticallyGroupedRowIndex(\n      viewCellsData, appointment, date, columnIndex, takePrev, groupCount,\n    ) : getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n\n  const cellIndex = (rowIndex * viewCellsData[0].length) + columnIndex;\n  return {\n    index: cellIndex,\n    startDate: viewCellsData[rowIndex][columnIndex].startDate,\n  };\n};\n\nconst getCellRect: GetCellRectVerticalFn = (\n  date, appointment, viewCellsData, cellDuration,\n  cellElementsMeta, takePrev, viewMetaData,\n) => {\n  const {\n    index: cellIndex,\n    startDate: cellStartDate,\n  } = getVerticalCellIndexByAppointmentData(\n    appointment, viewCellsData, viewMetaData, date, takePrev,\n  );\n\n  const {\n    top,\n    left,\n    width,\n    height: cellHeight,\n  } = cellElementsMeta.getCellRects[cellIndex]();\n  const timeOffset = moment(date as SchedulerDateTime).diff(cellStartDate as Date, 'minutes');\n  const topOffset = cellHeight * (timeOffset / cellDuration);\n  const parentRect = cellElementsMeta.parentRect();\n\n  return {\n    top,\n    left,\n    width,\n    topOffset,\n    parentRect,\n  };\n};\n\nexport const getVerticalRectByAppointmentData: GetVerticalRectByAppointmentDataFn = (\n  appointment,\n  viewMetaData,\n  {\n    viewCellsData,\n    cellDuration,\n    cellElementsMeta,\n    placeAppointmentsNextToEachOther,\n  },\n) => {\n  const firstCellRect = getCellRect(\n    appointment.start.toDate(), appointment, viewCellsData,\n    cellDuration, cellElementsMeta, false, viewMetaData,\n  );\n  const lastCellRect = getCellRect(\n    appointment.end.toDate(), appointment, viewCellsData,\n    cellDuration, cellElementsMeta, true, viewMetaData,\n  );\n\n  const top = firstCellRect.top + firstCellRect.topOffset;\n  const height = (lastCellRect.top + lastCellRect.topOffset) - top;\n\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: placeAppointmentsNextToEachOther ? height - CELL_BOUND_VERTICAL_OFFSET_PX : height,\n  };\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  AppointmentMoment, GetAllDayCellIndexByAppointmentDataFn,\n  SliceAppointmentsByBoundariesFn, SchedulerDateTime, ViewCell,\n} from '../../types';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\nimport { checkCellGroupingInfo } from '../common/helpers';\n\nexport const allDayPredicate: PureComputed<[AppointmentMoment], boolean> = appointment => (\n  appointment.end.diff(appointment.start, 'hours') > 23\n  || !!appointment.allDay\n);\n\nexport const getAllDayCellIndexByAppointmentData: GetAllDayCellIndexByAppointmentDataFn = (\n  viewCellsData, viewMetaData, date, appointment, takePrev,\n) => {\n  const currentDate = moment(date as SchedulerDateTime);\n  const { groupOrientation, groupCount } = viewMetaData;\n\n  const columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData, currentDate, appointment)\n    : getAllDayVerticallyGroupedColumnIndex(viewCellsData, currentDate);\n  const rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount);\n\n  let cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n  return cellIndex;\n};\n\nexport const getAllDayVerticallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], moment.Moment], number\n> = (viewCellsData, date) => viewCellsData[0].findIndex((timeCell) => {\n  return date.isSame(timeCell.startDate, 'date');\n});\n\nexport const getAllDayHorizontallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], moment.Moment, AppointmentMoment], number\n> = (viewCellsData, date, appointment) => viewCellsData[0].findIndex(timeCell => (\n  date.isSame(timeCell.startDate, 'date') && checkCellGroupingInfo(timeCell, appointment)\n));\n\nexport const getAllDayVerticallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, number], number\n> = (viewCellsData, appointment, groupCount) => {\n  const index = viewCellsData.findIndex(viewCellsDataRow => checkCellGroupingInfo(\n    viewCellsDataRow[0], appointment,\n  ));\n  return index * groupCount / viewCellsData.length;\n};\n\nexport const sliceAppointmentsByBoundaries: SliceAppointmentsByBoundariesFn = (\n  appointment, left, right, excludedDays = [],\n) => {\n  const startDate = appointment.start.clone();\n  const endDate = appointment.end.clone();\n  let nextStart = startDate.clone();\n  let nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left as Date)) {\n    nextStart = moment(left as Date);\n    nextStart.startOf('day');\n  }\n  if (endDate.isAfter(right as Date)) {\n    nextEnd = moment(right as Date);\n    nextEnd.endOf('day');\n  }\n  if (excludedDays.findIndex(day => day === startDate.day()) !== -1) {\n    while (excludedDays.findIndex(day => day === nextStart.day()) !== -1\n      && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n  if (excludedDays.findIndex(day => day === endDate.day()) !== -1) {\n    while (excludedDays.findIndex(day => day === nextEnd.day()) !== -1\n      && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n  return [{ ...appointment, start: nextStart, end: nextEnd }];\n};\n\nexport const sliceAppointmentsByDays: PureComputed<\n  [AppointmentMoment, number[]], AppointmentMoment[]\n> = (appointment, excludedDays = []) => {\n  const startDate = appointment.start;\n  const endDate = appointment.end;\n  let nextStart = startDate.clone();\n  const appointments = [] as AppointmentMoment[];\n\n  while (nextStart.isBefore(endDate)) {\n    if (excludedDays.findIndex(day => day === nextStart.day()) === - 1) {\n      appointments.push({\n        ...appointment,\n        start: nextStart,\n        end: moment(nextStart).endOf('day'),\n      });\n    }\n    nextStart = moment(nextStart).add(1, 'day');\n  }\n  return appointments;\n};\n","import { RRule } from 'rrule';\n\nexport const DEFAULT_RULE_OBJECT = {\n  interval: 1,\n};\n\nexport const DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6,\n};\n\nexport const RRULE_DAYS_OF_WEEK = [\n  RRule.MO,\n  RRule.TU,\n  RRule.WE,\n  RRule.TH,\n  RRule.FR,\n  RRule.SA,\n  RRule.SU,\n];\n\nexport const DAYS_IN_WEEK = 7;\n\nexport const DAYS_OF_WEEK_ARRAY = [\n  DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY,\n  DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY,\n];\n\nexport const MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12,\n};\n\nexport const RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY as number,\n  MONTHLY: RRule.MONTHLY as number,\n  WEEKLY: RRule.WEEKLY as number,\n  DAILY: RRule.DAILY as number,\n  HOURLY: RRule.HOURLY as number,\n  MINUTELY: RRule.MINUTELY as number,\n};\n\nexport const REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never',\n};\n\nexport const REPEAT_TYPES_ARRAY = [\n  REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY,\n];\n\nexport const WEEK_NUMBER_LABELS = [\n  'firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel',\n];\n\nexport const END_REPEAT_RADIO_GROUP = 'endRepeat';\nexport const MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nexport const YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\n\nexport const TITLE_TEXT_EDITOR = 'titleTextEditor';\nexport const MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nexport const ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nexport const NUMBER_EDITOR = 'numberEditor';\n\nexport const TITLE = 'title';\nexport const ORDINARY_LABEL = 'ordinaryLabel';\n\nexport const SAVE_BUTTON = 'saveButton';\nexport const DELETE_BUTTON = 'deleteButton';\nexport const CANCEL_BUTTON = 'cancelButton';\n\nexport const OUTLINED_SELECT = 'outlinedSelect';\nexport const STANDARD_SELECT = 'standardSelect';\n\nexport const SUNDAY_DATE = new Date(2019, 7, 11);\nexport const MONDAY_DATE = new Date(2019, 7, 12);\nexport const TUESDAY_DATE = new Date(2019, 7, 13);\nexport const WEDNESDAY_DATE = new Date(2019, 7, 14);\nexport const THURSDAY_DATE = new Date(2019, 7, 15);\nexport const FRIDAY_DATE = new Date(2019, 7, 16);\nexport const SATURDAY_DATE = new Date(2019, 7, 17);\n\nexport const DAYS_OF_WEEK_DATES = [\n  SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE,\n  THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE,\n];\n\nexport const JANUARY_DATE = new Date(2019, 0, 1);\nexport const FEBRUARY_DATE = new Date(2019, 1, 1);\nexport const MARCH_DATE = new Date(2019, 2, 1);\nexport const APRIL_DATE = new Date(2019, 3, 1);\nexport const MAY_DATE = new Date(2019, 4, 1);\nexport const JUNE_DATE = new Date(2019, 5, 1);\nexport const JULY_DATE = new Date(2019, 6, 1);\nexport const AUGUST_DATE = new Date(2019, 7, 1);\nexport const SEPTEMBER_DATE = new Date(2019, 8, 1);\nexport const OCTOBER_DATE = new Date(2019, 9, 1);\nexport const NOVEMBER_DATE = new Date(2019, 10, 1);\nexport const DECEMBER_DATE = new Date(2019, 11, 1);\n\nexport const MONTHS_DATES = [\n  JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE,\n  JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE,\n];\n\nexport const FIRST_WEEK = 0;\nexport const SECOND_WEEK = 1;\nexport const THIRD_WEEK = 2;\nexport const FOURTH_WEEK = 3;\nexport const LAST_WEEK = 4;\n\nexport const BASIC_YEALY_COUNT = 5;\nexport const BASIC_MONTHLY_COUNT = 12;\nexport const BASIC_WEEKLY_COUNT = 13;\nexport const BASIC_DAILY_COUNT = 30;\n","import moment from 'moment';\nimport {\n  SliceAppointmentByWeekFn, GetMonthCellIndexByAppointmentDataFn,\n  SchedulerDateTime, AppointmentMoment, ViewCell,\n} from '../../types';\nimport { DAYS_IN_WEEK } from '../appointment-form/constants';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\nimport { checkCellGroupingInfo } from '../common/helpers';\nimport { addDateToKey } from '../../utils';\n\nexport const sliceAppointmentByWeek: SliceAppointmentByWeekFn = (timeBounds, appointment, step) => {\n  const { left, right } = timeBounds;\n  const pieces: AppointmentMoment[] = [];\n  const { start, end, key, ...restFields } = appointment;\n  let apptStart = start;\n  let apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  let pieceFrom = apptStart.clone();\n  let pieceTo = apptStart.clone();\n  let i = 0;\n  while (pieceTo.isBefore(apptEnd)) {\n    const currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push({\n          start: pieceFrom,\n          end: pieceTo,\n          key: addDateToKey(key, pieceFrom),\n          ...restFields,\n        });\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n    i += 1;\n  }\n  return pieces;\n};\n\nexport const getMonthCellIndexByAppointmentData: GetMonthCellIndexByAppointmentDataFn = (\n  viewCellsData, viewMetaData, date, appointment, takePrev = false,\n) => {\n  const {\n    groupOrientation,\n    groupedByDate,\n    groupCount,\n  } = viewMetaData;\n\n  const startViewDate = moment(viewCellsData[0][0].startDate);\n  const currentDate = moment(date as SchedulerDateTime);\n  let dayNumber = currentDate.diff(startViewDate, 'days');\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    dayNumber -= 1;\n  }\n  const weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);\n  const dayOfWeek = dayNumber % DAYS_IN_WEEK;\n\n  const columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? getMonthHorizontallyGroupedColumnIndex(\n      viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate,\n    )\n    : dayOfWeek;\n  const rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? weekNumber\n    : getMonthVerticallyGroupedRowIndex(\n      viewCellsData, appointment, weekNumber, dayOfWeek, groupCount,\n    );\n\n  const totalCellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return totalCellIndex;\n};\n\nexport const getMonthHorizontallyGroupedColumnIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, number, number, number, boolean], number\n> = (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) => {\n  let columnIndex = -1;\n  let currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;\n  const cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;\n\n  while (columnIndex === -1) {\n    const isCorrectCell = checkCellGroupingInfo(\n      viewCellsData[weekNumber][currentColumnIndex], appointment,\n    );\n    if (isCorrectCell) {\n      columnIndex = currentColumnIndex;\n    }\n    currentColumnIndex += cellsInGroupRow;\n  }\n  return columnIndex;\n};\n\nexport const getMonthVerticallyGroupedRowIndex: PureComputed<\n  [ViewCell[][], AppointmentMoment, number, number, number], number\n> = (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount) => {\n  const rowsInOneGroup = viewCellsData.length / groupCount;\n  let rowIndex = -1;\n  let currentRowIndex = weekNumber;\n  while (rowIndex === -1) {\n    const isCorrectCell = checkCellGroupingInfo(\n      viewCellsData[currentRowIndex][dayOfWeek], appointment,\n    );\n    if (isCorrectCell) {\n      rowIndex = currentRowIndex;\n    }\n    currentRowIndex += rowsInOneGroup;\n  }\n  return rowIndex;\n};\n","import { GetCellRectHorizontalFn, GetHorizontalRectByAppointmentDataFn } from '../../types';\nimport { getAllDayCellIndexByAppointmentData } from '../all-day-panel/helpers';\nimport { getMonthCellIndexByAppointmentData } from '../month-view/helpers';\n\nconst TOP_CELL_OFFSET = 0.32;\nconst CELL_BOUND_OFFSET_PX = 1;\n\nconst getCellRect: GetCellRectHorizontalFn = (\n  date, appointment, viewCellsData, viewMetaData, cellElementsMeta, takePrev, multiline,\n) => {\n  const cellIndex = multiline\n    ? getMonthCellIndexByAppointmentData(\n      viewCellsData, viewMetaData, date, appointment, takePrev,\n    ) : getAllDayCellIndexByAppointmentData(\n      viewCellsData, viewMetaData, date, appointment, takePrev,\n    );\n\n  const {\n    top,\n    left,\n    width,\n    height,\n  } = cellElementsMeta.getCellRects[cellIndex]();\n  const parentRect = cellElementsMeta.parentRect();\n  return {\n    top,\n    left,\n    width,\n    height,\n    parentRect,\n  };\n};\n\nexport const getHorizontalRectByAppointmentData: GetHorizontalRectByAppointmentDataFn = (\n  appointment,\n  viewMetaData,\n  {\n    multiline,\n    viewCellsData,\n    cellElementsMeta,\n  },\n) => {\n  const firstCellRect = getCellRect(\n    appointment.start.toDate(), appointment, viewCellsData,\n    viewMetaData, cellElementsMeta, false, multiline,\n  );\n  const lastCellRect = getCellRect(\n    appointment.end.toDate(), appointment, viewCellsData,\n    viewMetaData, cellElementsMeta, true, multiline,\n  );\n\n  const top = firstCellRect.top + (firstCellRect.height * TOP_CELL_OFFSET);\n  const height = firstCellRect.height - (firstCellRect.height * TOP_CELL_OFFSET);\n\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: (firstCellRect.left - firstCellRect.parentRect.left) + CELL_BOUND_OFFSET_PX,\n    width: ((lastCellRect.left - firstCellRect.left) + firstCellRect.width) - CELL_BOUND_OFFSET_PX,\n    height,\n    parentWidth: firstCellRect.parentRect.width,\n  };\n};\n","import moment from 'moment';\nimport {\n  MonthCellsDataComputedFn, MonthCellData,\n  CalculateMonthDateIntervalsFn, AppointmentMoment,\n} from '../../types';\nimport { filterByViewBoundaries } from '../../utils';\nimport { sliceAppointmentByWeek } from './helpers';\n\nconst DAY_COUNT = 7;\nconst MONTH_LENGTH = 31;\n\nexport const monthCellsData: MonthCellsDataComputedFn = (\n  currentDate,\n  firstDayOfWeek,\n  intervalCount = 1,\n  today,\n) => {\n  const targetDate = moment(currentDate as Date);\n  const currentMonths = [targetDate.month()];\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n  const firstMonthDate = moment(currentDate as Date).date(1);\n  const firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  const prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  const prevMonth = moment(currentDate as Date).subtract(1, 'months');\n  const prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  const from = moment()\n    .year(prevMonth.year())\n    .month(prevMonth.month())\n    .date(prevMonthStartDay)\n    .startOf('day');\n\n  const result: MonthCellData[][] = [];\n  while (result.length < (Math.trunc((MONTH_LENGTH * intervalCount) / DAY_COUNT) + 2)) {\n    const week: MonthCellData[] = [];\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(month => month === from.month()) === -1,\n        today: today ? moment(today as Date).isSame(from, 'date') : false,\n      });\n      from.add(1, 'day');\n    }\n    result.push(week);\n  }\n  return result;\n};\n\nexport const calculateMonthDateIntervals: CalculateMonthDateIntervalsFn = (\n  appointments, leftBound, rightBound,\n) => [\n  appointments\n    .map(({ start, end, ...restArgs }) => ({ start: moment(start), end: moment(end), ...restArgs }))\n    .reduce((acc, appointment) =>\n      [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, [], false)],\n      [] as AppointmentMoment[],\n    )\n    .reduce((acc, appointment) => ([\n      ...acc,\n      ...sliceAppointmentByWeek(\n        { left: moment(leftBound as Date), right: moment(rightBound as Date) },\n        appointment,\n        DAY_COUNT,\n      ),\n    ]), [] as AppointmentMoment[]),\n];\n","import moment from 'moment';\nimport {\n  AppointmentMoment, CalculateAllDayDateIntervalsFn,\n} from '../../types';\nimport { allDayPredicate, sliceAppointmentsByBoundaries } from './helpers';\nimport { filterByViewBoundaries } from '../../utils';\n\nexport const calculateAllDayDateIntervals: CalculateAllDayDateIntervalsFn = (\n  appointments,\n  leftBound, rightBound,\n  excludedDays,\n) => [\n  appointments\n    .map(({ start, end, ...restArgs }) => ({ start: moment(start), end: moment(end), ...restArgs }))\n    .reduce((acc, appointment) =>\n      [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false)],\n      [] as AppointmentMoment[],\n    )\n    .filter(appointment => allDayPredicate(appointment))\n    .reduce((acc, appointment) => ([\n      ...acc,\n      ...sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays),\n    ]), [] as AppointmentMoment[]),\n];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  ValidResourceInstance, Group, ViewCell, ValidResource,\n  AppointmentMoment, Grouping, GroupOrientation, AppointmentKey,\n} from '../../types';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\n\nexport const getGroupFromResourceInstance: PureComputed<\n  [ValidResourceInstance], Group\n> = resourceInstance => ({\n  id: resourceInstance.id,\n  fieldName: resourceInstance.fieldName,\n  text: resourceInstance.text,\n});\n\nexport const addGroupInfoToCells: PureComputed<\n  [Group, Group[][], ValidResource[],\n  ViewCell[], number, boolean, GroupOrientation], ViewCell[]\n> = (\n  currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation,\n) => viewCellRow.map((\n    viewCell: ViewCell, cellIndex: number,\n  ) => {\n  const groupedCell = addGroupInfoToCell(\n    currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation,\n  ) as ViewCell;\n  return cellIndex === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION\n    ? { ...groupedCell, endOfGroup: true }\n    : groupedCell;\n});\n\nexport const addGroupInfoToCell: PureComputed<\n  [Group, Group[][], ValidResource[],\n  ViewCell, number, boolean, GroupOrientation], ViewCell\n> = (currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) => {\n  let previousIndex = index;\n  const groupingInfo = groups.reduceRight((\n    acc: Group[], group: Group[], currentIndex: number,\n  ) => {\n    if (currentIndex === groups.length - 1) return acc;\n    const previousResourceLength = sortedResources[currentIndex + 1].instances.length;\n    const currentGroupingInstance = group[Math.floor(\n      previousIndex / previousResourceLength,\n    )];\n    previousIndex = currentIndex;\n    return [...acc, currentGroupingInstance];\n  }, [currentGroup]);\n  return { ...viewCell, groupingInfo, endOfGroup, groupOrientation };\n};\n\nconst getCurrentGroup: PureComputed<\n  [Group[][], ValidResource[], number, Group], Group[]\n> = (groups, resources, index, group) => {\n  let currentIndex = index;\n  return groups.reduceRight((groupAcc, groupsRow, rowIndex) => {\n    if (rowIndex === groups!.length - 1) {\n      return groupAcc;\n    }\n    currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);\n    const currentInstance = groupsRow[currentIndex];\n    return [\n      ...groupAcc,\n      currentInstance,\n    ];\n  }, [group]);\n};\n\nexport const groupAppointments: PureComputed<\n  [AppointmentMoment[], ValidResource[] | undefined,\n  Group[][] | undefined], AppointmentMoment[][]\n> = (appointments, resources, groups) => {\n  if (!resources || !groups) return [appointments.slice()];\n  const mainResource = resources.find(resource => resource.isMain);\n  return groups![groups!.length - 1].map((group, index) => {\n    const currentGroup = getCurrentGroup(groups, resources, index, group);\n\n    return appointments.reduce((acc, appointment) => {\n      const belongsToGroup = currentGroup.reduce((isBelonging, groupItem) => (\n        isBelonging && groupItem.id === appointment[groupItem.fieldName]\n      ), true);\n      if (!belongsToGroup) return acc;\n      const currentMainResourceId = currentGroup.find(\n        groupItem => groupItem.fieldName === mainResource!.fieldName,\n      )!.id;\n\n      const updatedAppointment = {\n        ...appointment,\n        dataItem: {\n          ...appointment.dataItem,\n          [mainResource!.fieldName]: rearrangeResourceIds(\n            mainResource!, appointment, currentMainResourceId,\n          ),\n        },\n        resources: appointment.resources && rearrangeResources(\n          mainResource!, appointment, currentMainResourceId,\n        ),\n      };\n      return [...acc, updatedAppointment];\n    }, [] as AppointmentMoment[]);\n  });\n};\n\nconst rearrangeResourceIds: PureComputed<\n  [ValidResource, AppointmentMoment, any], any[] | any\n> = (mainResource, appointment, mainResourceId) => {\n  if (!mainResource.allowMultiple) {\n    return mainResourceId;\n  }\n  return [\n    mainResourceId,\n    ...appointment.dataItem[mainResource!.fieldName].filter((id: any) => id !== mainResourceId),\n  ];\n};\n\nexport const rearrangeResources: PureComputed<\n  [ValidResource, AppointmentMoment, any], ValidResourceInstance[]\n> = (mainResource, appointment, currentResourceInstanceId) => {\n  if (!mainResource.allowMultiple) {\n    return appointment.resources;\n  }\n  const resources = appointment.resources.slice();\n  const firstMainResource = resources.findIndex((el: ValidResourceInstance) => el.isMain);\n  const currentResourceIndex = resources.findIndex(\n    (el: ValidResourceInstance) => el.isMain && el.id === currentResourceInstanceId,\n  );\n  [resources[firstMainResource], resources[currentResourceIndex]] =\n    [resources[currentResourceIndex], resources[firstMainResource]];\n  return resources;\n};\n\nexport const expandGroupedAppointment: PureComputed<\n  [AppointmentMoment, Grouping[], ValidResource[]], AppointmentMoment[]\n> = (appointment, grouping, resources) => {\n  if (!resources || !grouping) {\n    return [appointment];\n  }\n  return resources\n    .reduce((acc: AppointmentMoment[], resource: ValidResource) => {\n      const isGroupedByResource = grouping.find(\n        group => group.resourceName === resource.fieldName,\n      ) !== undefined;\n      if (!isGroupedByResource) return acc;\n      const resourceField = resource.fieldName;\n      if (!resource.allowMultiple) {\n        return acc.reduce((accumulatedAppointments, currentAppointment) => [\n          ...accumulatedAppointments,\n          { ...currentAppointment, [resourceField]: currentAppointment.dataItem[resourceField] },\n        ], [] as AppointmentMoment[]);\n      }\n      return acc.reduce((accumulatedAppointments, currentAppointment) => [\n        ...accumulatedAppointments,\n        ...currentAppointment.dataItem[resourceField].map(\n          (resourceValue: number | string) => ({\n            ...currentAppointment,\n            [resourceField]: resourceValue,\n            key: generateMultipleResourceKey(currentAppointment.key, resourceValue),\n          }),\n        ),\n      ], [] as AppointmentMoment[]);\n    }, [appointment] as AppointmentMoment[]);\n};\n\nconst generateMultipleResourceKey: PureComputed<\n  [AppointmentKey, number | string], AppointmentKey\n> = (previousKey, resourceValue) => `${previousKey}_${resourceValue}`;\n\nexport const getGroupingInfoFromGroups: PureComputed<\n  [Group[][], number], Group[]\n> = (groups, groupIndex) => {\n  let previousIndex = groupIndex;\n  return groups.reduceRight((acc, currentGroups, currentIndex) => {\n    if (currentIndex === groups.length - 1) return acc;\n    const previousResourceLength = groups[currentIndex + 1].length / currentGroups.length;\n    const currentGroupingInstance = currentGroups[Math.floor(\n      previousIndex / previousResourceLength,\n    )];\n    previousIndex = currentIndex;\n    return [...acc, currentGroupingInstance];\n  }, [getGroupsLastRow(groups)[groupIndex]]);\n};\n\nexport const getGroupsLastRow: PureComputed<\n  [Group[][]], Group[]\n> = groups => groups[groups.length - 1];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  Grouping, ValidResourceInstance, ViewCell, ValidResource,\n  Group, AppointmentMoment, ExpandGroupingPanelCellFn, GroupOrientation,\n  CellElementsMeta, SchedulerView,\n} from '../../types';\nimport {\n  getGroupFromResourceInstance, addGroupInfoToCells,\n  groupAppointments, expandGroupedAppointment, addGroupInfoToCell, getGroupsLastRow,\n} from './helpers';\nimport { sliceAppointmentsByDays } from '../all-day-panel/helpers';\nimport { HORIZONTAL_GROUP_ORIENTATION, VERTICAL_GROUP_ORIENTATION } from '../../constants';\nimport { containsDSTChange } from '../common/helpers';\n\nexport const filterResourcesByGrouping: PureComputed<\n  [Array<ValidResource>, Array<Grouping>], Array<ValidResource>\n> = (resources, grouping) => resources.filter(\n  resource => grouping.find(resourceId => resource.fieldName === resourceId.resourceName),\n);\n\nexport const sortFilteredResources: PureComputed<\n  [Array<ValidResource>, Array<Grouping>], Array<ValidResource>\n> = (resources, grouping) => grouping.map(({ resourceName }: Grouping) => (\n  resources.find(resource => resource.fieldName === resourceName) as ValidResource\n));\n\nexport const getGroupsFromResources: PureComputed<\n  [Array<ValidResource>], Array<Array<Group>>\n> = sortedAndFilteredResources => sortedAndFilteredResources.reduce((\n    acc: Array<Array<Group>>, resource: ValidResource, index: number,\n  ) => {\n  if (index === 0) {\n    return [resource.instances.map(instance => getGroupFromResourceInstance(instance))];\n  }\n\n  return [\n    ...acc,\n    acc[index - 1].reduce((currentResourceNames: Array<Group>) => [\n      ...currentResourceNames,\n      ...resource.instances.map(\n        (instance: ValidResourceInstance) => getGroupFromResourceInstance(instance),\n      ),\n    ], []),\n  ];\n}, []);\n\nexport const expandViewCellsDataWithGroups: PureComputed<\n  [ViewCell[][], Group[][], ValidResource[], boolean, GroupOrientation], ViewCell[][]\n> = (viewCellsData, groups, sortedResources, groupByDate, groupOrientation) => {\n  if (groups.length === 0) return viewCellsData;\n  if (groupByDate) {\n    return expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources);\n  }\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources);\n  }\n  return expandVerticallyGroupedCells(viewCellsData, groups, sortedResources);\n};\n\nconst expandCellsWithGroupedByDateData: ExpandGroupingPanelCellFn = (\n  viewCellsData, groups, sortedResources,\n) => viewCellsData.map(\n  (cellsRow: ViewCell[]) => cellsRow.reduce((acc: ViewCell[], viewCell: ViewCell) => {\n    const groupedCells = getGroupsLastRow(groups).map((\n      group: Group, index: number,\n    ) => addGroupInfoToCell(\n      group, groups, sortedResources, viewCell, index,\n      false, HORIZONTAL_GROUP_ORIENTATION,\n    ));\n    groupedCells[groupedCells.length - 1] = {\n      ...groupedCells[groupedCells.length - 1],\n      endOfGroup: true,\n    };\n    return [...acc, ...groupedCells] as ViewCell[];\n  }, [] as ViewCell[]),\n);\n\nconst expandHorizontallyGroupedCells: ExpandGroupingPanelCellFn = (\n  viewCellsData, groups, sortedResources,\n) => getGroupsLastRow(groups).reduce((\n  acc: ViewCell[][], group: Group, index: number,\n) => {\n  if (index === 0) {\n    return viewCellsData.map((viewCellsRow: ViewCell[]) =>\n      addGroupInfoToCells(\n        group, groups, sortedResources, viewCellsRow, index,\n        false, HORIZONTAL_GROUP_ORIENTATION,\n      ) as ViewCell[],\n    );\n  }\n  return acc.map((item: ViewCell[], id: number) => [\n    ...item,\n    ...addGroupInfoToCells(\n      group, groups, sortedResources, viewCellsData[id], index,\n      false, HORIZONTAL_GROUP_ORIENTATION,\n    ),\n  ]);\n}, [[]] as ViewCell[][]);\n\nconst expandVerticallyGroupedCells: ExpandGroupingPanelCellFn = (\n  viewCellsData, groups, sortedResources,\n) => getGroupsLastRow(groups).reduce((\n  acc: ViewCell[][], group: Group, index: number,\n) => {\n  if (index === 0) {\n    return viewCellsData.map((\n      viewCellsRow: ViewCell[], viewRowIndex: number,\n    ) => addGroupInfoToCells(\n        group, groups, sortedResources, viewCellsRow,\n        index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION,\n      ) as ViewCell[]);\n  }\n  return [\n    ...acc,\n    ...viewCellsData.map((viewCellsRow: ViewCell[], viewRowIndex: number) =>\n      addGroupInfoToCells(\n        group, groups, sortedResources, viewCellsRow,\n        index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION,\n      ) as ViewCell[],\n    ),\n  ];\n}, [[]] as ViewCell[][]);\n\nexport const updateGroupingWithMainResource: PureComputed<\n  [Grouping[] | undefined, ValidResource[]], Grouping[]\n> = (grouping, resources) => grouping\n  || [{ resourceName: resources.find(resource => resource.isMain)!.fieldName }];\n\nexport const expandGroups: PureComputed<\n  [AppointmentMoment[][], Grouping[], ValidResource[],\n  Group[][], number[], boolean], AppointmentMoment[][]\n> = (appointments, grouping, resources, groups, excludedDays, sliceByDay = false) => {\n  const slicedAppointments = sliceByDay ?\n    appointments[0].reduce((acc: AppointmentMoment[], appointment: AppointmentMoment) => ([\n      ...acc,\n      ...sliceAppointmentsByDays(appointment, excludedDays),\n    ]), [] as AppointmentMoment[]) : appointments[0];\n\n  const expandedAppointments = (slicedAppointments as AppointmentMoment[])\n    .reduce((acc: AppointmentMoment[], appointment: AppointmentMoment) => [\n      ...acc,\n      ...expandGroupedAppointment(appointment, grouping, resources),\n    ], [] as AppointmentMoment[]);\n  return groupAppointments(expandedAppointments, resources, groups);\n};\n\nexport const updateTimeTableCellElementsMeta: PureComputed<\n  [CellElementsMeta, (viewName: string) => GroupOrientation, Group[][],\n  boolean, ViewCell[][], SchedulerView], CellElementsMeta\n> = (\n  timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView,\n) => {\n  if (checkCellElementsMeta(\n    timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists,\n  )) {\n    return timeTableElementsMeta;\n  }\n\n  const {\n    groupCount, timeTableWidth, groupSize, validGetCellRects,\n  } = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups);\n  let allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(allDayPanelsLeft * (timeTableWidth + groupSize), timeTableWidth);\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects,\n  };\n};\n\nexport const updateAllDayCellElementsMeta: PureComputed<\n  [CellElementsMeta, CellElementsMeta, (viewName: string) => GroupOrientation, Group[][],\n  boolean, ViewCell[][], SchedulerView], CellElementsMeta\n> = (\n  allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups,\n  allDayPanelExists, viewCellsData, currentView,\n) => {\n  if (checkCellElementsMeta(\n    timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists,\n  )) {\n    return allDayElementsMeta;\n  }\n\n  const {\n    groupCount, timeTableWidth, groupSize, validGetCellRects,\n  } = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups);\n  let allDayPanelsLeft = groupCount;\n\n  while (allDayPanelsLeft > 0) {\n    allDayPanelsLeft -= 1;\n    validGetCellRects.splice(\n      groupSize * allDayPanelsLeft + timeTableWidth * (allDayPanelsLeft + 1), groupSize,\n    );\n  }\n\n  return {\n    parentRect: timeTableElementsMeta.parentRect,\n    getCellRects: validGetCellRects,\n  };\n};\n\nconst checkCellElementsMeta: PureComputed<\n  [CellElementsMeta, (viewName: string) => GroupOrientation, SchedulerView, boolean], boolean\n> = (\n  cellElementsMeta, groupOrientation, currentView, allDayPanelExists,\n) => groupOrientation(currentView.name) === HORIZONTAL_GROUP_ORIENTATION\n  || !allDayPanelExists || !cellElementsMeta.getCellRects;\n\nconst initializeCellElementsData: PureComputed<\n  [CellElementsMeta, ViewCell[][], Group[][]], any\n> = (cellElementsMeta, viewCellsData, groups) => {\n  const timeTableWidth = viewCellsData[0].length;\n  const groupCount = getGroupsLastRow(groups).length;\n  const groupHeight = viewCellsData.length / groupCount;\n  return {\n    groupCount,\n    timeTableWidth,\n    groupSize: timeTableWidth * groupHeight,\n    validGetCellRects: cellElementsMeta.getCellRects.slice(),\n  };\n};\n\nexport const updateTimeCellsData: PureComputed<\n  [ViewCell[][], ViewCell[][], Group[][], ValidResource[], GroupOrientation], ViewCell[][]\n> = (viewCellsData, timeCellsData, groups, sortedResources, groupOrientation) => {\n  const { startDate: firstViewDate } = viewCellsData[0][0];\n  if (!containsDSTChange(firstViewDate)) {\n    return viewCellsData;\n  }\n\n  if (groupOrientation !== VERTICAL_GROUP_ORIENTATION) {\n    return timeCellsData;\n  }\n\n  return expandVerticallyGroupedCells(timeCellsData, groups, sortedResources);\n};\n","import {\n  AllDayRects, VerticalRects, HorizontalRects,\n} from '../../types';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE,\n} from '../../constants';\nimport { calculateRectByDateAndGroupIntervals } from '../appointments/helpers';\nimport { calculateWeekDateIntervals } from '../week-view/computeds';\nimport { getVerticalRectByAppointmentData } from '../vertical-rect/helpers';\nimport { getHorizontalRectByAppointmentData } from '../horizontal-rect/helpers';\nimport { calculateMonthDateIntervals } from '../month-view/computeds';\nimport { calculateAllDayDateIntervals } from '../all-day-panel/computeds';\nimport { expandGroups } from '../integrated-grouping/computeds';\nimport { getGroupsLastRow } from '../integrated-grouping/helpers';\n\nexport const allDayRects: AllDayRects = (\n  appointments, startViewDate, endViewDate,\n  excludedDays, viewCellsData, cellElementsMeta,\n  grouping, resources, groups, groupOrientation, sliceAppointments,\n) => {\n  const intervals = calculateAllDayDateIntervals(\n    appointments, startViewDate, endViewDate, excludedDays,\n  );\n  const groupedIntervals = expandGroups(\n    intervals, grouping, resources, groups, excludedDays, sliceAppointments,\n  );\n\n  return calculateRectByDateAndGroupIntervals(\n    {\n      growDirection: HORIZONTAL_TYPE,\n      multiline: false,\n    },\n    groupedIntervals,\n    getHorizontalRectByAppointmentData,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellElementsMeta,\n      excludedDays,\n    },\n    {\n      groupOrientation,\n      groupedByDate: sliceAppointments,\n      groupCount: groups ? getGroupsLastRow(groups).length : 1,\n    },\n  );\n};\n\nexport const verticalTimeTableRects: VerticalRects = (\n  appointments, startViewDate, endViewDate, excludedDays, viewCellsData,\n  cellDuration, cellElementsMeta, grouping, resources, groups,  groupOrientation, groupByDate,\n) => {\n  const intervals = calculateWeekDateIntervals(\n    appointments, startViewDate, endViewDate, excludedDays, cellDuration,\n  );\n  const groupedIntervals = expandGroups(\n    intervals, grouping, resources, groups, excludedDays, false,\n  );\n\n  return calculateRectByDateAndGroupIntervals(\n    {\n      growDirection: VERTICAL_TYPE,\n      multiline: false,\n    },\n    groupedIntervals,\n    getVerticalRectByAppointmentData,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n    },\n    {\n      groupOrientation,\n      groupedByDate: groupByDate,\n      groupCount: groups ? getGroupsLastRow(groups).length : 1,\n    },\n  );\n};\n\nexport const horizontalTimeTableRects: HorizontalRects = (\n  appointments, startViewDate, endViewDate, viewCellsData,\n  cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments,\n) => {\n  const intervals = calculateMonthDateIntervals(\n    appointments, startViewDate, endViewDate,\n  );\n  const groupedIntervals = expandGroups(\n    intervals, grouping, resources, groups, [], sliceAppointments,\n  );\n\n  return calculateRectByDateAndGroupIntervals(\n    {\n      growDirection: HORIZONTAL_TYPE,\n      multiline: true,\n    },\n    groupedIntervals,\n    getHorizontalRectByAppointmentData,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellElementsMeta,\n    },\n    {\n      groupOrientation,\n      groupedByDate: sliceAppointments,\n      groupCount: groups ? getGroupsLastRow(groups).length : 1,\n    },\n  );\n};\n","import { DateTimeFormatInstanceFn } from '../../types';\n\nexport const dateTimeFormatInstance: DateTimeFormatInstanceFn = (\n  locale, formatOptions,\n) => new Intl.DateTimeFormat(locale, formatOptions);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { AppointmentModel, Appointment, FormatDateTimeGetterFn, FormatterFn } from '../../types';\nimport { convertToMoment } from '../common/helpers';\nimport { dateTimeFormatInstance } from './helpers';\n\nexport const appointments: PureComputed<\n  [AppointmentModel[]], Appointment[]\n> = data => data.map((appointment, index) => ({\n  dataItem: appointment,\n  start: appointment.startDate,\n  ...appointment.endDate !== undefined ? {\n    end: appointment.endDate,\n  } : {\n    end: appointment.startDate,\n    dataItem: { ...appointment, endDate: appointment.startDate },\n  },\n  ...appointment.allDay !== undefined && {\n    allDay: appointment.allDay,\n  },\n  ...appointment.rRule !== undefined && {\n    rRule: appointment.rRule,\n  },\n  ...appointment.exDate !== undefined && {\n    exDate: appointment.exDate,\n  },\n  key: appointment.id || index,\n}));\n\nexport const formatDateTimeGetter: FormatDateTimeGetterFn = (locale) => {\n  const cache = new Map<Intl.DateTimeFormatOptions, Intl.DateTimeFormat>(); // any -> type\n\n  const formatter: FormatterFn = (nextDate, nextOptions) => {\n    if (nextDate === undefined) return '';\n    const date = convertToMoment(nextDate).toDate();\n    let formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n  return formatter;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Group, HorizontalGroupingCellData, VerticalGroupingCellData } from '../../types';\nimport { getGroupsLastRow } from '../integrated-grouping/helpers';\n\nexport const getCellKey: PureComputed<\n  [Group[][], number, number], string\n> = (groups, groupIndex, rowNumber) => {\n  let currentIndex = groupIndex;\n  return groups.reduceRight((acc: string, groupRow: Group[], rowIndex: number) => {\n    if (rowNumber < rowIndex) return acc;\n    const currentKey = groupRow[currentIndex].id;\n    if (rowIndex > 0) {\n      const currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;\n      currentIndex = Math.floor(currentIndex / currentRowLength);\n    }\n    return acc + currentKey;\n  }, '' as string);\n};\n\nexport const getRowFromGroups: PureComputed<\n  [number, Group[], any, Group[][], number], HorizontalGroupingCellData[]\n> = (width, groupRow, cellStyle, groups, rowIndex) => {\n  let row = [] as any[];\n  const currentRowLength = groupRow.length;\n  const standardWidth = width / getGroupsLastRow(groups).length;\n  const colSpan = getGroupsLastRow(groups).length / currentRowLength;\n  for (let i = 0; i < standardWidth; i += 1) {\n    row = [...row, ...groupRow.reduce((acc, group, index) => [\n      ...acc,\n      {\n        group,\n        colSpan,\n        key: getCellKey(groups, index, rowIndex) + i,\n        left: cellStyle.left,\n        endOfGroup: index === currentRowLength - 1,\n      },\n    ], [] as any[])];\n  }\n  return row;\n};\n\nexport const getVerticalRowFromGroups: PureComputed<\n  [Group[][], number, number, number, boolean, number], VerticalGroupingCellData[]\n> = (\n  groups, groupIndex, groupingPanelRowSpan,\n  timeTableCellHeight, addAllDayHeight, allDayCellHeight,\n) => groups.reduce((\n  acc, groupColumn, columnIndex,\n) => {\n  const groupSpan = getGroupsLastRow(groups).length / groupColumn.length;\n  const cellIndex = groupIndex / groupSpan;\n  const baseHeight = (groupingPanelRowSpan * groupSpan * timeTableCellHeight)\n    / getGroupsLastRow(groups).length;\n  const allDayHeight = groupSpan * allDayCellHeight;\n\n  return groupIndex % groupSpan !== 0 ? acc : [\n    ...acc,\n    {\n      group: groupColumn[cellIndex],\n      rowSpan: groupSpan,\n      height: addAllDayHeight ? baseHeight + allDayHeight : baseHeight,\n      key: getCellKey(groups, cellIndex, columnIndex),\n    },\n  ];\n}, [] as VerticalGroupingCellData[]);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { HORIZONTAL_GROUP_ORIENTATION } from '../../constants';\nimport { ViewCell, Group, GroupOrientation, TimeScaleLabelData, AllDayCell } from '../../types';\nimport { getCellKey } from '../grouping-panel/utils';\nimport { getGroupsLastRow } from '../integrated-grouping/helpers';\n\nconst getLabelsForSingleGroup: PureComputed<\n  [Group[][], ViewCell[][], number, number], TimeScaleLabelData[]\n> = (groups, cellsData, groupIndex, groupHeight) => {\n  const currentGroupIndex = groupIndex * groupHeight;\n  const nextGroupIndex = currentGroupIndex + groupHeight;\n\n  return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce((\n    acc: TimeScaleLabelData[], days: ViewCell[],\n  ) => (([\n    ...acc,\n    {\n      startDate: days[0].startDate,\n      endDate: days[0].endDate,\n      key: days[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),\n      groupingInfo: days[0].groupingInfo,\n    },\n  ])), [] as TimeScaleLabelData[]);\n};\n\nexport const getLabelsForAllGroups: PureComputed<\n  [ViewCell[][], Group[][], GroupOrientation], TimeScaleLabelData[][]\n> = (cellsData, groups, groupOrientation) => {\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return [cellsData.map(cellsRow => ({\n      startDate: cellsRow[0].startDate,\n      endDate: cellsRow[0].endDate,\n      groupingInfo: cellsRow[0].groupingInfo,\n      key: cellsRow[0].endDate,\n    }))];\n  }\n\n  const groupCount = getGroupsLastRow(groups).length;\n  const singleGroupHeight = cellsData.length / groupCount;\n\n  return getGroupsLastRow(groups).reduce((\n    acc: TimeScaleLabelData[][], group: Group, groupIndex: number,\n  ) => [\n    ...acc,\n    getLabelsForSingleGroup(\n      groups, cellsData, groupIndex, singleGroupHeight,\n    ) as TimeScaleLabelData[],\n  ], [] as TimeScaleLabelData[][]);\n};\n\nexport const prepareVerticalViewCellsData: PureComputed<\n  [ViewCell[][], AllDayCell[][]], ViewCell[][][]\n> = (cellsData, allDayCellsData) => {\n  const groupCount = allDayCellsData?.length || 1;\n  const validCellsData = [] as ViewCell[][][];\n  const groupHeight = cellsData.length / groupCount;\n  for (let i = 0; i < groupCount; i += 1) {\n    validCellsData.push(cellsData.slice(i * groupHeight, (i + 1) * groupHeight));\n  }\n  return validCellsData;\n};\n","import moment from 'moment';\nimport { PureReducer } from '@devexpress/dx-core';\nimport { ChangeCurrentDatePayload } from '../../types';\n\nexport const changeCurrentDate: PureReducer<Date, ChangeCurrentDatePayload> = (\n  currentDate, {\n  nextDate, step, amount, direction,\n}) => (\n  nextDate\n  || moment(currentDate as Date)[direction === 'back' ? 'subtract' : 'add'](amount, step)\n    .toDate()\n  || moment().subtract(amount, step)\n);\n\nexport const setCurrentViewName: PureReducer<\n  string, string, string\n> = (currentViewName, nextViewName) => nextViewName;\n","import { PureReducer } from '@devexpress/dx-core';\nimport { AppointmentMeta } from '../../types';\n\nexport const setAppointmentMeta: PureReducer<AppointmentMeta, AppointmentMeta> = (\n  prevAppointmentMeta,\n  { target, data },\n) => ({ target, data });\n","export const OPEN_COMMAND_BUTTON = 'open';\nexport const CLOSE_COMMAND_BUTTON = 'close';\nexport const DELETE_COMMAND_BUTTON = 'delete';\nexport const CANCEL_COMMAND_BUTTON = 'cancel';\nexport const COMMIT_COMMAND_BUTTON = 'commit';\n","import { PureReducer } from '@devexpress/dx-core';\nimport { AppointmentModel, AppointmentDataPayload } from '../../types';\n\nexport const setAppointmentData: PureReducer<\n  AppointmentModel, AppointmentDataPayload\n> = (prevAppointmentData, { appointmentData }) => appointmentData;\n","import {\n  LONG_WEEK_DAY_OPTIONS, DAY_LONG_MONTH_OPTIONS,\n  LONG_MONTH_OPTIONS,\n} from '@devexpress/dx-scheduler-core';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  SelectOption, OptionsFormatterFn, DateFormatterFn, RecurrenceFrequency,\n} from '../../types';\nimport {\n  MONTHS_DATES, REPEAT_TYPES_ARRAY, WEEK_NUMBER_LABELS, DAYS_IN_WEEK, RRULE_REPEAT_TYPES,\n  BASIC_YEALY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_DAILY_COUNT,\n} from './constants';\nimport { getDaysOfWeekDates, getDaysOfWeekArray } from './helpers';\n\nexport const getWeekNumberLabels: OptionsFormatterFn = getMessage =>\n  WEEK_NUMBER_LABELS.map((weekNumberLabel, index) => ({\n    text: getMessage(weekNumberLabel),\n    id: index,\n  }));\n\nexport const getDaysOfWeek: PureComputed<\n  [(date: Date, formatOptions: object) => string, number], Array<SelectOption>\n> = (formatDate, firstDayOfWeek) => {\n  const daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  const daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(\n    (day, index) => ({\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0],\n    }),\n  );\n};\n\nexport const getMonths: DateFormatterFn = formatDate => MONTHS_DATES.map((month, index) => ({\n  text: getMonth(month, formatDate),\n  id: getMonthId(index),\n}));\n\nexport const getMonthsWithOf: PureComputed<\n  [(messageKey: string) => string, (date: Date, formatOptions: object) => string],\n    Array<SelectOption>\n> = (getMessage, formatDate) => MONTHS_DATES.map((month, index) => ({\n  text: getMonthWithOf(month, getMessage, formatDate),\n  id: getMonthId(index),\n}));\n\nconst getMonthWithOf = (\n  date: Date,\n  getMessage: (messageKey: string) => string,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => getMessage('ofLabel')\n  + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n\nconst getMonth = (\n  date: Date,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => formatDate(date, LONG_MONTH_OPTIONS);\n\nconst getDayOfWeek = (\n  date: Date,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => formatDate(date, LONG_WEEK_DAY_OPTIONS);\n\nconst getMonthId: PureComputed<\n  [number], number\n> = index => index + 1;\n\nexport const getAvailableRecurrenceOptions: OptionsFormatterFn = getMessage =>\n  REPEAT_TYPES_ARRAY.map(type => ({\n    text: getMessage(type),\n    id: type,\n  }));\n\nexport const getCountDependingOnRecurrenceType = (frequency: RecurrenceFrequency) => {\n  let count;\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n  return count;\n};\n\nexport const checkIsNaturalNumber: PureComputed<\n  [number], boolean\n> = number => number > 0 && number <= Number.MAX_SAFE_INTEGER;\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { RRule, Options, Weekday } from 'rrule';\nimport {\n  Action,\n  StartDate,\n  EndDate,\n  RadioGroupDisplayData,\n  ValidResource,\n} from '../../types';\nimport {\n  DEFAULT_RULE_OBJECT, RRULE_REPEAT_TYPES, REPEAT_TYPES, LAST_WEEK,\n  DAYS_OF_WEEK_ARRAY, DAYS_IN_WEEK, DAYS_OF_WEEK_DATES, RRULE_DAYS_OF_WEEK,\n} from './constants';\nimport { getCountDependingOnRecurrenceType } from './utils';\n\nexport const callActionIfExists: PureComputed<[Action, object], void> = (action, payload) => {\n  if (action) {\n    action(payload);\n  }\n};\n\nexport const isAllDayCell: PureComputed<\n  [StartDate, EndDate], boolean\n> = (\n  startDate, endDate,\n) => moment(endDate as EndDate).diff(moment(startDate as StartDate), 'days') >= 1;\n\nexport const changeRecurrenceFrequency: PureComputed<\n  [string, number, Date], string\n> = (\n  rule, freq, startDate,\n) => {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return (new RRule({\n        ...DEFAULT_RULE_OBJECT,\n        freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq),\n      })).toString();\n    }\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return (new RRule({\n        ...DEFAULT_RULE_OBJECT,\n        freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq),\n      })).toString();\n    }\n    return (new RRule({\n      ...DEFAULT_RULE_OBJECT, freq, count: getCountDependingOnRecurrenceType(freq),\n    })).toString();\n  }\n\n  const options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n  options.byweekday = undefined;\n  const nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nexport const getRecurrenceOptions: PureComputed<\n  [string | undefined], Partial<Options> | null\n> = rule => !rule ? null : RRule.parseString(rule);\n\nexport const changeRecurrenceOptions = (options: Partial<Options>) => {\n  return options ? (new RRule({ ...options })).toString() : undefined;\n};\n\nexport const handleStartDateChange = (nextStartDay: number, options: Partial<Options>) => {\n  if (nextStartDay <= 31) {\n    const nextOptions = { ...options, bymonthday: nextStartDay };\n    return changeRecurrenceOptions(nextOptions);\n  }\n  return changeRecurrenceOptions(options);\n};\n\nexport const handleToDayOfWeekChange = (\n  weekNumber: number, dayOfWeek: number, options: Partial<Options>,\n) => {\n  const validDayOfWeek = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  const validWeekNumber = weekNumber === 4 ? -1 : weekNumber + 1;\n  const rruleDayOfWeek = RRULE_DAYS_OF_WEEK[validDayOfWeek];\n\n  const nextOptions = {\n    ...options,\n    byweekday: [rruleDayOfWeek.nth(validWeekNumber)],\n    bymonthday: undefined,\n  };\n\n  return changeRecurrenceOptions(nextOptions);\n};\n\nexport const getRRuleFrequency: PureComputed<\n  [string], number\n> = repeatType => RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n\nexport const getFrequencyString: PureComputed<\n  [number], string\n> = (rRuleFrequency) => {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nexport const getRadioGroupDisplayData: PureComputed<\n  [Partial<Options>, number, number, number, string, string], RadioGroupDisplayData\n> = (\n  recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption,\n) => {\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: (recurrenceOptions.bymonthday as number),\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption,\n    };\n  }\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber,\n    };\n  }\n  const dayOfWeek = recurrenceOptions.byweekday[0].weekday < 6\n    ? recurrenceOptions.byweekday[0].weekday + 1 : 0;\n  const weekNumber = recurrenceOptions.byweekday[0].n === -1\n    ? LAST_WEEK\n    : recurrenceOptions.byweekday[0].n - 1;\n\n  return {\n    dayOfWeek,\n    weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber,\n  };\n};\n\nexport const handleChangeFrequency: PureComputed<\n  [string, string, Date, Action], void\n> = (repeatType, rRule, startDate, action) => {\n  const rruleRepeatType = getRRuleFrequency(repeatType);\n  let nextRRule;\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(\n      rRule,\n      rruleRepeatType,\n      startDate,\n    );\n  }\n  action({ rRule: nextRRule });\n};\n\nexport const handleWeekDaysChange: PureComputed<\n[Partial<Options>, number], void\n> = (options, currentWeekDay) => {\n  const byWeekDay = options.byweekday || [];\n  const index = (byWeekDay as Weekday[]).findIndex(({ weekday }) => weekday === currentWeekDay);\n\n  const isAdded = index === -1;\n\n  if (isAdded) {\n    (byWeekDay as Weekday[]).push(RRULE_DAYS_OF_WEEK[currentWeekDay]);\n  } else if (index > -1) {\n    (byWeekDay as Weekday[]).splice(index, 1);\n  }\n  if (byWeekDay === 0) return { ...options, byweekday: undefined };\n  return { ...options, byweekday: byWeekDay };\n};\n\nexport const getDaysOfWeekArray: PureComputed<[number], Array<number>> = (firstDayOfWeek) => {\n  const firstPart = DAYS_OF_WEEK_ARRAY.filter(\n    dayOfWeek => dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1,\n  );\n  const secondPart = DAYS_OF_WEEK_ARRAY.filter(\n    dayOfWeek => dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1,\n  );\n  return firstDayOfWeek !== 0 ? [...firstPart, ...secondPart] : [...secondPart, ...firstPart];\n};\n\nexport const getDaysOfWeekDates: PureComputed<[number], Array<Date>> = (firstDayOfWeek) => {\n  const firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  const secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return [...firstPart, ...secondPart];\n};\n\nexport const checkMultipleResourceFields: PureComputed<\n  [object, ValidResource[]], object\n> = (resourceFields, resources) => resources.reduce((acc, resource) => {\n  if (!resource.allowMultiple) {\n    return acc;\n  }\n\n  const fieldName = resource.fieldName;\n  const field = resourceFields[fieldName];\n  return {\n    ...acc,\n    [fieldName]: Array.isArray(field) ? field : [field],\n  };\n}, resourceFields);\n","import { PureReducer } from '@devexpress/dx-core';\nimport {\n  AddedAppointmentDataPayload, AppointmentModel, Changes, EditAppointmentPayload,\n} from '../../types';\n\nexport const addAppointment: PureReducer<\n  AppointmentModel, AddedAppointmentDataPayload, AppointmentModel | {}\n> = (\n  addedAppointmentData, { appointmentData } = { appointmentData:  {} },\n) => appointmentData;\n\nexport const cancelAddedAppointment = () => ({});\n\nexport const startEditAppointment: PureReducer<\n  Partial<AppointmentModel>, EditAppointmentPayload\n> = (prevEditingAppointment, appointmentData) => appointmentData;\n\nexport const stopEditAppointment = () => undefined;\n\nexport const changeAppointment: PureReducer<\nAppointmentModel, Changes\n> = (\n  appointment, { change },\n) => ({ ...appointment, ...change });\n\nexport const cancelChanges = () => ({});\n","import { PureComputed } from '@devexpress/dx-core';\nimport { AppointmentId, AppointmentChanges, Changes } from '../../types';\n\nexport const changedAppointmentById: PureComputed<\n  [Changes, AppointmentId], AppointmentChanges\n> = (changes, appointmentId) => (\n  { [appointmentId]: changes }\n);\n","import moment from 'moment';\nimport { RRule, RRuleSet } from 'rrule';\nimport {\n  AppointmentModel, PreCommitChangesFn, Changes, MakeDateSequenceFn, EditFn, DeleteFn, ChangeFn,\n} from '../../types';\nimport { RECURRENCE_EDIT_SCOPE } from '../../constants';\nimport { getUTCDate, getRRuleSetWithExDates, formatDateToString } from '../../utils';\n\nconst mergeNewChanges = (\n  appointmentData: Partial<AppointmentModel>, changes: Changes,\n) => {\n  const appointment = {\n    ...appointmentData,\n  };\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return { ...appointment, ...changes };\n};\n\nconst reduceExDate = (prevExDate: string, boundDate: Date) => {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce((acc: string[], date: string) => {\n      const momentDate = moment.utc(date);\n      if (momentDate.isBefore(boundDate)) {\n        return [...acc, date];\n      }\n      return acc;\n    }, []).join(',');\n  }\n  return undefined;\n};\n\nconst configureExDate = (exDate: string | undefined, date: Date) => {\n  const currentExDate = `${moment.utc(date).format('YYYYMMDDTHHmmss')}Z`;\n  return exDate\n    ? `${exDate},${currentExDate}`\n    : currentExDate;\n};\n\nconst configureDateSequence: MakeDateSequenceFn = (rRule, exDate, prevStartDate, nextStartDate) => {\n  const rruleSet = getRRuleSetWithExDates(exDate);\n\n  const currentOptions = RRule.parseString(rRule as string);\n  const correctedOptions = currentOptions.until\n    ? { ...currentOptions, until: moment(getUTCDate(currentOptions.until)).toDate() }\n    : currentOptions;\n  const prevStartDateUTC = moment(getUTCDate(prevStartDate!)).toDate();\n  rruleSet.rrule(new RRule({\n    ...correctedOptions,\n    dtstart: prevStartDateUTC,\n  }));\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all()\n      // we shouldn't use `new Date(string)` because this function has different results in Safari\n      .map(nextDate => moment(formatDateToString(nextDate)).toDate());\n  }\n  const leftBound = prevStartDateUTC;\n  const rightBound = moment(getUTCDate(nextStartDate!)).toDate();\n  return rruleSet.between(leftBound, rightBound, true)\n    .map(nextDate => moment(formatDateToString(nextDate)).toDate());\n};\n\nconst configureICalendarRules = (rRule: string | undefined, options: object) => {\n  const rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule({\n    ...RRule.parseString(rRule as string),\n    ...options,\n  }));\n  return rruleSet.valueOf();\n};\n\nconst changeCurrentAndFollowing: ChangeFn = (appointmentData, changes, changeAllAction) => {\n  const { rRule, startDate, parentData, exDate: prevExDate = '', id } = appointmentData;\n\n  const { initialSequence, currentChildIndex } = getAppointmentSequenceData(\n    parentData.startDate, moment.utc(startDate as Date).toDate(), prevExDate, rRule,\n  );\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n\n  const changedRules = configureICalendarRules(rRule as string, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null,\n  });\n\n  const nextExDate = reduceExDate(prevExDate, startDate as Date);\n  return {\n    changed: {\n      [id!]: {\n        rRule: changedRules[1].slice(6),\n        ...nextExDate && prevExDate !== nextExDate ? { exDate: nextExDate } : {},\n      },\n    },\n  };\n};\n\nconst getAppointmentSequenceData = (\n  prevStartDate: Date, startDate: Date, exDate: string, rRule: string | undefined,\n) => {\n  const initialSequence: Date[] = configureDateSequence(rRule, exDate,\n    moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate(),\n  );\n  const currentChildIndex = initialSequence\n    .findIndex(date => moment(date).isSame(startDate as Date));\n  return { initialSequence, currentChildIndex };\n};\n\nexport const deleteCurrent: DeleteFn = (appointmentData) => {\n  const currentSequence: Date[] = configureDateSequence(\n    appointmentData.rRule, appointmentData.exDate,\n    moment.utc(appointmentData.parentData.startDate).toDate(),\n    moment.utc(appointmentData.startDate).toDate(),\n  );\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  const nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate as Date);\n  return { changed: { [appointmentData.id!]: { exDate: nextExDate } } };\n};\n\nexport const deleteAll: DeleteFn = (appointmentData) => {\n  return { deleted: appointmentData.id };\n};\n\nexport const deleteCurrentAndFollowing: DeleteFn = appointmentData => changeCurrentAndFollowing(\n  appointmentData, {}, deleteAll,\n);\n\nexport const editAll: EditFn = (appointmentData, changes) => {\n  const { rRule, id } = appointmentData;\n\n  const initialRule = new RRule(RRule.parseString(rRule as string));\n  if (changes.startDate\n    && moment.utc(changes.startDate as Date).isAfter(initialRule.options.until!)) {\n    return {\n      changed: {\n        [id!]: {\n          ...changes,\n          rRule: 'FREQ=DAILY;COUNT=1',\n          exDate: '',\n        },\n      },\n    };\n  }\n\n  return  { changed: {  [appointmentData.id!]: changes } };\n};\n\nexport const editCurrent: EditFn = (appointmentData, changes) => ({\n  changed: {\n    [appointmentData.id!]: {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate as Date),\n    },\n  },\n  added: mergeNewChanges(appointmentData as Partial<AppointmentModel>, changes as Changes),\n});\n\nexport const editCurrentAndFollowing: EditFn = (appointmentData, changes) => {\n  const { rRule, startDate, exDate: prevExDate = '', parentData } = appointmentData;\n  const initialRule = new RRule(RRule.parseString(rRule as string));\n\n  const { initialSequence, currentChildIndex } = getAppointmentSequenceData(\n    parentData.startDate, moment.utc(startDate as Date).toDate(),  prevExDate, rRule,\n  );\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n\n  const addedOptions = initialRule.options.count || initialRule.options.until\n    ? { count: initialSequence.length - currentChildIndex }\n    : {};\n  const addedRules = configureICalendarRules(appointmentData.rRule as string, {\n    dtstart: moment.utc(startDate as Date).toDate(),\n    ...addedOptions,\n  });\n\n  const addedAppointment = moment.utc(changes.startDate as Date).isAfter(initialRule.options.until!)\n    ? { rRule: 'FREQ=DAILY;COUNT=1', exDate: '' } : { rRule: addedRules[1].slice(6) };\n\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: {\n      ...addedAppointment, ...mergeNewChanges(appointmentData, changes),\n    },\n  };\n};\n\nexport const preCommitChanges: PreCommitChangesFn = (\n  changes, appointmentData, editType,\n) => {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL: {\n        return deleteAll(appointmentData);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT: {\n        return deleteCurrent(appointmentData);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {\n        return deleteCurrentAndFollowing(appointmentData);\n      }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL: {\n        return editAll(appointmentData, changes);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT: {\n        return editCurrent(appointmentData, changes);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {\n        return editCurrentAndFollowing(appointmentData, changes);\n      }\n    }\n  }\n  return {};\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  ViewCell, ClientOffset, TimeType, ScrollingStrategy,\n  AllDayCell, CalculateAppointmentTimeBoundaries,\n  TimeBoundariesByDrag, TimeBoundariesByResize, AppointmentModel,\n  CellElementsMeta, Grouping, ValidResource, Group, SchedulerDateTime, GroupOrientation,\n} from '../../types';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE, SCROLL_OFFSET, MINUTES,\n  SECONDS, RESIZE_TOP, RESIZE_BOTTOM, HOURS,\n} from '../../constants';\nimport {\n  allDayRects, horizontalTimeTableRects, verticalTimeTableRects,\n} from '../common/calculate-rects';\n\nconst clamp: PureComputed<\n  [number, number, number]\n> = (value, min, max) => Math.max(Math.min(value, max), min);\n\nconst calculateInsideOffset: PureComputed<\n  [string, number, number], number\n> = (targetType, insidePart, cellDurationMinutes) => targetType === VERTICAL_TYPE\n  ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n\nexport const cellType: PureComputed<\n  [ViewCell | AllDayCell], string\n> = data => moment(data.startDate as Date)\n  .isSame(data.endDate as Date, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n\nexport const intervalDuration: PureComputed<\n  [ViewCell | AllDayCell, TimeType], number\n> = (data, type) => moment(data.endDate as Date).diff(data.startDate as Date, type);\n\nexport const cellIndex: PureComputed<\n  [Array<() => ClientRect>, ClientOffset], number\n> = (getCellRects, clientOffset) => getCellRects.findIndex((getCellRect) => {\n  const { left, top, right, bottom } = getCellRect();\n  const isOver = clientOffset\n      && clamp(clientOffset.x, left, right) === clientOffset.x\n      && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n  return isOver;\n});\n\nexport const cellData: PureComputed<\n  [number, number, ViewCell[][], ViewCell[][]], ViewCell | AllDayCell\n> = (timeTableIndex, allDayIndex, viewCellsData, allDayCellsData) => {\n  const cellsData = allDayIndex !== -1 ? allDayCellsData : viewCellsData;\n  const currentIndex = allDayIndex !== -1 ? allDayIndex : timeTableIndex;\n  const tableWidth = cellsData[0].length;\n\n  const rowIndex = Math.floor(currentIndex / tableWidth);\n  const columnIndex = currentIndex % tableWidth;\n  return cellsData[rowIndex][columnIndex];\n};\n\nexport const autoScroll: PureComputed<\n  [ClientOffset, ScrollingStrategy, number], void\n> = (clientOffset, scrollingStrategy, scrollSpeed) => {\n  scroll(\n    clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary,\n    scrollingStrategy.changeVerticalScroll, scrollSpeed,\n  );\n  scroll(\n    clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary,\n    scrollingStrategy.changeHorizontalScroll, scrollSpeed,\n  );\n};\n\nconst scroll: PureComputed<\n  [number, number, number, (value: number) => void, number], void\n> = (offset, firstBoundary, secondBoundary, changeScroll, scrollSpeed) => {\n  if ((offset < firstBoundary + SCROLL_OFFSET) && (offset > firstBoundary)) {\n    changeScroll(-scrollSpeed);\n  }\n  if (secondBoundary - SCROLL_OFFSET < offset) {\n    changeScroll(+scrollSpeed);\n  }\n};\n\nexport const timeBoundariesByResize: TimeBoundariesByResize = (\n  payload, targetData, targetType, cellDurationMinutes, insidePart,\n) => {\n  if (targetType !== payload.appointmentType) {\n    return { appointmentStartTime: undefined, appointmentEndTime: undefined };\n  }\n\n  let appointmentStartTime;\n  let appointmentEndTime;\n  const sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    const insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate as Date)\n      .add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate as Date).toDate();\n  }\n  if (sourceType === RESIZE_BOTTOM) {\n    const insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE\n      ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate as Date)\n      .add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate as Date).toDate();\n  }\n  // keep origin appointment duration if coordinates are wrong\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate as Date).toDate();\n    appointmentEndTime = moment(payload.endDate as Date).toDate();\n  }\n  return { appointmentStartTime, appointmentEndTime };\n};\n\nexport const timeBoundariesByDrag: TimeBoundariesByDrag = (\n  payload, targetData, targetType,\n  cellDurationMinutes, insidePart, offsetTimeTopBase,\n) => {\n  if (targetType === HORIZONTAL_TYPE\n    && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate as Date,\n      appointmentEndTime: targetData.endDate as Date,\n      offsetTimeTop: 0,\n    };\n  }\n  let offsetTimeTop;\n  let appointmentStartTime;\n  let appointmentEndTime;\n\n  const insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  const start = moment(targetData.startDate as Date).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate as Date)\n      .diff(payload.startDate as Date, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    const appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add((offsetTimeTop) * (-1), SECONDS).toDate();\n    appointmentEndTime = moment(start)\n      .add((appointmentDurationSeconds - offsetTimeTop), SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate as Date)\n      .add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate as Date).add(insideOffset, SECONDS).toDate();\n  }\n\n  return { appointmentStartTime, appointmentEndTime, offsetTimeTop };\n};\n\nexport const calculateAppointmentTimeBoundaries: CalculateAppointmentTimeBoundaries = (\n  payload, targetData, targetType,\n  cellDurationMinutes, insidePart, offsetTimeTopBase,\n) => {\n  const isDragging = (payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE);\n\n  return(isDragging\n    ? timeBoundariesByDrag(\n        payload, targetData as AppointmentModel, targetType,\n        cellDurationMinutes, insidePart, offsetTimeTopBase,\n      )\n    : timeBoundariesByResize(\n        payload, targetData as AppointmentModel, targetType, cellDurationMinutes, insidePart,\n      )\n  );\n};\n\nexport const calculateInsidePart: PureComputed<\n  [number, Array<() => ClientRect>, number]\n> = (top, timeTableCellsRects, timeTableIndex) => {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    const cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n  return 0;\n};\n\nexport const calculateDraftAppointments = (\n  allDayIndex: number, draftAppointments: any, startViewDate: Date,\n  endViewDate: Date, excludedDays: number[], viewCellsData: any,\n  getAllDayCellsElementRects: CellElementsMeta,\n  targetType: string, cellDurationMinutes: number,\n  getTableCellElementRects: CellElementsMeta,\n  grouping: Grouping[], resources: ValidResource[], groups: Group[][],\n  groupOrientation: GroupOrientation, groupedByDate: boolean,\n) => {\n  if (allDayIndex !== -1 || (targetType === VERTICAL_TYPE\n    && getAllDayCellsElementRects.getCellRects.length\n    && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23)) {\n    const allDayDrafts = draftAppointments.map((draftAppt: any) => ({\n      ...draftAppt,\n      allDay: true,\n    }));\n\n    return {\n      allDayDraftAppointments: allDayRects(\n        allDayDrafts, startViewDate, endViewDate,\n        excludedDays, viewCellsData, getAllDayCellsElementRects,\n        grouping, resources, groups, groupOrientation, groupedByDate,\n      ),\n      timeTableDraftAppointments: [],\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(\n        draftAppointments, startViewDate, endViewDate,\n        excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects,\n        grouping, resources, groups, groupOrientation, groupedByDate,\n      ),\n    };\n  }\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(\n      draftAppointments, startViewDate, endViewDate,\n      viewCellsData, getTableCellElementRects,\n      grouping, resources, groups, groupOrientation, groupedByDate,\n    ),\n  };\n};\n\nexport const calculateAppointmentGroups: PureComputed<\n  [Array<Group> | undefined, Array<ValidResource>, AppointmentModel], any\n> = (cellGroupingInfo, resources, appointmentData) => {\n  if (!cellGroupingInfo) return {};\n  return cellGroupingInfo.reduce((acc, group: Group) => {\n    const isMultipleResource = resources.find(\n      resource => (resource.fieldName === group.fieldName),\n    )!.allowMultiple;\n    return {\n      ...acc,\n      [group.fieldName]: isMultipleResource\n        ? updateMultipleResourceInfo(group, appointmentData) : group.id,\n    };\n  }, {});\n};\n\nconst updateMultipleResourceInfo: PureComputed<\n  [Group, AppointmentModel], any\n> = (cellResource, appointmentData) => {\n  const appointmentGroupItems = appointmentData[cellResource.fieldName];\n  if (appointmentGroupItems.findIndex((groupItem: any) => groupItem === cellResource.id) !== -1) {\n    return appointmentGroupItems;\n  }\n  return [cellResource.id];\n};\n\nexport const appointmentDragged: PureComputed<\n  [SchedulerDateTime, SchedulerDateTime, SchedulerDateTime, SchedulerDateTime, any, any], boolean\n> = (start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) => {\n  if (moment(start as Date).isSame(startPrev as Date)\n      && moment(end as Date).isSame(endPrev as Date)\n      && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {\n    return false;\n  }\n  return true;\n};\n\nconst groupingInfoNotChanged: PureComputed<\n  [any, any], boolean\n> = (groupingInfo, groupingInfoPrev) => {\n  const fields = Object.getOwnPropertyNames(groupingInfo);\n  return fields.every((field) => {\n    if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {\n      return groupingInfo[field].every((item: any, index: number) => (\n        item === groupingInfoPrev[field][index]\n      ));\n    }\n    return groupingInfo[field] === groupingInfoPrev[field];\n  });\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport moment from 'moment';\nimport {\n  IsCellShadedFn, IsShadedAppointment,\n  GetCurrentTimeIndicatorTopFn,\n} from '../../types';\n\nexport const isMonthCell: PureComputed<\n  [boolean | undefined], boolean\n> = otherMonth => otherMonth !== undefined;\n\nexport const isShadedAppointment: IsShadedAppointment = (\n  { data: appointmentData }, currentTime, shadePreviousAppointments,\n) => {\n  const momentCurrentDate = moment(currentTime);\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate as Date, 'day')\n    && shadePreviousAppointments;\n  }\n  if (momentCurrentDate.isAfter(appointmentData.endDate as Date)) {\n    return shadePreviousAppointments;\n  }\n  return false;\n};\n\nexport const getCurrentTimeIndicatorTop: GetCurrentTimeIndicatorTopFn = (\n  cellData, currentTime,\n) => {\n  const top = ((currentTime - cellData.startDate.getTime()) * 100)\n  / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return (top < 0 || top > 100) ? undefined : `${top}%`;\n};\n\nexport const isCellShaded: IsCellShadedFn = (\n  { startDate, endDate, otherMonth }, currentTime, shadePreviousCells,\n) => {\n  const monthCell = isMonthCell(otherMonth);\n  return ((startDate.getTime() < currentTime && !monthCell)\n    || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n","import { GetAppointmentResources, ValidResourceInstance, ValidResource } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const getAppointmentResources: GetAppointmentResources = (\n  appointment, resources, plainResources,\n) => {\n  if (\n    !resources || resources.length === 0\n    || !plainResources || plainResources.length === 0\n  ) return [];\n\n  return resources.reduce((acc, resource) => {\n    const appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId)\n    || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return [\n        ...acc,\n        ...(appointmentResourceId as Array<number | string>)\n        .reduce((prevResources, itemId) => addResourceToAppointmentResources(\n          plainResources, prevResources, resource, itemId,\n        ) as Array<ValidResourceInstance>, [] as Array<ValidResourceInstance>),\n      ];\n    }\n\n    return addResourceToAppointmentResources(\n      plainResources, acc, resource, appointmentResourceId,\n    ) as Array<ValidResourceInstance>;\n  }, [] as Array<ValidResourceInstance>);\n};\n\nconst addResourceToAppointmentResources: PureComputed<\n  [Array<ValidResourceInstance>, Array<ValidResourceInstance>, ValidResource,\n  number | string], Array<ValidResourceInstance>\n> = (plainResources, appointmentResources, resource, resourceId) => {\n  const currentResource = plainResources.find(\n    plainItem => resource.fieldName === plainItem.fieldName && plainItem.id === resourceId,\n  );\n\n  return currentResource ? [\n    ...appointmentResources,\n    currentResource!,\n  ] : appointmentResources;\n};\n","import {\n  ConvertResourcesToPlain, ValidateResources, ValidResourceInstance, AddResourcesToAppointments,\n} from '../../types';\nimport { getAppointmentResources } from './helpers';\n\nexport const convertResourcesToPlain: ConvertResourcesToPlain = (validResources) => {\n  return validResources.reduce((acc, resource) => [\n    ...acc,\n    ...resource.instances.map(item => item),\n  ], [] as Array<ValidResourceInstance>);\n};\n\nexport const validateResources: ValidateResources = (resources, mainResourceName, palette) => {\n  const isMainResourceDefined = !!mainResourceName;\n  let currentPaletteIndex = 0;\n  return resources.map((resource, groupIndex) => {\n    const fieldName = resource.fieldName;\n    const isMain = isMainResourceDefined && mainResourceName === fieldName\n      || groupIndex === 0 && !isMainResourceDefined;\n    const title = resource.title || fieldName;\n    const allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName,\n      isMain,\n      title,\n      allowMultiple,\n      instances: resource.instances.map((resourceItem) => {\n        const color = resourceItem.color || palette[currentPaletteIndex % palette.length];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n\n        return ({\n          id: resourceItem.id,\n          color,\n          fieldName,\n          text: resourceItem.text || title || fieldName,\n          title,\n          allowMultiple,\n          isMain,\n        });\n      }),\n    };\n  });\n};\n\nexport const addResourcesToAppointments: AddResourcesToAppointments = (\n  appointments, resources, plainResources,\n) => [\n  appointments.map(appointment => ({\n    ...appointment,\n    resources: getAppointmentResources(appointment.dataItem, resources, plainResources),\n  })),\n];\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport {\n  ResourceGroupingState, ToggleGroupPayload,\n} from '../../types';\n\nexport const toggleExpandedGroups: PureReducer<ResourceGroupingState, ToggleGroupPayload> = (\n  state, { groupKey },\n) => {\n  const expandedGroups = slice(state.expandedGroups);\n  const groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return { expandedGroups };\n};\n","import moment, { Moment } from 'moment';\nimport { ViewCell } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const getDayScaleCellColSpan: PureComputed<\n  [ViewCell[][]], number\n> = (cellsData) => {\n  const firstDate = cellsData[0][0].startDate;\n  let count = 1;\n  while (cellsData[0][count] && moment(cellsData[0][count].startDate).isSame(firstDate, 'day')) {\n    count += 1;\n  }\n  return count;\n};\n\nexport const getDayScaleCells: PureComputed<\n[ViewCell[][], boolean], ViewCell[]\n> = (cellsData, groupedByDate) => {\n  if (!groupedByDate) {\n    return cellsData[0].map(({\n      startDate, endDate, today, endOfGroup, groupingInfo,\n    }, index) => ({\n      key: index.toString(),\n      startDate, endDate, today, endOfGroup, groupingInfo,\n    }));\n  }\n  let prevDate: Moment;\n  const colSpan = getDayScaleCellColSpan(cellsData);\n  return cellsData[0].reduce((acc, { startDate, endDate, today }, index) => {\n    const currentDate = moment(startDate);\n    if (currentDate.isSame(prevDate)) {\n      return acc;\n    }\n    prevDate = currentDate;\n    return [\n      ...acc, {\n        key: index.toString(),\n        startDate, endDate, today, colSpan,\n        endOfGroup: true,\n      },\n    ];\n  }, [] as ViewCell[]);\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { SchedulerDateTime } from '../../types';\nimport moment from 'moment';\n\nexport const navigateByOneMonth: PureComputed<\n  [SchedulerDateTime, boolean], Date\n> = (currentDate, isBackward) => moment(currentDate as SchedulerDateTime)\n  [isBackward ? 'subtract' : 'add'](1, 'month').toDate();\n","import { AppointmentModel, SchedulerDateTime } from './scheduler-core.types';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { RRULE_REPEAT_TYPES } from '../plugins/appointment-form/constants';\n\n/** @internal */\nexport type Action = ([fieldName]?: any) => void;\n/** @internal */\nexport type StartDate = SchedulerDateTime;\n/** @internal */\nexport type EndDate = SchedulerDateTime;\n/** @internal */\nexport type AppointmentDataPayload = {\n  appointmentData: AppointmentModel;\n};\n/** @internal */\nexport type AddedAppointmentDataPayload = {\n  appointmentData: AppointmentModel | {};\n};\n/** @internal */\nexport type RadioGroupDisplayData = {\n  weekNumber: number;\n  dayNumberTextField: number;\n  dayOfWeek: number;\n  radioGroupValue: string;\n};\n/** An option in the Select editor. */\nexport type SelectOption = {\n  /** The option's text. */\n  text: string;\n  /** The option's id. */\n  id: number | string;\n};\n/** @internal */\nexport type OptionsFormatterFn = PureComputed<\n  [(messageKey: string) => string], Array<SelectOption>\n>;\n/** @internal */\nexport type DateFormatterFn = PureComputed<\n  [(date: Date, formatOptions: object) => string], Array<SelectOption>\n>;\n/** @internal */\nexport enum RecurrenceFrequency {\n  Daily = RRULE_REPEAT_TYPES.DAILY,\n  Weekly = RRULE_REPEAT_TYPES.WEEKLY,\n  Monthly = RRULE_REPEAT_TYPES.MONTHLY,\n  Yearly = RRULE_REPEAT_TYPES.YEARLY,\n}\n"]},"metadata":{},"sourceType":"module"}